// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: relayer/relayer.proto

package relayer

import (
	context "context"
	fmt "fmt"
	_ "github.com/gogo/protobuf/gogoproto"
	proto "github.com/gogo/protobuf/proto"
	grpc "google.golang.org/grpc"
	codes "google.golang.org/grpc/codes"
	status "google.golang.org/grpc/status"
	io "io"
	math "math"
	math_bits "math/bits"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.GoGoProtoPackageIsVersion3 // please upgrade the proto package

type Status int32

const (
	UNKONWN     Status = 0
	NONE        Status = 1
	ERROR       Status = 2
	SUCCESS     Status = 200
	BAD_REQUEST Status = 400
	FORBIDDEN   Status = 403
)

var Status_name = map[int32]string{
	0:   "UNKONWN",
	1:   "NONE",
	2:   "ERROR",
	200: "SUCCESS",
	400: "BAD_REQUEST",
	403: "FORBIDDEN",
}

var Status_value = map[string]int32{
	"UNKONWN":     0,
	"NONE":        1,
	"ERROR":       2,
	"SUCCESS":     200,
	"BAD_REQUEST": 400,
	"FORBIDDEN":   403,
}

func (x Status) String() string {
	return proto.EnumName(Status_name, int32(x))
}

func (Status) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_66800904a3ba52be, []int{0}
}

type StatePhase int32

const (
	UNFINISH     StatePhase = 0
	FINISHED     StatePhase = 1
	REGISTER     StatePhase = 2
	REGISTERED   StatePhase = 3
	CROSSINVOKE  StatePhase = 4
	PREEXECUTE   StatePhase = 5
	PREEXECUTED  StatePhase = 6
	PREEXECUTERR StatePhase = 7
	COMMIT       StatePhase = 8
	COMMITTED    StatePhase = 9
	ROLLBACK     StatePhase = 10
	ROLLED       StatePhase = 11
)

var StatePhase_name = map[int32]string{
	0:  "UNFINISH",
	1:  "FINISHED",
	2:  "REGISTER",
	3:  "REGISTERED",
	4:  "CROSSINVOKE",
	5:  "PREEXECUTE",
	6:  "PREEXECUTED",
	7:  "PREEXECUTERR",
	8:  "COMMIT",
	9:  "COMMITTED",
	10: "ROLLBACK",
	11: "ROLLED",
}

var StatePhase_value = map[string]int32{
	"UNFINISH":     0,
	"FINISHED":     1,
	"REGISTER":     2,
	"REGISTERED":   3,
	"CROSSINVOKE":  4,
	"PREEXECUTE":   5,
	"PREEXECUTED":  6,
	"PREEXECUTERR": 7,
	"COMMIT":       8,
	"COMMITTED":    9,
	"ROLLBACK":     10,
	"ROLLED":       11,
}

func (x StatePhase) String() string {
	return proto.EnumName(StatePhase_name, int32(x))
}

func (StatePhase) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_66800904a3ba52be, []int{1}
}

type MsgType int32

const (
	NetMsg       MsgType = 0
	SdkMsg       MsgType = 1
	NetConfigMsg MsgType = 2
	SdkConfigMsg MsgType = 3
	QueryConfig  MsgType = 4
)

var MsgType_name = map[int32]string{
	0: "NetMsg",
	1: "SdkMsg",
	2: "NetConfigMsg",
	3: "SdkConfigMsg",
	4: "QueryConfig",
}

var MsgType_value = map[string]int32{
	"NetMsg":       0,
	"SdkMsg":       1,
	"NetConfigMsg": 2,
	"SdkConfigMsg": 3,
	"QueryConfig":  4,
}

func (x MsgType) String() string {
	return proto.EnumName(MsgType_name, int32(x))
}

func (MsgType) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_66800904a3ba52be, []int{2}
}

type NetMsgType int32

const (
	Register_Chain       NetMsgType = 0
	Register_Contract    NetMsgType = 1
	Update_Chain         NetMsgType = 2
	Update_Contract      NetMsgType = 3
	Sync_Chains          NetMsgType = 4
	PreExecute_Request   NetMsgType = 5
	PreExecute_Response  NetMsgType = 6
	Commit_Request       NetMsgType = 7
	Commit_Response      NetMsgType = 8
	Rollback_Request     NetMsgType = 9
	Rollback_Response    NetMsgType = 10
	Query_Chains         NetMsgType = 11
	Query_Contracts      NetMsgType = 12
	Query_ContractInfo   NetMsgType = 13
	Query_CrossEventInfo NetMsgType = 14
)

var NetMsgType_name = map[int32]string{
	0:  "Register_Chain",
	1:  "Register_Contract",
	2:  "Update_Chain",
	3:  "Update_Contract",
	4:  "Sync_Chains",
	5:  "PreExecute_Request",
	6:  "PreExecute_Response",
	7:  "Commit_Request",
	8:  "Commit_Response",
	9:  "Rollback_Request",
	10: "Rollback_Response",
	11: "Query_Chains",
	12: "Query_Contracts",
	13: "Query_ContractInfo",
	14: "Query_CrossEventInfo",
}

var NetMsgType_value = map[string]int32{
	"Register_Chain":       0,
	"Register_Contract":    1,
	"Update_Chain":         2,
	"Update_Contract":      3,
	"Sync_Chains":          4,
	"PreExecute_Request":   5,
	"PreExecute_Response":  6,
	"Commit_Request":       7,
	"Commit_Response":      8,
	"Rollback_Request":     9,
	"Rollback_Response":    10,
	"Query_Chains":         11,
	"Query_Contracts":      12,
	"Query_ContractInfo":   13,
	"Query_CrossEventInfo": 14,
}

func (x NetMsgType) String() string {
	return proto.EnumName(NetMsgType_name, int32(x))
}

func (NetMsgType) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_66800904a3ba52be, []int{3}
}

type Property int32

const (
	INITIATIVE Property = 0
	PASSIVE    Property = 1
)

var Property_name = map[int32]string{
	0: "INITIATIVE",
	1: "PASSIVE",
}

var Property_value = map[string]int32{
	"INITIATIVE": 0,
	"PASSIVE":    1,
}

func (x Property) String() string {
	return proto.EnumName(Property_name, int32(x))
}

func (Property) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_66800904a3ba52be, []int{4}
}

type State struct {
	Key   string     `protobuf:"bytes,1,opt,name=key,proto3" json:"key,omitempty"`
	State []byte     `protobuf:"bytes,2,opt,name=state,proto3" json:"state,omitempty"`
	Phase StatePhase `protobuf:"varint,3,opt,name=phase,proto3,enum=relayer.StatePhase" json:"phase,omitempty"`
}

func (m *State) Reset()         { *m = State{} }
func (m *State) String() string { return proto.CompactTextString(m) }
func (*State) ProtoMessage()    {}
func (*State) Descriptor() ([]byte, []int) {
	return fileDescriptor_66800904a3ba52be, []int{0}
}
func (m *State) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *State) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_State.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *State) XXX_Merge(src proto.Message) {
	xxx_messageInfo_State.Merge(m, src)
}
func (m *State) XXX_Size() int {
	return m.Size()
}
func (m *State) XXX_DiscardUnknown() {
	xxx_messageInfo_State.DiscardUnknown(m)
}

var xxx_messageInfo_State proto.InternalMessageInfo

type States struct {
	EncryptedStates []*State `protobuf:"bytes,1,rep,name=encryptedStates,proto3" json:"encryptedStates,omitempty"`
}

func (m *States) Reset()         { *m = States{} }
func (m *States) String() string { return proto.CompactTextString(m) }
func (*States) ProtoMessage()    {}
func (*States) Descriptor() ([]byte, []int) {
	return fileDescriptor_66800904a3ba52be, []int{1}
}
func (m *States) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *States) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_States.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *States) XXX_Merge(src proto.Message) {
	xxx_messageInfo_States.Merge(m, src)
}
func (m *States) XXX_Size() int {
	return m.Size()
}
func (m *States) XXX_DiscardUnknown() {
	xxx_messageInfo_States.DiscardUnknown(m)
}

var xxx_messageInfo_States proto.InternalMessageInfo

type ExecMsg struct {
	Status Status   `protobuf:"varint,1,opt,name=status,proto3,enum=relayer.Status" json:"status,omitempty"`
	Msg    [][]byte `protobuf:"bytes,2,rep,name=msg,proto3" json:"msg,omitempty"`
}

func (m *ExecMsg) Reset()         { *m = ExecMsg{} }
func (m *ExecMsg) String() string { return proto.CompactTextString(m) }
func (*ExecMsg) ProtoMessage()    {}
func (*ExecMsg) Descriptor() ([]byte, []int) {
	return fileDescriptor_66800904a3ba52be, []int{2}
}
func (m *ExecMsg) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ExecMsg) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ExecMsg.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ExecMsg) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ExecMsg.Merge(m, src)
}
func (m *ExecMsg) XXX_Size() int {
	return m.Size()
}
func (m *ExecMsg) XXX_DiscardUnknown() {
	xxx_messageInfo_ExecMsg.DiscardUnknown(m)
}

var xxx_messageInfo_ExecMsg proto.InternalMessageInfo

type DataIndex struct {
	Indexs []uint32 `protobuf:"varint,1,rep,packed,name=indexs,proto3" json:"indexs,omitempty"`
}

func (m *DataIndex) Reset()         { *m = DataIndex{} }
func (m *DataIndex) String() string { return proto.CompactTextString(m) }
func (*DataIndex) ProtoMessage()    {}
func (*DataIndex) Descriptor() ([]byte, []int) {
	return fileDescriptor_66800904a3ba52be, []int{3}
}
func (m *DataIndex) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *DataIndex) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_DataIndex.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *DataIndex) XXX_Merge(src proto.Message) {
	xxx_messageInfo_DataIndex.Merge(m, src)
}
func (m *DataIndex) XXX_Size() int {
	return m.Size()
}
func (m *DataIndex) XXX_DiscardUnknown() {
	xxx_messageInfo_DataIndex.DiscardUnknown(m)
}

var xxx_messageInfo_DataIndex proto.InternalMessageInfo

type ExecInput struct {
	Msg    *ExecMsg `protobuf:"bytes,1,opt,name=msg,proto3" json:"msg,omitempty"`
	States *States  `protobuf:"bytes,2,opt,name=states,proto3" json:"states,omitempty"`
	Cmd    uint32   `protobuf:"varint,3,opt,name=cmd,proto3" json:"cmd,omitempty"`
}

func (m *ExecInput) Reset()         { *m = ExecInput{} }
func (m *ExecInput) String() string { return proto.CompactTextString(m) }
func (*ExecInput) ProtoMessage()    {}
func (*ExecInput) Descriptor() ([]byte, []int) {
	return fileDescriptor_66800904a3ba52be, []int{4}
}
func (m *ExecInput) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ExecInput) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ExecInput.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ExecInput) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ExecInput.Merge(m, src)
}
func (m *ExecInput) XXX_Size() int {
	return m.Size()
}
func (m *ExecInput) XXX_DiscardUnknown() {
	xxx_messageInfo_ExecInput.DiscardUnknown(m)
}

var xxx_messageInfo_ExecInput proto.InternalMessageInfo

type ExecResponse struct {
	Status       Status         `protobuf:"varint,1,opt,name=status,proto3,enum=relayer.Status" json:"status,omitempty"`
	StatusMsg    string         `protobuf:"bytes,2,opt,name=status_msg,json=statusMsg,proto3" json:"status_msg,omitempty"`
	UpdateStates *States        `protobuf:"bytes,3,opt,name=updateStates,proto3" json:"updateStates,omitempty"`
	NextEvent    *NextExecution `protobuf:"bytes,4,opt,name=nextEvent,proto3" json:"nextEvent,omitempty"`
	Extension    []byte         `protobuf:"bytes,5,opt,name=extension,proto3" json:"extension,omitempty"`
}

func (m *ExecResponse) Reset()         { *m = ExecResponse{} }
func (m *ExecResponse) String() string { return proto.CompactTextString(m) }
func (*ExecResponse) ProtoMessage()    {}
func (*ExecResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_66800904a3ba52be, []int{5}
}
func (m *ExecResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ExecResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ExecResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ExecResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ExecResponse.Merge(m, src)
}
func (m *ExecResponse) XXX_Size() int {
	return m.Size()
}
func (m *ExecResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_ExecResponse.DiscardUnknown(m)
}

var xxx_messageInfo_ExecResponse proto.InternalMessageInfo

type RawMessage struct {
	Signature *RawMessage_Signature `protobuf:"bytes,1,opt,name=signature,proto3" json:"signature,omitempty"`
	Payload   []byte                `protobuf:"bytes,2,opt,name=payload,proto3" json:"payload,omitempty"`
}

func (m *RawMessage) Reset()         { *m = RawMessage{} }
func (m *RawMessage) String() string { return proto.CompactTextString(m) }
func (*RawMessage) ProtoMessage()    {}
func (*RawMessage) Descriptor() ([]byte, []int) {
	return fileDescriptor_66800904a3ba52be, []int{6}
}
func (m *RawMessage) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *RawMessage) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_RawMessage.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *RawMessage) XXX_Merge(src proto.Message) {
	xxx_messageInfo_RawMessage.Merge(m, src)
}
func (m *RawMessage) XXX_Size() int {
	return m.Size()
}
func (m *RawMessage) XXX_DiscardUnknown() {
	xxx_messageInfo_RawMessage.DiscardUnknown(m)
}

var xxx_messageInfo_RawMessage proto.InternalMessageInfo

type RawMessage_Signature struct {
	PubKey []byte `protobuf:"bytes,1,opt,name=pubKey,proto3" json:"pubKey,omitempty"`
	Sign   []byte `protobuf:"bytes,2,opt,name=sign,proto3" json:"sign,omitempty"`
}

func (m *RawMessage_Signature) Reset()         { *m = RawMessage_Signature{} }
func (m *RawMessage_Signature) String() string { return proto.CompactTextString(m) }
func (*RawMessage_Signature) ProtoMessage()    {}
func (*RawMessage_Signature) Descriptor() ([]byte, []int) {
	return fileDescriptor_66800904a3ba52be, []int{6, 0}
}
func (m *RawMessage_Signature) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *RawMessage_Signature) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_RawMessage_Signature.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *RawMessage_Signature) XXX_Merge(src proto.Message) {
	xxx_messageInfo_RawMessage_Signature.Merge(m, src)
}
func (m *RawMessage_Signature) XXX_Size() int {
	return m.Size()
}
func (m *RawMessage_Signature) XXX_DiscardUnknown() {
	xxx_messageInfo_RawMessage_Signature.DiscardUnknown(m)
}

var xxx_messageInfo_RawMessage_Signature proto.InternalMessageInfo

type ChainId struct {
	Chain   string `protobuf:"bytes,1,opt,name=chain,proto3" json:"chain,omitempty"`
	ChainId string `protobuf:"bytes,2,opt,name=chainId,proto3" json:"chainId,omitempty"`
}

func (m *ChainId) Reset()         { *m = ChainId{} }
func (m *ChainId) String() string { return proto.CompactTextString(m) }
func (*ChainId) ProtoMessage()    {}
func (*ChainId) Descriptor() ([]byte, []int) {
	return fileDescriptor_66800904a3ba52be, []int{7}
}
func (m *ChainId) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ChainId) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ChainId.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ChainId) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ChainId.Merge(m, src)
}
func (m *ChainId) XXX_Size() int {
	return m.Size()
}
func (m *ChainId) XXX_DiscardUnknown() {
	xxx_messageInfo_ChainId.DiscardUnknown(m)
}

var xxx_messageInfo_ChainId proto.InternalMessageInfo

type RegisteredChains struct {
	RelayerId string     `protobuf:"bytes,1,opt,name=relayerId,proto3" json:"relayerId,omitempty"`
	ChainIds  []*ChainId `protobuf:"bytes,2,rep,name=chainIds,proto3" json:"chainIds,omitempty"`
}

func (m *RegisteredChains) Reset()         { *m = RegisteredChains{} }
func (m *RegisteredChains) String() string { return proto.CompactTextString(m) }
func (*RegisteredChains) ProtoMessage()    {}
func (*RegisteredChains) Descriptor() ([]byte, []int) {
	return fileDescriptor_66800904a3ba52be, []int{8}
}
func (m *RegisteredChains) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *RegisteredChains) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_RegisteredChains.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *RegisteredChains) XXX_Merge(src proto.Message) {
	xxx_messageInfo_RegisteredChains.Merge(m, src)
}
func (m *RegisteredChains) XXX_Size() int {
	return m.Size()
}
func (m *RegisteredChains) XXX_DiscardUnknown() {
	xxx_messageInfo_RegisteredChains.DiscardUnknown(m)
}

var xxx_messageInfo_RegisteredChains proto.InternalMessageInfo

type OrgCa struct {
	OrgId  string `protobuf:"bytes,1,opt,name=orgId,proto3" json:"orgId,omitempty"`
	CaCert []byte `protobuf:"bytes,2,opt,name=caCert,proto3" json:"caCert,omitempty"`
}

func (m *OrgCa) Reset()         { *m = OrgCa{} }
func (m *OrgCa) String() string { return proto.CompactTextString(m) }
func (*OrgCa) ProtoMessage()    {}
func (*OrgCa) Descriptor() ([]byte, []int) {
	return fileDescriptor_66800904a3ba52be, []int{9}
}
func (m *OrgCa) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *OrgCa) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_OrgCa.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *OrgCa) XXX_Merge(src proto.Message) {
	xxx_messageInfo_OrgCa.Merge(m, src)
}
func (m *OrgCa) XXX_Size() int {
	return m.Size()
}
func (m *OrgCa) XXX_DiscardUnknown() {
	xxx_messageInfo_OrgCa.DiscardUnknown(m)
}

var xxx_messageInfo_OrgCa proto.InternalMessageInfo

type ChainCas struct {
	Chain    string   `protobuf:"bytes,1,opt,name=chain,proto3" json:"chain,omitempty"`
	ChainCas []*OrgCa `protobuf:"bytes,2,rep,name=chainCas,proto3" json:"chainCas,omitempty"`
}

func (m *ChainCas) Reset()         { *m = ChainCas{} }
func (m *ChainCas) String() string { return proto.CompactTextString(m) }
func (*ChainCas) ProtoMessage()    {}
func (*ChainCas) Descriptor() ([]byte, []int) {
	return fileDescriptor_66800904a3ba52be, []int{10}
}
func (m *ChainCas) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ChainCas) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ChainCas.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ChainCas) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ChainCas.Merge(m, src)
}
func (m *ChainCas) XXX_Size() int {
	return m.Size()
}
func (m *ChainCas) XXX_DiscardUnknown() {
	xxx_messageInfo_ChainCas.DiscardUnknown(m)
}

var xxx_messageInfo_ChainCas proto.InternalMessageInfo

type ChainContracts struct {
	Chain    string   `protobuf:"bytes,1,opt,name=chain,proto3" json:"chain,omitempty"`
	Contract []string `protobuf:"bytes,2,rep,name=contract,proto3" json:"contract,omitempty"`
}

func (m *ChainContracts) Reset()         { *m = ChainContracts{} }
func (m *ChainContracts) String() string { return proto.CompactTextString(m) }
func (*ChainContracts) ProtoMessage()    {}
func (*ChainContracts) Descriptor() ([]byte, []int) {
	return fileDescriptor_66800904a3ba52be, []int{11}
}
func (m *ChainContracts) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ChainContracts) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ChainContracts.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ChainContracts) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ChainContracts.Merge(m, src)
}
func (m *ChainContracts) XXX_Size() int {
	return m.Size()
}
func (m *ChainContracts) XXX_DiscardUnknown() {
	xxx_messageInfo_ChainContracts.DiscardUnknown(m)
}

var xxx_messageInfo_ChainContracts proto.InternalMessageInfo

type PhaseFunc struct {
	RegisterFunc  string `protobuf:"bytes,1,opt,name=registerFunc,proto3" json:"registerFunc,omitempty"`
	InitiatorFunc string `protobuf:"bytes,2,opt,name=initiatorFunc,proto3" json:"initiatorFunc,omitempty"`
	PrepareFunc   string `protobuf:"bytes,3,opt,name=prepareFunc,proto3" json:"prepareFunc,omitempty"`
	CommitFunc    string `protobuf:"bytes,4,opt,name=commitFunc,proto3" json:"commitFunc,omitempty"`
	RollbackFunc  string `protobuf:"bytes,5,opt,name=rollbackFunc,proto3" json:"rollbackFunc,omitempty"`
}

func (m *PhaseFunc) Reset()         { *m = PhaseFunc{} }
func (m *PhaseFunc) String() string { return proto.CompactTextString(m) }
func (*PhaseFunc) ProtoMessage()    {}
func (*PhaseFunc) Descriptor() ([]byte, []int) {
	return fileDescriptor_66800904a3ba52be, []int{12}
}
func (m *PhaseFunc) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *PhaseFunc) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_PhaseFunc.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *PhaseFunc) XXX_Merge(src proto.Message) {
	xxx_messageInfo_PhaseFunc.Merge(m, src)
}
func (m *PhaseFunc) XXX_Size() int {
	return m.Size()
}
func (m *PhaseFunc) XXX_DiscardUnknown() {
	xxx_messageInfo_PhaseFunc.DiscardUnknown(m)
}

var xxx_messageInfo_PhaseFunc proto.InternalMessageInfo

type ContractInfo struct {
	Name           string           `protobuf:"bytes,1,opt,name=name,proto3" json:"name,omitempty"`
	Chain          string           `protobuf:"bytes,2,opt,name=chain,proto3" json:"chain,omitempty"`
	Phase          StatePhase       `protobuf:"varint,3,opt,name=phase,proto3,enum=relayer.StatePhase" json:"phase,omitempty"`
	VerifyRule     string           `protobuf:"bytes,4,opt,name=verifyRule,proto3" json:"verifyRule,omitempty"`
	PhaseFuncGroup []*PhaseFunc     `protobuf:"bytes,5,rep,name=phaseFuncGroup,proto3" json:"phaseFuncGroup,omitempty"`
	InvokedList    []*CrossContract `protobuf:"bytes,6,rep,name=invokedList,proto3" json:"invokedList,omitempty"`
}

func (m *ContractInfo) Reset()         { *m = ContractInfo{} }
func (m *ContractInfo) String() string { return proto.CompactTextString(m) }
func (*ContractInfo) ProtoMessage()    {}
func (*ContractInfo) Descriptor() ([]byte, []int) {
	return fileDescriptor_66800904a3ba52be, []int{13}
}
func (m *ContractInfo) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ContractInfo) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ContractInfo.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ContractInfo) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ContractInfo.Merge(m, src)
}
func (m *ContractInfo) XXX_Size() int {
	return m.Size()
}
func (m *ContractInfo) XXX_DiscardUnknown() {
	xxx_messageInfo_ContractInfo.DiscardUnknown(m)
}

var xxx_messageInfo_ContractInfo proto.InternalMessageInfo

type SubAction struct {
	ChainId  string     `protobuf:"bytes,1,opt,name=chainId,proto3" json:"chainId,omitempty"`
	Chain    string     `protobuf:"bytes,2,opt,name=chain,proto3" json:"chain,omitempty"`
	Contract string     `protobuf:"bytes,3,opt,name=contract,proto3" json:"contract,omitempty"`
	Args     [][]byte   `protobuf:"bytes,4,rep,name=args,proto3" json:"args,omitempty"`
	Phase    StatePhase `protobuf:"varint,5,opt,name=phase,proto3,enum=relayer.StatePhase" json:"phase,omitempty"`
}

func (m *SubAction) Reset()         { *m = SubAction{} }
func (m *SubAction) String() string { return proto.CompactTextString(m) }
func (*SubAction) ProtoMessage()    {}
func (*SubAction) Descriptor() ([]byte, []int) {
	return fileDescriptor_66800904a3ba52be, []int{14}
}
func (m *SubAction) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *SubAction) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_SubAction.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *SubAction) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SubAction.Merge(m, src)
}
func (m *SubAction) XXX_Size() int {
	return m.Size()
}
func (m *SubAction) XXX_DiscardUnknown() {
	xxx_messageInfo_SubAction.DiscardUnknown(m)
}

var xxx_messageInfo_SubAction proto.InternalMessageInfo

type InvokePara struct {
	Action *SubAction `protobuf:"bytes,1,opt,name=action,proto3" json:"action,omitempty"`
	Funcs  *PhaseFunc `protobuf:"bytes,2,opt,name=funcs,proto3" json:"funcs,omitempty"`
}

func (m *InvokePara) Reset()         { *m = InvokePara{} }
func (m *InvokePara) String() string { return proto.CompactTextString(m) }
func (*InvokePara) ProtoMessage()    {}
func (*InvokePara) Descriptor() ([]byte, []int) {
	return fileDescriptor_66800904a3ba52be, []int{15}
}
func (m *InvokePara) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *InvokePara) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_InvokePara.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *InvokePara) XXX_Merge(src proto.Message) {
	xxx_messageInfo_InvokePara.Merge(m, src)
}
func (m *InvokePara) XXX_Size() int {
	return m.Size()
}
func (m *InvokePara) XXX_DiscardUnknown() {
	xxx_messageInfo_InvokePara.DiscardUnknown(m)
}

var xxx_messageInfo_InvokePara proto.InternalMessageInfo

type CrossContract struct {
	ChainId  string     `protobuf:"bytes,1,opt,name=chainId,proto3" json:"chainId,omitempty"`
	Contract string     `protobuf:"bytes,2,opt,name=contract,proto3" json:"contract,omitempty"`
	Phase    StatePhase `protobuf:"varint,3,opt,name=phase,proto3,enum=relayer.StatePhase" json:"phase,omitempty"`
}

func (m *CrossContract) Reset()         { *m = CrossContract{} }
func (m *CrossContract) String() string { return proto.CompactTextString(m) }
func (*CrossContract) ProtoMessage()    {}
func (*CrossContract) Descriptor() ([]byte, []int) {
	return fileDescriptor_66800904a3ba52be, []int{16}
}
func (m *CrossContract) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *CrossContract) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_CrossContract.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *CrossContract) XXX_Merge(src proto.Message) {
	xxx_messageInfo_CrossContract.Merge(m, src)
}
func (m *CrossContract) XXX_Size() int {
	return m.Size()
}
func (m *CrossContract) XXX_DiscardUnknown() {
	xxx_messageInfo_CrossContract.DiscardUnknown(m)
}

var xxx_messageInfo_CrossContract proto.InternalMessageInfo

type EventInfo struct {
	Property Property       `protobuf:"varint,1,opt,name=property,proto3,enum=relayer.Property" json:"property,omitempty"`
	EventId  string         `protobuf:"bytes,2,opt,name=eventId,proto3" json:"eventId,omitempty"`
	Launcher *CrossContract `protobuf:"bytes,3,opt,name=launcher,proto3" json:"launcher,omitempty"`
	Phase    StatePhase     `protobuf:"varint,4,opt,name=phase,proto3,enum=relayer.StatePhase" json:"phase,omitempty"`
	Invoke   []*InvokePara  `protobuf:"bytes,5,rep,name=invoke,proto3" json:"invoke,omitempty"`
	Actions  []*SubAction   `protobuf:"bytes,6,rep,name=actions,proto3" json:"actions,omitempty"`
}

func (m *EventInfo) Reset()         { *m = EventInfo{} }
func (m *EventInfo) String() string { return proto.CompactTextString(m) }
func (*EventInfo) ProtoMessage()    {}
func (*EventInfo) Descriptor() ([]byte, []int) {
	return fileDescriptor_66800904a3ba52be, []int{17}
}
func (m *EventInfo) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *EventInfo) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_EventInfo.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *EventInfo) XXX_Merge(src proto.Message) {
	xxx_messageInfo_EventInfo.Merge(m, src)
}
func (m *EventInfo) XXX_Size() int {
	return m.Size()
}
func (m *EventInfo) XXX_DiscardUnknown() {
	xxx_messageInfo_EventInfo.DiscardUnknown(m)
}

var xxx_messageInfo_EventInfo proto.InternalMessageInfo

type ChainUpdate struct {
	Chain    string     `protobuf:"bytes,1,opt,name=chain,proto3" json:"chain,omitempty"`
	Contract string     `protobuf:"bytes,2,opt,name=contract,proto3" json:"contract,omitempty"`
	Funcs    *PhaseFunc `protobuf:"bytes,3,opt,name=funcs,proto3" json:"funcs,omitempty"`
	Number   uint64     `protobuf:"varint,4,opt,name=number,proto3" json:"number,omitempty"`
}

func (m *ChainUpdate) Reset()         { *m = ChainUpdate{} }
func (m *ChainUpdate) String() string { return proto.CompactTextString(m) }
func (*ChainUpdate) ProtoMessage()    {}
func (*ChainUpdate) Descriptor() ([]byte, []int) {
	return fileDescriptor_66800904a3ba52be, []int{18}
}
func (m *ChainUpdate) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ChainUpdate) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ChainUpdate.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ChainUpdate) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ChainUpdate.Merge(m, src)
}
func (m *ChainUpdate) XXX_Size() int {
	return m.Size()
}
func (m *ChainUpdate) XXX_DiscardUnknown() {
	xxx_messageInfo_ChainUpdate.DiscardUnknown(m)
}

var xxx_messageInfo_ChainUpdate proto.InternalMessageInfo

type NextExecution struct {
	SdkAction []*InvokePara `protobuf:"bytes,1,rep,name=sdkAction,proto3" json:"sdkAction,omitempty"`
	RemoteMsg []*ChainMsg   `protobuf:"bytes,2,rep,name=remoteMsg,proto3" json:"remoteMsg,omitempty"`
	SignRes   *SignResponse `protobuf:"bytes,3,opt,name=signRes,proto3" json:"signRes,omitempty"`
	Update    *ChainUpdate  `protobuf:"bytes,4,opt,name=update,proto3" json:"update,omitempty"`
}

func (m *NextExecution) Reset()         { *m = NextExecution{} }
func (m *NextExecution) String() string { return proto.CompactTextString(m) }
func (*NextExecution) ProtoMessage()    {}
func (*NextExecution) Descriptor() ([]byte, []int) {
	return fileDescriptor_66800904a3ba52be, []int{19}
}
func (m *NextExecution) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *NextExecution) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_NextExecution.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *NextExecution) XXX_Merge(src proto.Message) {
	xxx_messageInfo_NextExecution.Merge(m, src)
}
func (m *NextExecution) XXX_Size() int {
	return m.Size()
}
func (m *NextExecution) XXX_DiscardUnknown() {
	xxx_messageInfo_NextExecution.DiscardUnknown(m)
}

var xxx_messageInfo_NextExecution proto.InternalMessageInfo

type ChainMsg struct {
	Payload   []byte `protobuf:"bytes,1,opt,name=payload,proto3" json:"payload,omitempty"`
	Sign      []byte `protobuf:"bytes,2,opt,name=sign,proto3" json:"sign,omitempty"`
	PubKey    []byte `protobuf:"bytes,3,opt,name=pubKey,proto3" json:"pubKey,omitempty"`
	RelayerId string `protobuf:"bytes,4,opt,name=relayerId,proto3" json:"relayerId,omitempty"`
}

func (m *ChainMsg) Reset()         { *m = ChainMsg{} }
func (m *ChainMsg) String() string { return proto.CompactTextString(m) }
func (*ChainMsg) ProtoMessage()    {}
func (*ChainMsg) Descriptor() ([]byte, []int) {
	return fileDescriptor_66800904a3ba52be, []int{20}
}
func (m *ChainMsg) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ChainMsg) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ChainMsg.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ChainMsg) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ChainMsg.Merge(m, src)
}
func (m *ChainMsg) XXX_Size() int {
	return m.Size()
}
func (m *ChainMsg) XXX_DiscardUnknown() {
	xxx_messageInfo_ChainMsg.DiscardUnknown(m)
}

var xxx_messageInfo_ChainMsg proto.InternalMessageInfo

type SignResponse struct {
	Payload []byte `protobuf:"bytes,1,opt,name=payload,proto3" json:"payload,omitempty"`
	Sign    []byte `protobuf:"bytes,2,opt,name=sign,proto3" json:"sign,omitempty"`
}

func (m *SignResponse) Reset()         { *m = SignResponse{} }
func (m *SignResponse) String() string { return proto.CompactTextString(m) }
func (*SignResponse) ProtoMessage()    {}
func (*SignResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_66800904a3ba52be, []int{21}
}
func (m *SignResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *SignResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_SignResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *SignResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SignResponse.Merge(m, src)
}
func (m *SignResponse) XXX_Size() int {
	return m.Size()
}
func (m *SignResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_SignResponse.DiscardUnknown(m)
}

var xxx_messageInfo_SignResponse proto.InternalMessageInfo

type ChainHeight struct {
	Chain       string `protobuf:"bytes,1,opt,name=chain,proto3" json:"chain,omitempty"`
	BlockNumber uint64 `protobuf:"varint,2,opt,name=blockNumber,proto3" json:"blockNumber,omitempty"`
}

func (m *ChainHeight) Reset()         { *m = ChainHeight{} }
func (m *ChainHeight) String() string { return proto.CompactTextString(m) }
func (*ChainHeight) ProtoMessage()    {}
func (*ChainHeight) Descriptor() ([]byte, []int) {
	return fileDescriptor_66800904a3ba52be, []int{22}
}
func (m *ChainHeight) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ChainHeight) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ChainHeight.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ChainHeight) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ChainHeight.Merge(m, src)
}
func (m *ChainHeight) XXX_Size() int {
	return m.Size()
}
func (m *ChainHeight) XXX_DiscardUnknown() {
	xxx_messageInfo_ChainHeight.DiscardUnknown(m)
}

var xxx_messageInfo_ChainHeight proto.InternalMessageInfo

type ChainsHeight struct {
	RelayerId string         `protobuf:"bytes,1,opt,name=relayerId,proto3" json:"relayerId,omitempty"`
	Chains    []*ChainHeight `protobuf:"bytes,2,rep,name=chains,proto3" json:"chains,omitempty"`
}

func (m *ChainsHeight) Reset()         { *m = ChainsHeight{} }
func (m *ChainsHeight) String() string { return proto.CompactTextString(m) }
func (*ChainsHeight) ProtoMessage()    {}
func (*ChainsHeight) Descriptor() ([]byte, []int) {
	return fileDescriptor_66800904a3ba52be, []int{23}
}
func (m *ChainsHeight) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ChainsHeight) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ChainsHeight.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ChainsHeight) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ChainsHeight.Merge(m, src)
}
func (m *ChainsHeight) XXX_Size() int {
	return m.Size()
}
func (m *ChainsHeight) XXX_DiscardUnknown() {
	xxx_messageInfo_ChainsHeight.DiscardUnknown(m)
}

var xxx_messageInfo_ChainsHeight proto.InternalMessageInfo

type Block struct {
	BlockNumber uint64   `protobuf:"varint,1,opt,name=blockNumber,proto3" json:"blockNumber,omitempty"`
	Payload     [][]byte `protobuf:"bytes,2,rep,name=payload,proto3" json:"payload,omitempty"`
}

func (m *Block) Reset()         { *m = Block{} }
func (m *Block) String() string { return proto.CompactTextString(m) }
func (*Block) ProtoMessage()    {}
func (*Block) Descriptor() ([]byte, []int) {
	return fileDescriptor_66800904a3ba52be, []int{24}
}
func (m *Block) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Block) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Block.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Block) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Block.Merge(m, src)
}
func (m *Block) XXX_Size() int {
	return m.Size()
}
func (m *Block) XXX_DiscardUnknown() {
	xxx_messageInfo_Block.DiscardUnknown(m)
}

var xxx_messageInfo_Block proto.InternalMessageInfo

type CrossMsg struct {
	Type    MsgType `protobuf:"varint,1,opt,name=type,proto3,enum=relayer.MsgType" json:"type,omitempty"`
	Payload []byte  `protobuf:"bytes,2,opt,name=payload,proto3" json:"payload,omitempty"`
}

func (m *CrossMsg) Reset()         { *m = CrossMsg{} }
func (m *CrossMsg) String() string { return proto.CompactTextString(m) }
func (*CrossMsg) ProtoMessage()    {}
func (*CrossMsg) Descriptor() ([]byte, []int) {
	return fileDescriptor_66800904a3ba52be, []int{25}
}
func (m *CrossMsg) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *CrossMsg) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_CrossMsg.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *CrossMsg) XXX_Merge(src proto.Message) {
	xxx_messageInfo_CrossMsg.Merge(m, src)
}
func (m *CrossMsg) XXX_Size() int {
	return m.Size()
}
func (m *CrossMsg) XXX_DiscardUnknown() {
	xxx_messageInfo_CrossMsg.DiscardUnknown(m)
}

var xxx_messageInfo_CrossMsg proto.InternalMessageInfo

type Request struct {
	Type    NetMsgType `protobuf:"varint,1,opt,name=type,proto3,enum=relayer.NetMsgType" json:"type,omitempty"`
	Payload []byte     `protobuf:"bytes,2,opt,name=payload,proto3" json:"payload,omitempty"`
}

func (m *Request) Reset()         { *m = Request{} }
func (m *Request) String() string { return proto.CompactTextString(m) }
func (*Request) ProtoMessage()    {}
func (*Request) Descriptor() ([]byte, []int) {
	return fileDescriptor_66800904a3ba52be, []int{26}
}
func (m *Request) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Request) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Request.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Request) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Request.Merge(m, src)
}
func (m *Request) XXX_Size() int {
	return m.Size()
}
func (m *Request) XXX_DiscardUnknown() {
	xxx_messageInfo_Request.DiscardUnknown(m)
}

var xxx_messageInfo_Request proto.InternalMessageInfo

type Response struct {
	Status     Status `protobuf:"varint,1,opt,name=status,proto3,enum=relayer.Status" json:"status,omitempty"`
	StatusInfo string `protobuf:"bytes,2,opt,name=statusInfo,proto3" json:"statusInfo,omitempty"`
	Payload    []byte `protobuf:"bytes,3,opt,name=payload,proto3" json:"payload,omitempty"`
}

func (m *Response) Reset()         { *m = Response{} }
func (m *Response) String() string { return proto.CompactTextString(m) }
func (*Response) ProtoMessage()    {}
func (*Response) Descriptor() ([]byte, []int) {
	return fileDescriptor_66800904a3ba52be, []int{27}
}
func (m *Response) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Response) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Response.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Response) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Response.Merge(m, src)
}
func (m *Response) XXX_Size() int {
	return m.Size()
}
func (m *Response) XXX_DiscardUnknown() {
	xxx_messageInfo_Response.DiscardUnknown(m)
}

var xxx_messageInfo_Response proto.InternalMessageInfo

type RegisterChain struct {
	Name   string    `protobuf:"bytes,1,opt,name=name,proto3" json:"name,omitempty"`
	Cas    *ChainCas `protobuf:"bytes,2,opt,name=cas,proto3" json:"cas,omitempty"`
	Height uint64    `protobuf:"varint,3,opt,name=height,proto3" json:"height,omitempty"`
}

func (m *RegisterChain) Reset()         { *m = RegisterChain{} }
func (m *RegisterChain) String() string { return proto.CompactTextString(m) }
func (*RegisterChain) ProtoMessage()    {}
func (*RegisterChain) Descriptor() ([]byte, []int) {
	return fileDescriptor_66800904a3ba52be, []int{28}
}
func (m *RegisterChain) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *RegisterChain) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_RegisterChain.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *RegisterChain) XXX_Merge(src proto.Message) {
	xxx_messageInfo_RegisterChain.Merge(m, src)
}
func (m *RegisterChain) XXX_Size() int {
	return m.Size()
}
func (m *RegisterChain) XXX_DiscardUnknown() {
	xxx_messageInfo_RegisterChain.DiscardUnknown(m)
}

var xxx_messageInfo_RegisterChain proto.InternalMessageInfo

type RegisterChainRes struct {
	Status     Status `protobuf:"varint,1,opt,name=status,proto3,enum=relayer.Status" json:"status,omitempty"`
	StatusInfo string `protobuf:"bytes,2,opt,name=statusInfo,proto3" json:"statusInfo,omitempty"`
	ChainAddr  string `protobuf:"bytes,3,opt,name=chainAddr,proto3" json:"chainAddr,omitempty"`
}

func (m *RegisterChainRes) Reset()         { *m = RegisterChainRes{} }
func (m *RegisterChainRes) String() string { return proto.CompactTextString(m) }
func (*RegisterChainRes) ProtoMessage()    {}
func (*RegisterChainRes) Descriptor() ([]byte, []int) {
	return fileDescriptor_66800904a3ba52be, []int{29}
}
func (m *RegisterChainRes) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *RegisterChainRes) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_RegisterChainRes.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *RegisterChainRes) XXX_Merge(src proto.Message) {
	xxx_messageInfo_RegisterChainRes.Merge(m, src)
}
func (m *RegisterChainRes) XXX_Size() int {
	return m.Size()
}
func (m *RegisterChainRes) XXX_DiscardUnknown() {
	xxx_messageInfo_RegisterChainRes.DiscardUnknown(m)
}

var xxx_messageInfo_RegisterChainRes proto.InternalMessageInfo

type RegisterContract struct {
	Name        string           `protobuf:"bytes,1,opt,name=name,proto3" json:"name,omitempty"`
	Chain       string           `protobuf:"bytes,2,opt,name=chain,proto3" json:"chain,omitempty"`
	VerifyRule  string           `protobuf:"bytes,3,opt,name=verifyRule,proto3" json:"verifyRule,omitempty"`
	InvokedList []*CrossContract `protobuf:"bytes,4,rep,name=invokedList,proto3" json:"invokedList,omitempty"`
}

func (m *RegisterContract) Reset()         { *m = RegisterContract{} }
func (m *RegisterContract) String() string { return proto.CompactTextString(m) }
func (*RegisterContract) ProtoMessage()    {}
func (*RegisterContract) Descriptor() ([]byte, []int) {
	return fileDescriptor_66800904a3ba52be, []int{30}
}
func (m *RegisterContract) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *RegisterContract) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_RegisterContract.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *RegisterContract) XXX_Merge(src proto.Message) {
	xxx_messageInfo_RegisterContract.Merge(m, src)
}
func (m *RegisterContract) XXX_Size() int {
	return m.Size()
}
func (m *RegisterContract) XXX_DiscardUnknown() {
	xxx_messageInfo_RegisterContract.DiscardUnknown(m)
}

var xxx_messageInfo_RegisterContract proto.InternalMessageInfo

type RegisterContractRes struct {
	Status     Status `protobuf:"varint,1,opt,name=status,proto3,enum=relayer.Status" json:"status,omitempty"`
	StatusInfo string `protobuf:"bytes,2,opt,name=statusInfo,proto3" json:"statusInfo,omitempty"`
}

func (m *RegisterContractRes) Reset()         { *m = RegisterContractRes{} }
func (m *RegisterContractRes) String() string { return proto.CompactTextString(m) }
func (*RegisterContractRes) ProtoMessage()    {}
func (*RegisterContractRes) Descriptor() ([]byte, []int) {
	return fileDescriptor_66800904a3ba52be, []int{31}
}
func (m *RegisterContractRes) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *RegisterContractRes) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_RegisterContractRes.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *RegisterContractRes) XXX_Merge(src proto.Message) {
	xxx_messageInfo_RegisterContractRes.Merge(m, src)
}
func (m *RegisterContractRes) XXX_Size() int {
	return m.Size()
}
func (m *RegisterContractRes) XXX_DiscardUnknown() {
	xxx_messageInfo_RegisterContractRes.DiscardUnknown(m)
}

var xxx_messageInfo_RegisterContractRes proto.InternalMessageInfo

type SyncChainsReq struct {
	Chains *RegisteredChains `protobuf:"bytes,1,opt,name=chains,proto3" json:"chains,omitempty"`
}

func (m *SyncChainsReq) Reset()         { *m = SyncChainsReq{} }
func (m *SyncChainsReq) String() string { return proto.CompactTextString(m) }
func (*SyncChainsReq) ProtoMessage()    {}
func (*SyncChainsReq) Descriptor() ([]byte, []int) {
	return fileDescriptor_66800904a3ba52be, []int{32}
}
func (m *SyncChainsReq) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *SyncChainsReq) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_SyncChainsReq.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *SyncChainsReq) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SyncChainsReq.Merge(m, src)
}
func (m *SyncChainsReq) XXX_Size() int {
	return m.Size()
}
func (m *SyncChainsReq) XXX_DiscardUnknown() {
	xxx_messageInfo_SyncChainsReq.DiscardUnknown(m)
}

var xxx_messageInfo_SyncChainsReq proto.InternalMessageInfo

type PreExecuteReq struct {
	EventId        string     `protobuf:"bytes,1,opt,name=eventId,proto3" json:"eventId,omitempty"`
	LaunchChainId  string     `protobuf:"bytes,2,opt,name=launchChainId,proto3" json:"launchChainId,omitempty"`
	LaunchContract string     `protobuf:"bytes,3,opt,name=launchContract,proto3" json:"launchContract,omitempty"`
	Action         *SubAction `protobuf:"bytes,4,opt,name=action,proto3" json:"action,omitempty"`
}

func (m *PreExecuteReq) Reset()         { *m = PreExecuteReq{} }
func (m *PreExecuteReq) String() string { return proto.CompactTextString(m) }
func (*PreExecuteReq) ProtoMessage()    {}
func (*PreExecuteReq) Descriptor() ([]byte, []int) {
	return fileDescriptor_66800904a3ba52be, []int{33}
}
func (m *PreExecuteReq) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *PreExecuteReq) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_PreExecuteReq.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *PreExecuteReq) XXX_Merge(src proto.Message) {
	xxx_messageInfo_PreExecuteReq.Merge(m, src)
}
func (m *PreExecuteReq) XXX_Size() int {
	return m.Size()
}
func (m *PreExecuteReq) XXX_DiscardUnknown() {
	xxx_messageInfo_PreExecuteReq.DiscardUnknown(m)
}

var xxx_messageInfo_PreExecuteReq proto.InternalMessageInfo

type PreExecuteResult struct {
	EventId    string `protobuf:"bytes,1,opt,name=eventId,proto3" json:"eventId,omitempty"`
	ChainId    string `protobuf:"bytes,2,opt,name=chainId,proto3" json:"chainId,omitempty"`
	Status     Status `protobuf:"varint,3,opt,name=status,proto3,enum=relayer.Status" json:"status,omitempty"`
	StatusInfo string `protobuf:"bytes,4,opt,name=statusInfo,proto3" json:"statusInfo,omitempty"`
}

func (m *PreExecuteResult) Reset()         { *m = PreExecuteResult{} }
func (m *PreExecuteResult) String() string { return proto.CompactTextString(m) }
func (*PreExecuteResult) ProtoMessage()    {}
func (*PreExecuteResult) Descriptor() ([]byte, []int) {
	return fileDescriptor_66800904a3ba52be, []int{34}
}
func (m *PreExecuteResult) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *PreExecuteResult) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_PreExecuteResult.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *PreExecuteResult) XXX_Merge(src proto.Message) {
	xxx_messageInfo_PreExecuteResult.Merge(m, src)
}
func (m *PreExecuteResult) XXX_Size() int {
	return m.Size()
}
func (m *PreExecuteResult) XXX_DiscardUnknown() {
	xxx_messageInfo_PreExecuteResult.DiscardUnknown(m)
}

var xxx_messageInfo_PreExecuteResult proto.InternalMessageInfo

type CommitReq struct {
	EventId string `protobuf:"bytes,1,opt,name=eventId,proto3" json:"eventId,omitempty"`
	ChainId string `protobuf:"bytes,2,opt,name=chainId,proto3" json:"chainId,omitempty"`
}

func (m *CommitReq) Reset()         { *m = CommitReq{} }
func (m *CommitReq) String() string { return proto.CompactTextString(m) }
func (*CommitReq) ProtoMessage()    {}
func (*CommitReq) Descriptor() ([]byte, []int) {
	return fileDescriptor_66800904a3ba52be, []int{35}
}
func (m *CommitReq) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *CommitReq) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_CommitReq.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *CommitReq) XXX_Merge(src proto.Message) {
	xxx_messageInfo_CommitReq.Merge(m, src)
}
func (m *CommitReq) XXX_Size() int {
	return m.Size()
}
func (m *CommitReq) XXX_DiscardUnknown() {
	xxx_messageInfo_CommitReq.DiscardUnknown(m)
}

var xxx_messageInfo_CommitReq proto.InternalMessageInfo

type CommitResult struct {
	EventId    string `protobuf:"bytes,1,opt,name=eventId,proto3" json:"eventId,omitempty"`
	ChainId    string `protobuf:"bytes,2,opt,name=chainId,proto3" json:"chainId,omitempty"`
	Status     Status `protobuf:"varint,3,opt,name=status,proto3,enum=relayer.Status" json:"status,omitempty"`
	StatusInfo string `protobuf:"bytes,4,opt,name=statusInfo,proto3" json:"statusInfo,omitempty"`
}

func (m *CommitResult) Reset()         { *m = CommitResult{} }
func (m *CommitResult) String() string { return proto.CompactTextString(m) }
func (*CommitResult) ProtoMessage()    {}
func (*CommitResult) Descriptor() ([]byte, []int) {
	return fileDescriptor_66800904a3ba52be, []int{36}
}
func (m *CommitResult) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *CommitResult) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_CommitResult.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *CommitResult) XXX_Merge(src proto.Message) {
	xxx_messageInfo_CommitResult.Merge(m, src)
}
func (m *CommitResult) XXX_Size() int {
	return m.Size()
}
func (m *CommitResult) XXX_DiscardUnknown() {
	xxx_messageInfo_CommitResult.DiscardUnknown(m)
}

var xxx_messageInfo_CommitResult proto.InternalMessageInfo

type RollbackReq struct {
	EventId string `protobuf:"bytes,1,opt,name=eventId,proto3" json:"eventId,omitempty"`
	ChainId string `protobuf:"bytes,2,opt,name=chainId,proto3" json:"chainId,omitempty"`
}

func (m *RollbackReq) Reset()         { *m = RollbackReq{} }
func (m *RollbackReq) String() string { return proto.CompactTextString(m) }
func (*RollbackReq) ProtoMessage()    {}
func (*RollbackReq) Descriptor() ([]byte, []int) {
	return fileDescriptor_66800904a3ba52be, []int{37}
}
func (m *RollbackReq) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *RollbackReq) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_RollbackReq.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *RollbackReq) XXX_Merge(src proto.Message) {
	xxx_messageInfo_RollbackReq.Merge(m, src)
}
func (m *RollbackReq) XXX_Size() int {
	return m.Size()
}
func (m *RollbackReq) XXX_DiscardUnknown() {
	xxx_messageInfo_RollbackReq.DiscardUnknown(m)
}

var xxx_messageInfo_RollbackReq proto.InternalMessageInfo

type RollbackResult struct {
	EventId    string `protobuf:"bytes,1,opt,name=eventId,proto3" json:"eventId,omitempty"`
	ChainId    string `protobuf:"bytes,2,opt,name=chainId,proto3" json:"chainId,omitempty"`
	Status     Status `protobuf:"varint,3,opt,name=status,proto3,enum=relayer.Status" json:"status,omitempty"`
	StatusInfo string `protobuf:"bytes,4,opt,name=statusInfo,proto3" json:"statusInfo,omitempty"`
}

func (m *RollbackResult) Reset()         { *m = RollbackResult{} }
func (m *RollbackResult) String() string { return proto.CompactTextString(m) }
func (*RollbackResult) ProtoMessage()    {}
func (*RollbackResult) Descriptor() ([]byte, []int) {
	return fileDescriptor_66800904a3ba52be, []int{38}
}
func (m *RollbackResult) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *RollbackResult) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_RollbackResult.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *RollbackResult) XXX_Merge(src proto.Message) {
	xxx_messageInfo_RollbackResult.Merge(m, src)
}
func (m *RollbackResult) XXX_Size() int {
	return m.Size()
}
func (m *RollbackResult) XXX_DiscardUnknown() {
	xxx_messageInfo_RollbackResult.DiscardUnknown(m)
}

var xxx_messageInfo_RollbackResult proto.InternalMessageInfo

type QueryChainsReq struct {
	RelayerId string `protobuf:"bytes,1,opt,name=relayerId,proto3" json:"relayerId,omitempty"`
}

func (m *QueryChainsReq) Reset()         { *m = QueryChainsReq{} }
func (m *QueryChainsReq) String() string { return proto.CompactTextString(m) }
func (*QueryChainsReq) ProtoMessage()    {}
func (*QueryChainsReq) Descriptor() ([]byte, []int) {
	return fileDescriptor_66800904a3ba52be, []int{39}
}
func (m *QueryChainsReq) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *QueryChainsReq) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_QueryChainsReq.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *QueryChainsReq) XXX_Merge(src proto.Message) {
	xxx_messageInfo_QueryChainsReq.Merge(m, src)
}
func (m *QueryChainsReq) XXX_Size() int {
	return m.Size()
}
func (m *QueryChainsReq) XXX_DiscardUnknown() {
	xxx_messageInfo_QueryChainsReq.DiscardUnknown(m)
}

var xxx_messageInfo_QueryChainsReq proto.InternalMessageInfo

type QueryChainsRes struct {
	RegisteredChains []*ChainId `protobuf:"bytes,2,rep,name=registeredChains,proto3" json:"registeredChains,omitempty"`
}

func (m *QueryChainsRes) Reset()         { *m = QueryChainsRes{} }
func (m *QueryChainsRes) String() string { return proto.CompactTextString(m) }
func (*QueryChainsRes) ProtoMessage()    {}
func (*QueryChainsRes) Descriptor() ([]byte, []int) {
	return fileDescriptor_66800904a3ba52be, []int{40}
}
func (m *QueryChainsRes) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *QueryChainsRes) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_QueryChainsRes.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *QueryChainsRes) XXX_Merge(src proto.Message) {
	xxx_messageInfo_QueryChainsRes.Merge(m, src)
}
func (m *QueryChainsRes) XXX_Size() int {
	return m.Size()
}
func (m *QueryChainsRes) XXX_DiscardUnknown() {
	xxx_messageInfo_QueryChainsRes.DiscardUnknown(m)
}

var xxx_messageInfo_QueryChainsRes proto.InternalMessageInfo

type QueryContractsReq struct {
	Chain string `protobuf:"bytes,1,opt,name=chain,proto3" json:"chain,omitempty"`
}

func (m *QueryContractsReq) Reset()         { *m = QueryContractsReq{} }
func (m *QueryContractsReq) String() string { return proto.CompactTextString(m) }
func (*QueryContractsReq) ProtoMessage()    {}
func (*QueryContractsReq) Descriptor() ([]byte, []int) {
	return fileDescriptor_66800904a3ba52be, []int{41}
}
func (m *QueryContractsReq) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *QueryContractsReq) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_QueryContractsReq.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *QueryContractsReq) XXX_Merge(src proto.Message) {
	xxx_messageInfo_QueryContractsReq.Merge(m, src)
}
func (m *QueryContractsReq) XXX_Size() int {
	return m.Size()
}
func (m *QueryContractsReq) XXX_DiscardUnknown() {
	xxx_messageInfo_QueryContractsReq.DiscardUnknown(m)
}

var xxx_messageInfo_QueryContractsReq proto.InternalMessageInfo

type QueryContractsRes struct {
	RegisteredContracts *ChainContracts `protobuf:"bytes,2,opt,name=registeredContracts,proto3" json:"registeredContracts,omitempty"`
}

func (m *QueryContractsRes) Reset()         { *m = QueryContractsRes{} }
func (m *QueryContractsRes) String() string { return proto.CompactTextString(m) }
func (*QueryContractsRes) ProtoMessage()    {}
func (*QueryContractsRes) Descriptor() ([]byte, []int) {
	return fileDescriptor_66800904a3ba52be, []int{42}
}
func (m *QueryContractsRes) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *QueryContractsRes) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_QueryContractsRes.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *QueryContractsRes) XXX_Merge(src proto.Message) {
	xxx_messageInfo_QueryContractsRes.Merge(m, src)
}
func (m *QueryContractsRes) XXX_Size() int {
	return m.Size()
}
func (m *QueryContractsRes) XXX_DiscardUnknown() {
	xxx_messageInfo_QueryContractsRes.DiscardUnknown(m)
}

var xxx_messageInfo_QueryContractsRes proto.InternalMessageInfo

type QueryContractInfoReq struct {
	Chain    string `protobuf:"bytes,1,opt,name=chain,proto3" json:"chain,omitempty"`
	Contract string `protobuf:"bytes,2,opt,name=contract,proto3" json:"contract,omitempty"`
}

func (m *QueryContractInfoReq) Reset()         { *m = QueryContractInfoReq{} }
func (m *QueryContractInfoReq) String() string { return proto.CompactTextString(m) }
func (*QueryContractInfoReq) ProtoMessage()    {}
func (*QueryContractInfoReq) Descriptor() ([]byte, []int) {
	return fileDescriptor_66800904a3ba52be, []int{43}
}
func (m *QueryContractInfoReq) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *QueryContractInfoReq) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_QueryContractInfoReq.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *QueryContractInfoReq) XXX_Merge(src proto.Message) {
	xxx_messageInfo_QueryContractInfoReq.Merge(m, src)
}
func (m *QueryContractInfoReq) XXX_Size() int {
	return m.Size()
}
func (m *QueryContractInfoReq) XXX_DiscardUnknown() {
	xxx_messageInfo_QueryContractInfoReq.DiscardUnknown(m)
}

var xxx_messageInfo_QueryContractInfoReq proto.InternalMessageInfo

type QueryContractInfoRes struct {
	ContractInfo *ContractInfo `protobuf:"bytes,2,opt,name=contractInfo,proto3" json:"contractInfo,omitempty"`
}

func (m *QueryContractInfoRes) Reset()         { *m = QueryContractInfoRes{} }
func (m *QueryContractInfoRes) String() string { return proto.CompactTextString(m) }
func (*QueryContractInfoRes) ProtoMessage()    {}
func (*QueryContractInfoRes) Descriptor() ([]byte, []int) {
	return fileDescriptor_66800904a3ba52be, []int{44}
}
func (m *QueryContractInfoRes) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *QueryContractInfoRes) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_QueryContractInfoRes.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *QueryContractInfoRes) XXX_Merge(src proto.Message) {
	xxx_messageInfo_QueryContractInfoRes.Merge(m, src)
}
func (m *QueryContractInfoRes) XXX_Size() int {
	return m.Size()
}
func (m *QueryContractInfoRes) XXX_DiscardUnknown() {
	xxx_messageInfo_QueryContractInfoRes.DiscardUnknown(m)
}

var xxx_messageInfo_QueryContractInfoRes proto.InternalMessageInfo

type QueryCrossEventInfoReq struct {
	RelayerId string `protobuf:"bytes,1,opt,name=relayerId,proto3" json:"relayerId,omitempty"`
	EventId   string `protobuf:"bytes,2,opt,name=eventId,proto3" json:"eventId,omitempty"`
}

func (m *QueryCrossEventInfoReq) Reset()         { *m = QueryCrossEventInfoReq{} }
func (m *QueryCrossEventInfoReq) String() string { return proto.CompactTextString(m) }
func (*QueryCrossEventInfoReq) ProtoMessage()    {}
func (*QueryCrossEventInfoReq) Descriptor() ([]byte, []int) {
	return fileDescriptor_66800904a3ba52be, []int{45}
}
func (m *QueryCrossEventInfoReq) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *QueryCrossEventInfoReq) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_QueryCrossEventInfoReq.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *QueryCrossEventInfoReq) XXX_Merge(src proto.Message) {
	xxx_messageInfo_QueryCrossEventInfoReq.Merge(m, src)
}
func (m *QueryCrossEventInfoReq) XXX_Size() int {
	return m.Size()
}
func (m *QueryCrossEventInfoReq) XXX_DiscardUnknown() {
	xxx_messageInfo_QueryCrossEventInfoReq.DiscardUnknown(m)
}

var xxx_messageInfo_QueryCrossEventInfoReq proto.InternalMessageInfo

type QueryCrossEventInfoRes struct {
	EventId      string           `protobuf:"bytes,1,opt,name=eventId,proto3" json:"eventId,omitempty"`
	Launcher     *CrossContract   `protobuf:"bytes,2,opt,name=launcher,proto3" json:"launcher,omitempty"`
	Phase        StatePhase       `protobuf:"varint,3,opt,name=phase,proto3,enum=relayer.StatePhase" json:"phase,omitempty"`
	Participants []*CrossContract `protobuf:"bytes,4,rep,name=participants,proto3" json:"participants,omitempty"`
}

func (m *QueryCrossEventInfoRes) Reset()         { *m = QueryCrossEventInfoRes{} }
func (m *QueryCrossEventInfoRes) String() string { return proto.CompactTextString(m) }
func (*QueryCrossEventInfoRes) ProtoMessage()    {}
func (*QueryCrossEventInfoRes) Descriptor() ([]byte, []int) {
	return fileDescriptor_66800904a3ba52be, []int{46}
}
func (m *QueryCrossEventInfoRes) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *QueryCrossEventInfoRes) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_QueryCrossEventInfoRes.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *QueryCrossEventInfoRes) XXX_Merge(src proto.Message) {
	xxx_messageInfo_QueryCrossEventInfoRes.Merge(m, src)
}
func (m *QueryCrossEventInfoRes) XXX_Size() int {
	return m.Size()
}
func (m *QueryCrossEventInfoRes) XXX_DiscardUnknown() {
	xxx_messageInfo_QueryCrossEventInfoRes.DiscardUnknown(m)
}

var xxx_messageInfo_QueryCrossEventInfoRes proto.InternalMessageInfo

type TxIndex struct {
	BlockNumber uint64 `protobuf:"varint,1,opt,name=blockNumber,proto3" json:"blockNumber,omitempty"`
	TxNumber    uint64 `protobuf:"varint,2,opt,name=txNumber,proto3" json:"txNumber,omitempty"`
}

func (m *TxIndex) Reset()         { *m = TxIndex{} }
func (m *TxIndex) String() string { return proto.CompactTextString(m) }
func (*TxIndex) ProtoMessage()    {}
func (*TxIndex) Descriptor() ([]byte, []int) {
	return fileDescriptor_66800904a3ba52be, []int{47}
}
func (m *TxIndex) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *TxIndex) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_TxIndex.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *TxIndex) XXX_Merge(src proto.Message) {
	xxx_messageInfo_TxIndex.Merge(m, src)
}
func (m *TxIndex) XXX_Size() int {
	return m.Size()
}
func (m *TxIndex) XXX_DiscardUnknown() {
	xxx_messageInfo_TxIndex.DiscardUnknown(m)
}

var xxx_messageInfo_TxIndex proto.InternalMessageInfo

type TxMsg struct {
	EventId  string     `protobuf:"bytes,1,opt,name=eventId,proto3" json:"eventId,omitempty"`
	Chain    string     `protobuf:"bytes,2,opt,name=chain,proto3" json:"chain,omitempty"`
	Contract string     `protobuf:"bytes,3,opt,name=contract,proto3" json:"contract,omitempty"`
	Phase    StatePhase `protobuf:"varint,4,opt,name=phase,proto3,enum=relayer.StatePhase" json:"phase,omitempty"`
	Index    *TxIndex   `protobuf:"bytes,5,opt,name=index,proto3" json:"index,omitempty"`
}

func (m *TxMsg) Reset()         { *m = TxMsg{} }
func (m *TxMsg) String() string { return proto.CompactTextString(m) }
func (*TxMsg) ProtoMessage()    {}
func (*TxMsg) Descriptor() ([]byte, []int) {
	return fileDescriptor_66800904a3ba52be, []int{48}
}
func (m *TxMsg) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *TxMsg) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_TxMsg.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *TxMsg) XXX_Merge(src proto.Message) {
	xxx_messageInfo_TxMsg.Merge(m, src)
}
func (m *TxMsg) XXX_Size() int {
	return m.Size()
}
func (m *TxMsg) XXX_DiscardUnknown() {
	xxx_messageInfo_TxMsg.DiscardUnknown(m)
}

var xxx_messageInfo_TxMsg proto.InternalMessageInfo

type SdkRawMsg struct {
	Chain       string   `protobuf:"bytes,1,opt,name=chain,proto3" json:"chain,omitempty"`
	BlockNumber uint64   `protobuf:"varint,2,opt,name=blockNumber,proto3" json:"blockNumber,omitempty"`
	ExecTxs     []*TxMsg `protobuf:"bytes,3,rep,name=execTxs,proto3" json:"execTxs,omitempty"`
	BlockResult []byte   `protobuf:"bytes,4,opt,name=blockResult,proto3" json:"blockResult,omitempty"`
}

func (m *SdkRawMsg) Reset()         { *m = SdkRawMsg{} }
func (m *SdkRawMsg) String() string { return proto.CompactTextString(m) }
func (*SdkRawMsg) ProtoMessage()    {}
func (*SdkRawMsg) Descriptor() ([]byte, []int) {
	return fileDescriptor_66800904a3ba52be, []int{49}
}
func (m *SdkRawMsg) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *SdkRawMsg) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_SdkRawMsg.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *SdkRawMsg) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SdkRawMsg.Merge(m, src)
}
func (m *SdkRawMsg) XXX_Size() int {
	return m.Size()
}
func (m *SdkRawMsg) XXX_DiscardUnknown() {
	xxx_messageInfo_SdkRawMsg.DiscardUnknown(m)
}

var xxx_messageInfo_SdkRawMsg proto.InternalMessageInfo

type BlockInfo struct {
	BlockNumber uint64   `protobuf:"varint,1,opt,name=blockNumber,proto3" json:"blockNumber,omitempty"`
	Chain       string   `protobuf:"bytes,2,opt,name=chain,proto3" json:"chain,omitempty"`
	TxsPayload  [][]byte `protobuf:"bytes,3,rep,name=txsPayload,proto3" json:"txsPayload,omitempty"`
	TxsValid    []bool   `protobuf:"varint,4,rep,packed,name=txsValid,proto3" json:"txsValid,omitempty"`
}

func (m *BlockInfo) Reset()         { *m = BlockInfo{} }
func (m *BlockInfo) String() string { return proto.CompactTextString(m) }
func (*BlockInfo) ProtoMessage()    {}
func (*BlockInfo) Descriptor() ([]byte, []int) {
	return fileDescriptor_66800904a3ba52be, []int{50}
}
func (m *BlockInfo) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *BlockInfo) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_BlockInfo.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *BlockInfo) XXX_Merge(src proto.Message) {
	xxx_messageInfo_BlockInfo.Merge(m, src)
}
func (m *BlockInfo) XXX_Size() int {
	return m.Size()
}
func (m *BlockInfo) XXX_DiscardUnknown() {
	xxx_messageInfo_BlockInfo.DiscardUnknown(m)
}

var xxx_messageInfo_BlockInfo proto.InternalMessageInfo

type InvokeChainInfo struct {
	ChainAddr string   `protobuf:"bytes,1,opt,name=chainAddr,proto3" json:"chainAddr,omitempty"`
	Chain     string   `protobuf:"bytes,2,opt,name=chain,proto3" json:"chain,omitempty"`
	Contract  string   `protobuf:"bytes,3,opt,name=contract,proto3" json:"contract,omitempty"`
	Func      string   `protobuf:"bytes,4,opt,name=func,proto3" json:"func,omitempty"`
	Args      [][]byte `protobuf:"bytes,5,rep,name=args,proto3" json:"args,omitempty"`
}

func (m *InvokeChainInfo) Reset()         { *m = InvokeChainInfo{} }
func (m *InvokeChainInfo) String() string { return proto.CompactTextString(m) }
func (*InvokeChainInfo) ProtoMessage()    {}
func (*InvokeChainInfo) Descriptor() ([]byte, []int) {
	return fileDescriptor_66800904a3ba52be, []int{51}
}
func (m *InvokeChainInfo) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *InvokeChainInfo) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_InvokeChainInfo.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *InvokeChainInfo) XXX_Merge(src proto.Message) {
	xxx_messageInfo_InvokeChainInfo.Merge(m, src)
}
func (m *InvokeChainInfo) XXX_Size() int {
	return m.Size()
}
func (m *InvokeChainInfo) XXX_DiscardUnknown() {
	xxx_messageInfo_InvokeChainInfo.DiscardUnknown(m)
}

var xxx_messageInfo_InvokeChainInfo proto.InternalMessageInfo

type CrossInvoke struct {
	EventId      string             `protobuf:"bytes,1,opt,name=eventId,proto3" json:"eventId,omitempty"`
	Initiator    *InvokeChainInfo   `protobuf:"bytes,2,opt,name=initiator,proto3" json:"initiator,omitempty"`
	Participants []*InvokeChainInfo `protobuf:"bytes,3,rep,name=participants,proto3" json:"participants,omitempty"`
}

func (m *CrossInvoke) Reset()         { *m = CrossInvoke{} }
func (m *CrossInvoke) String() string { return proto.CompactTextString(m) }
func (*CrossInvoke) ProtoMessage()    {}
func (*CrossInvoke) Descriptor() ([]byte, []int) {
	return fileDescriptor_66800904a3ba52be, []int{52}
}
func (m *CrossInvoke) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *CrossInvoke) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_CrossInvoke.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *CrossInvoke) XXX_Merge(src proto.Message) {
	xxx_messageInfo_CrossInvoke.Merge(m, src)
}
func (m *CrossInvoke) XXX_Size() int {
	return m.Size()
}
func (m *CrossInvoke) XXX_DiscardUnknown() {
	xxx_messageInfo_CrossInvoke.DiscardUnknown(m)
}

var xxx_messageInfo_CrossInvoke proto.InternalMessageInfo

type RegContract struct {
	Contract  string       `protobuf:"bytes,1,opt,name=contract,proto3" json:"contract,omitempty"`
	Func      string       `protobuf:"bytes,2,opt,name=func,proto3" json:"func,omitempty"`
	Phasefunc []*PhaseFunc `protobuf:"bytes,3,rep,name=phasefunc,proto3" json:"phasefunc,omitempty"`
}

func (m *RegContract) Reset()         { *m = RegContract{} }
func (m *RegContract) String() string { return proto.CompactTextString(m) }
func (*RegContract) ProtoMessage()    {}
func (*RegContract) Descriptor() ([]byte, []int) {
	return fileDescriptor_66800904a3ba52be, []int{53}
}
func (m *RegContract) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *RegContract) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_RegContract.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *RegContract) XXX_Merge(src proto.Message) {
	xxx_messageInfo_RegContract.Merge(m, src)
}
func (m *RegContract) XXX_Size() int {
	return m.Size()
}
func (m *RegContract) XXX_DiscardUnknown() {
	xxx_messageInfo_RegContract.DiscardUnknown(m)
}

var xxx_messageInfo_RegContract proto.InternalMessageInfo

type WasmInvokeRes struct {
	Status     Status `protobuf:"varint,1,opt,name=status,proto3,enum=relayer.Status" json:"status,omitempty"`
	StatusInfo string `protobuf:"bytes,2,opt,name=statusInfo,proto3" json:"statusInfo,omitempty"`
	Result     []byte `protobuf:"bytes,3,opt,name=result,proto3" json:"result,omitempty"`
}

func (m *WasmInvokeRes) Reset()         { *m = WasmInvokeRes{} }
func (m *WasmInvokeRes) String() string { return proto.CompactTextString(m) }
func (*WasmInvokeRes) ProtoMessage()    {}
func (*WasmInvokeRes) Descriptor() ([]byte, []int) {
	return fileDescriptor_66800904a3ba52be, []int{54}
}
func (m *WasmInvokeRes) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *WasmInvokeRes) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_WasmInvokeRes.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *WasmInvokeRes) XXX_Merge(src proto.Message) {
	xxx_messageInfo_WasmInvokeRes.Merge(m, src)
}
func (m *WasmInvokeRes) XXX_Size() int {
	return m.Size()
}
func (m *WasmInvokeRes) XXX_DiscardUnknown() {
	xxx_messageInfo_WasmInvokeRes.DiscardUnknown(m)
}

var xxx_messageInfo_WasmInvokeRes proto.InternalMessageInfo

type Replay struct {
}

func (m *Replay) Reset()         { *m = Replay{} }
func (m *Replay) String() string { return proto.CompactTextString(m) }
func (*Replay) ProtoMessage()    {}
func (*Replay) Descriptor() ([]byte, []int) {
	return fileDescriptor_66800904a3ba52be, []int{55}
}
func (m *Replay) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Replay) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Replay.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Replay) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Replay.Merge(m, src)
}
func (m *Replay) XXX_Size() int {
	return m.Size()
}
func (m *Replay) XXX_DiscardUnknown() {
	xxx_messageInfo_Replay.DiscardUnknown(m)
}

var xxx_messageInfo_Replay proto.InternalMessageInfo

func init() {
	proto.RegisterEnum("relayer.Status", Status_name, Status_value)
	proto.RegisterEnum("relayer.StatePhase", StatePhase_name, StatePhase_value)
	proto.RegisterEnum("relayer.MsgType", MsgType_name, MsgType_value)
	proto.RegisterEnum("relayer.NetMsgType", NetMsgType_name, NetMsgType_value)
	proto.RegisterEnum("relayer.Property", Property_name, Property_value)
	proto.RegisterType((*State)(nil), "relayer.State")
	proto.RegisterType((*States)(nil), "relayer.States")
	proto.RegisterType((*ExecMsg)(nil), "relayer.ExecMsg")
	proto.RegisterType((*DataIndex)(nil), "relayer.DataIndex")
	proto.RegisterType((*ExecInput)(nil), "relayer.ExecInput")
	proto.RegisterType((*ExecResponse)(nil), "relayer.ExecResponse")
	proto.RegisterType((*RawMessage)(nil), "relayer.RawMessage")
	proto.RegisterType((*RawMessage_Signature)(nil), "relayer.RawMessage.Signature")
	proto.RegisterType((*ChainId)(nil), "relayer.ChainId")
	proto.RegisterType((*RegisteredChains)(nil), "relayer.RegisteredChains")
	proto.RegisterType((*OrgCa)(nil), "relayer.OrgCa")
	proto.RegisterType((*ChainCas)(nil), "relayer.ChainCas")
	proto.RegisterType((*ChainContracts)(nil), "relayer.ChainContracts")
	proto.RegisterType((*PhaseFunc)(nil), "relayer.PhaseFunc")
	proto.RegisterType((*ContractInfo)(nil), "relayer.ContractInfo")
	proto.RegisterType((*SubAction)(nil), "relayer.SubAction")
	proto.RegisterType((*InvokePara)(nil), "relayer.InvokePara")
	proto.RegisterType((*CrossContract)(nil), "relayer.CrossContract")
	proto.RegisterType((*EventInfo)(nil), "relayer.EventInfo")
	proto.RegisterType((*ChainUpdate)(nil), "relayer.ChainUpdate")
	proto.RegisterType((*NextExecution)(nil), "relayer.NextExecution")
	proto.RegisterType((*ChainMsg)(nil), "relayer.ChainMsg")
	proto.RegisterType((*SignResponse)(nil), "relayer.SignResponse")
	proto.RegisterType((*ChainHeight)(nil), "relayer.ChainHeight")
	proto.RegisterType((*ChainsHeight)(nil), "relayer.ChainsHeight")
	proto.RegisterType((*Block)(nil), "relayer.Block")
	proto.RegisterType((*CrossMsg)(nil), "relayer.CrossMsg")
	proto.RegisterType((*Request)(nil), "relayer.Request")
	proto.RegisterType((*Response)(nil), "relayer.Response")
	proto.RegisterType((*RegisterChain)(nil), "relayer.RegisterChain")
	proto.RegisterType((*RegisterChainRes)(nil), "relayer.RegisterChainRes")
	proto.RegisterType((*RegisterContract)(nil), "relayer.RegisterContract")
	proto.RegisterType((*RegisterContractRes)(nil), "relayer.RegisterContractRes")
	proto.RegisterType((*SyncChainsReq)(nil), "relayer.SyncChainsReq")
	proto.RegisterType((*PreExecuteReq)(nil), "relayer.PreExecuteReq")
	proto.RegisterType((*PreExecuteResult)(nil), "relayer.PreExecuteResult")
	proto.RegisterType((*CommitReq)(nil), "relayer.CommitReq")
	proto.RegisterType((*CommitResult)(nil), "relayer.CommitResult")
	proto.RegisterType((*RollbackReq)(nil), "relayer.RollbackReq")
	proto.RegisterType((*RollbackResult)(nil), "relayer.RollbackResult")
	proto.RegisterType((*QueryChainsReq)(nil), "relayer.QueryChainsReq")
	proto.RegisterType((*QueryChainsRes)(nil), "relayer.QueryChainsRes")
	proto.RegisterType((*QueryContractsReq)(nil), "relayer.QueryContractsReq")
	proto.RegisterType((*QueryContractsRes)(nil), "relayer.QueryContractsRes")
	proto.RegisterType((*QueryContractInfoReq)(nil), "relayer.QueryContractInfoReq")
	proto.RegisterType((*QueryContractInfoRes)(nil), "relayer.QueryContractInfoRes")
	proto.RegisterType((*QueryCrossEventInfoReq)(nil), "relayer.QueryCrossEventInfoReq")
	proto.RegisterType((*QueryCrossEventInfoRes)(nil), "relayer.QueryCrossEventInfoRes")
	proto.RegisterType((*TxIndex)(nil), "relayer.TxIndex")
	proto.RegisterType((*TxMsg)(nil), "relayer.TxMsg")
	proto.RegisterType((*SdkRawMsg)(nil), "relayer.SdkRawMsg")
	proto.RegisterType((*BlockInfo)(nil), "relayer.BlockInfo")
	proto.RegisterType((*InvokeChainInfo)(nil), "relayer.InvokeChainInfo")
	proto.RegisterType((*CrossInvoke)(nil), "relayer.CrossInvoke")
	proto.RegisterType((*RegContract)(nil), "relayer.RegContract")
	proto.RegisterType((*WasmInvokeRes)(nil), "relayer.WasmInvokeRes")
	proto.RegisterType((*Replay)(nil), "relayer.Replay")
}

func init() { proto.RegisterFile("relayer/relayer.proto", fileDescriptor_66800904a3ba52be) }

var fileDescriptor_66800904a3ba52be = []byte{
	// 2368 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xc4, 0x59, 0xcd, 0x6f, 0x1b, 0xc7,
	0x15, 0xe7, 0xf2, 0x7b, 0x1f, 0x3f, 0xb4, 0x1e, 0xd9, 0x0e, 0x6b, 0x24, 0x82, 0x30, 0x31, 0x62,
	0x45, 0x75, 0xa5, 0x46, 0x69, 0xd3, 0x38, 0x31, 0x50, 0x48, 0x14, 0x6d, 0xb3, 0xb6, 0x28, 0x79,
	0x28, 0x39, 0x85, 0x0f, 0x76, 0x57, 0xcb, 0x11, 0xb5, 0x95, 0xb8, 0xbb, 0xd9, 0x59, 0xda, 0xe4,
	0xa5, 0x45, 0x8f, 0x45, 0xd1, 0x36, 0x40, 0x81, 0x9e, 0xda, 0x53, 0x81, 0xfe, 0x13, 0x3d, 0xe4,
	0xea, 0x4b, 0x51, 0xa3, 0xa7, 0xde, 0xda, 0xd8, 0x7f, 0x45, 0x6f, 0xc1, 0x7c, 0xec, 0x17, 0x45,
	0xea, 0xc3, 0x30, 0x90, 0x13, 0x67, 0xde, 0xfe, 0xe6, 0xcd, 0x7b, 0x6f, 0xde, 0xcc, 0xfb, 0xcd,
	0x10, 0xae, 0xf8, 0xf4, 0xd8, 0x1c, 0x53, 0x7f, 0x55, 0xfd, 0xae, 0x78, 0xbe, 0x1b, 0xb8, 0xa8,
	0xa4, 0xba, 0xd7, 0x2e, 0xf7, 0xdd, 0xbe, 0x2b, 0x64, 0xab, 0xbc, 0x25, 0x3f, 0xe3, 0xc7, 0x50,
	0xe8, 0x06, 0x66, 0x40, 0x91, 0x01, 0xb9, 0x23, 0x3a, 0x6e, 0x68, 0x8b, 0xda, 0x92, 0x4e, 0x78,
	0x13, 0x5d, 0x86, 0x02, 0xe3, 0x9f, 0x1a, 0xd9, 0x45, 0x6d, 0xa9, 0x4a, 0x64, 0x07, 0x7d, 0x08,
	0x05, 0xef, 0xd0, 0x64, 0xb4, 0x91, 0x5b, 0xd4, 0x96, 0xea, 0x6b, 0xf3, 0x2b, 0xe1, 0x74, 0x42,
	0xcd, 0x0e, 0xff, 0x44, 0x24, 0x02, 0x6f, 0x40, 0x51, 0x08, 0x19, 0xfa, 0x14, 0xe6, 0xa8, 0x63,
	0xf9, 0x63, 0x2f, 0xa0, 0x3d, 0x29, 0x6a, 0x68, 0x8b, 0xb9, 0xa5, 0xca, 0x5a, 0x3d, 0x3d, 0x9c,
	0x4c, 0xc2, 0xf0, 0x26, 0x94, 0x5a, 0x23, 0x6a, 0x6d, 0xb1, 0x3e, 0xba, 0x01, 0x45, 0x6e, 0xc2,
	0x90, 0x09, 0x23, 0xeb, 0x6b, 0x73, 0xa9, 0xb1, 0x43, 0x46, 0xd4, 0x67, 0xee, 0xca, 0x80, 0xf5,
	0x1b, 0xd9, 0xc5, 0xdc, 0x52, 0x95, 0xf0, 0x26, 0x7e, 0x1f, 0xf4, 0x4d, 0x33, 0x30, 0xdb, 0x4e,
	0x8f, 0x8e, 0xd0, 0x55, 0x28, 0xda, 0xbc, 0x21, 0x6d, 0xa8, 0x11, 0xd5, 0xc3, 0xbf, 0x04, 0x9d,
	0x4f, 0xd5, 0x76, 0xbc, 0x61, 0x80, 0xb0, 0xd4, 0xc1, 0x67, 0xaa, 0xac, 0x19, 0xd1, 0x4c, 0xca,
	0x16, 0xa1, 0x35, 0x34, 0x88, 0x32, 0x11, 0xa1, 0xca, 0x84, 0x41, 0x54, 0x19, 0x44, 0x85, 0x41,
	0xd6, 0xa0, 0x27, 0x22, 0x56, 0x23, 0xbc, 0x89, 0xff, 0xab, 0x41, 0x95, 0xeb, 0x22, 0x94, 0x79,
	0xae, 0xc3, 0xe8, 0xf9, 0x9d, 0x7b, 0x0f, 0x40, 0xb6, 0x9e, 0x4a, 0x1f, 0xf9, 0x72, 0xe9, 0x52,
	0xc2, 0x83, 0xf4, 0x31, 0x54, 0x87, 0x5e, 0xcf, 0x0c, 0xa8, 0x0a, 0x73, 0x6e, 0xba, 0x65, 0x29,
	0x10, 0xfa, 0x11, 0xe8, 0x0e, 0x1d, 0x05, 0xad, 0x67, 0xd4, 0x09, 0x1a, 0x79, 0x31, 0xe2, 0x6a,
	0x34, 0xa2, 0xc3, 0xbf, 0x8c, 0xa8, 0x35, 0x0c, 0x6c, 0xd7, 0x21, 0x31, 0x10, 0xbd, 0x0b, 0x3a,
	0x1d, 0x05, 0xd4, 0x61, 0xb6, 0xeb, 0x34, 0x0a, 0x22, 0x47, 0x62, 0x01, 0xfe, 0x8b, 0x06, 0x40,
	0xcc, 0xe7, 0x5b, 0x94, 0x31, 0xb3, 0x4f, 0xd1, 0xe7, 0xa0, 0x33, 0xbb, 0xef, 0x98, 0xc1, 0xd0,
	0xa7, 0x2a, 0xaa, 0xef, 0x45, 0x53, 0xc4, 0xb8, 0x95, 0x6e, 0x08, 0x22, 0x31, 0x1e, 0x35, 0xa0,
	0xe4, 0x99, 0xe3, 0x63, 0xd7, 0xec, 0xa9, 0x5c, 0x0c, 0xbb, 0xd7, 0x7e, 0x02, 0x7a, 0x34, 0x82,
	0x2f, 0xac, 0x37, 0xdc, 0xbf, 0xaf, 0xb2, 0xb8, 0x4a, 0x54, 0x0f, 0x21, 0xc8, 0x73, 0x5d, 0x6a,
	0xac, 0x68, 0xe3, 0x5b, 0x50, 0x6a, 0x1e, 0x9a, 0xb6, 0xd3, 0xee, 0xf1, 0x3c, 0xb7, 0x78, 0x53,
	0xe5, 0xbe, 0xec, 0xf0, 0x39, 0x2d, 0x09, 0x50, 0x41, 0x0e, 0xbb, 0xf8, 0x09, 0x18, 0x84, 0xf6,
	0x6d, 0x16, 0x50, 0x9f, 0xf6, 0x84, 0x12, 0xc6, 0x63, 0xa1, 0x9c, 0x69, 0xf7, 0x94, 0x9e, 0x58,
	0x80, 0x6e, 0x42, 0x59, 0x0d, 0x66, 0x22, 0x2b, 0x93, 0x19, 0xa5, 0xac, 0x20, 0x11, 0x02, 0xff,
	0x18, 0x0a, 0xdb, 0x7e, 0xbf, 0x69, 0x72, 0xc3, 0x5c, 0xbf, 0x1f, 0x29, 0x94, 0x1d, 0xee, 0xa5,
	0x65, 0x36, 0xa9, 0x1f, 0x28, 0x7f, 0x54, 0x0f, 0x3f, 0x80, 0xb2, 0xd0, 0xd5, 0x34, 0xd9, 0x0c,
	0x97, 0x96, 0x95, 0x19, 0x4d, 0x33, 0x34, 0x23, 0xde, 0x7e, 0x62, 0x46, 0x12, 0x7d, 0xc7, 0x1b,
	0x50, 0x97, 0xda, 0x5c, 0x27, 0xf0, 0x4d, 0x2b, 0x98, 0xa5, 0xf3, 0x1a, 0x94, 0x2d, 0x05, 0x11,
	0x3a, 0x75, 0x12, 0xf5, 0xf1, 0x3f, 0x34, 0xd0, 0xc5, 0x81, 0x70, 0x67, 0xe8, 0x58, 0x08, 0x43,
	0xd5, 0x57, 0x61, 0xe3, 0x7d, 0xa5, 0x26, 0x25, 0x43, 0xd7, 0xa1, 0x66, 0x3b, 0x76, 0x60, 0x9b,
	0x81, 0x2b, 0x41, 0x32, 0xf4, 0x69, 0x21, 0x5a, 0x84, 0x8a, 0xe7, 0x53, 0xcf, 0xf4, 0x85, 0x62,
	0x91, 0xe2, 0x3a, 0x49, 0x8a, 0xd0, 0x02, 0x80, 0xe5, 0x0e, 0x06, 0x76, 0x20, 0x00, 0x79, 0x01,
	0x48, 0x48, 0x84, 0x2d, 0xee, 0xf1, 0xf1, 0xbe, 0x69, 0x1d, 0x09, 0x44, 0x41, 0xd9, 0x92, 0x90,
	0xe1, 0xff, 0x6b, 0x50, 0x0d, 0xbd, 0x6f, 0x3b, 0x07, 0x2e, 0x4f, 0x23, 0xc7, 0x1c, 0x50, 0x65,
	0xb8, 0x68, 0xc7, 0x41, 0xc9, 0x26, 0x83, 0x72, 0xfe, 0x33, 0x92, 0x5b, 0xfa, 0x8c, 0xfa, 0xf6,
	0xc1, 0x98, 0x0c, 0x8f, 0x69, 0x68, 0x69, 0x2c, 0x41, 0x9f, 0x41, 0xdd, 0x0b, 0x43, 0x78, 0xd7,
	0x77, 0x87, 0x5e, 0xa3, 0x20, 0x56, 0x0e, 0x45, 0x3a, 0xa3, 0x08, 0x93, 0x09, 0x24, 0xfa, 0x14,
	0x2a, 0xb6, 0xf3, 0xcc, 0x3d, 0xa2, 0xbd, 0x07, 0x36, 0x0b, 0x1a, 0x45, 0x31, 0x30, 0xde, 0xd8,
	0x4d, 0xdf, 0x65, 0x2c, 0xf4, 0x90, 0x24, 0xa1, 0xf8, 0xcf, 0x1a, 0xe8, 0xdd, 0xe1, 0xfe, 0xba,
	0xc5, 0xf7, 0x7c, 0x72, 0x2b, 0x68, 0xa9, 0xad, 0x30, 0xc3, 0xfd, 0x64, 0x4e, 0xc8, 0xc5, 0x89,
	0xfa, 0x3c, 0x88, 0xa6, 0xdf, 0x67, 0x8d, 0xbc, 0x38, 0x9c, 0x45, 0x3b, 0x0e, 0x57, 0xe1, 0xcc,
	0x92, 0xb2, 0x0f, 0xd0, 0x16, 0x76, 0xee, 0x98, 0xbe, 0x89, 0x96, 0xa1, 0x68, 0x0a, 0x13, 0xd5,
	0x89, 0x12, 0x07, 0x25, 0x32, 0x9e, 0x28, 0x04, 0x5a, 0x82, 0xc2, 0xc1, 0xd0, 0xb1, 0xc2, 0xb3,
	0x7a, 0x5a, 0xfc, 0x24, 0x00, 0x7b, 0x50, 0x4b, 0x85, 0xe6, 0x14, 0xff, 0xd3, 0xd9, 0x9f, 0xf6,
	0xf4, 0x02, 0x85, 0xf2, 0x0f, 0x59, 0xd0, 0xc5, 0x99, 0x2a, 0xf2, 0xec, 0x07, 0x50, 0xf6, 0x7c,
	0xd7, 0xa3, 0x7e, 0x30, 0x56, 0xc5, 0xe0, 0x52, 0x6c, 0xac, 0xfa, 0x40, 0x22, 0x08, 0xb7, 0x8e,
	0x8a, 0xb1, 0xd1, 0x41, 0xa5, 0xba, 0x68, 0x0d, 0xca, 0xc7, 0xe6, 0xd0, 0xb1, 0x0e, 0xa9, 0xaf,
	0xea, 0xc0, 0xac, 0xc5, 0x8f, 0x70, 0xb1, 0xd5, 0xf9, 0x33, 0x53, 0xf7, 0xfb, 0xbc, 0x8e, 0xf2,
	0xb5, 0x50, 0x29, 0x19, 0x63, 0xe3, 0x25, 0x22, 0x0a, 0x82, 0x6e, 0x42, 0x49, 0x2e, 0x04, 0x53,
	0x79, 0x38, 0x6d, 0xad, 0x42, 0x08, 0xfe, 0x8d, 0x06, 0x15, 0x71, 0xfc, 0xec, 0x89, 0x32, 0x75,
	0xae, 0xb3, 0x27, 0x1d, 0xfd, 0x68, 0xb9, 0x73, 0x67, 0x2c, 0x37, 0x3f, 0x4f, 0x9d, 0xe1, 0x60,
	0x9f, 0xfa, 0xc2, 0xe5, 0x3c, 0x51, 0x3d, 0xfc, 0x6f, 0x0d, 0x6a, 0xa9, 0xda, 0x87, 0x3e, 0x02,
	0x9d, 0xf5, 0x8e, 0xd6, 0xc3, 0x8c, 0x9b, 0xe9, 0x73, 0x8c, 0x42, 0xab, 0xbc, 0x2e, 0x0c, 0xdc,
	0x80, 0x6e, 0x29, 0x42, 0x52, 0x49, 0x2c, 0xa6, 0xf0, 0x90, 0xb3, 0x89, 0x18, 0x83, 0x56, 0xa1,
	0xc4, 0xeb, 0x13, 0x89, 0x4a, 0xf7, 0x95, 0x38, 0x4e, 0x52, 0x2e, 0xf8, 0x02, 0x09, 0x51, 0xe8,
	0x26, 0x14, 0x65, 0x2d, 0x57, 0x85, 0xfb, 0x72, 0x5a, 0xbd, 0x0c, 0x20, 0x51, 0x18, 0xec, 0xa8,
	0x22, 0xc1, 0xa7, 0x4a, 0x54, 0x55, 0x2d, 0x55, 0x55, 0xa7, 0x15, 0xcc, 0x44, 0x71, 0xcd, 0xa5,
	0x8a, 0x6b, 0xaa, 0xf2, 0xe5, 0x27, 0x2a, 0x1f, 0xbe, 0x0d, 0xd5, 0xa4, 0xd9, 0x17, 0x9b, 0x13,
	0xb7, 0x54, 0x16, 0xdc, 0xa3, 0x76, 0xff, 0x30, 0x98, 0x91, 0x05, 0x8b, 0x50, 0xd9, 0x3f, 0x76,
	0xad, 0xa3, 0x8e, 0x5c, 0xc4, 0xac, 0x58, 0xc4, 0xa4, 0x08, 0x3f, 0x86, 0xaa, 0x2c, 0xd3, 0x4a,
	0xcf, 0x59, 0xc5, 0xba, 0x28, 0x14, 0x87, 0x35, 0x72, 0x22, 0xa0, 0x52, 0x07, 0x51, 0x18, 0xdc,
	0x84, 0xc2, 0x06, 0x9f, 0x6a, 0xd2, 0x0c, 0xed, 0x84, 0x19, 0x69, 0x16, 0x93, 0x4b, 0xf8, 0x8e,
	0x7f, 0x06, 0x65, 0xb1, 0x1f, 0xf9, 0xaa, 0x5c, 0x87, 0x7c, 0x30, 0xf6, 0xa8, 0xda, 0xf9, 0x31,
	0x4f, 0xd8, 0x62, 0xfd, 0xdd, 0xb1, 0x47, 0x89, 0xf8, 0x3a, 0x9b, 0x11, 0xe1, 0x07, 0x50, 0x22,
	0xf4, 0xcb, 0x21, 0x65, 0x01, 0xba, 0x91, 0x52, 0x35, 0x9f, 0x60, 0x74, 0xc1, 0x79, 0xb5, 0x0d,
	0xa0, 0x7c, 0x71, 0x8a, 0xba, 0x10, 0x52, 0x54, 0x7e, 0x9c, 0xa9, 0x9d, 0x99, 0x90, 0x24, 0xa7,
	0xcb, 0xa5, 0xa7, 0xfb, 0x05, 0xd4, 0x42, 0x6a, 0x25, 0x82, 0x3d, 0xb5, 0xe6, 0xbe, 0x0f, 0x39,
	0xcb, 0x0c, 0xcf, 0xf1, 0x89, 0xdd, 0xd4, 0x34, 0x19, 0xe1, 0x5f, 0x79, 0xba, 0x1e, 0x8a, 0x95,
	0x12, 0x53, 0xe4, 0x89, 0xea, 0xe1, 0x71, 0x4c, 0xde, 0xc4, 0x00, 0xbe, 0x85, 0xde, 0x9a, 0x63,
	0xef, 0x82, 0x2e, 0xd2, 0x62, 0xbd, 0xd7, 0xf3, 0x55, 0xe5, 0x8b, 0x05, 0xbc, 0xa8, 0xc6, 0x73,
	0x27, 0xea, 0xe1, 0x39, 0x49, 0x45, 0x9a, 0x29, 0xe4, 0x4e, 0x30, 0x85, 0x89, 0x6a, 0x9f, 0x3f,
	0x7f, 0xb5, 0x7f, 0x02, 0xf3, 0x93, 0x76, 0xbd, 0xcd, 0xb0, 0xe0, 0x0d, 0xa8, 0x75, 0xc7, 0x8e,
	0x25, 0xf7, 0x20, 0xa1, 0x5f, 0xa2, 0x8f, 0xa2, 0x2d, 0x26, 0xeb, 0xf6, 0xf7, 0xe2, 0x9b, 0xc0,
	0x04, 0xb1, 0x8e, 0xf6, 0xd9, 0xdf, 0x34, 0xa8, 0xed, 0xf8, 0x54, 0x1e, 0xc6, 0x94, 0x2b, 0x49,
	0xd4, 0x3d, 0x2d, 0x5d, 0xf7, 0xae, 0x43, 0x4d, 0xd6, 0xb3, 0x66, 0x8a, 0xc0, 0xa7, 0x85, 0xe8,
	0x03, 0xa8, 0x2b, 0x41, 0x9a, 0xab, 0x4c, 0x48, 0x13, 0x24, 0x23, 0x7f, 0x16, 0xc9, 0xc0, 0x7f,
	0xd4, 0xc0, 0x48, 0x5a, 0xc9, 0x86, 0xc7, 0xc1, 0x29, 0x86, 0xce, 0xbc, 0x63, 0x24, 0x62, 0x9f,
	0xbb, 0x48, 0xec, 0xf3, 0x27, 0x62, 0xff, 0x53, 0xd0, 0x9b, 0x82, 0xf7, 0x9e, 0x1e, 0xb2, 0xd9,
	0xb7, 0x9d, 0xdf, 0x09, 0x1a, 0x2c, 0x35, 0x7c, 0xf7, 0xee, 0xac, 0x43, 0x85, 0x28, 0x92, 0xfe,
	0xa6, 0x0e, 0xfd, 0x5e, 0x83, 0x7a, 0xac, 0xe3, 0xbb, 0x77, 0x69, 0x05, 0xea, 0x0f, 0x87, 0xd4,
	0x1f, 0xc7, 0xdb, 0xe3, 0xd4, 0xfa, 0x84, 0x3b, 0x13, 0x78, 0x86, 0x6e, 0x83, 0xe1, 0x4f, 0xec,
	0x9b, 0x99, 0xd7, 0xcc, 0x13, 0x48, 0xfc, 0x21, 0x5c, 0x92, 0xfa, 0xc2, 0x9b, 0x1e, 0x37, 0x61,
	0x6a, 0xa9, 0xc5, 0x4f, 0x4e, 0x42, 0x19, 0x6a, 0xc3, 0x7c, 0x42, 0x67, 0xf8, 0x45, 0x1d, 0xcf,
	0xef, 0x4c, 0x1c, 0xcf, 0xd1, 0xc0, 0x69, 0x63, 0xf0, 0x3d, 0xb8, 0x9c, 0xd2, 0xcf, 0xe3, 0x33,
	0xd3, 0x9a, 0xd3, 0xe8, 0x1f, 0x7e, 0x38, 0x55, 0x13, 0x43, 0xb7, 0xa0, 0x6a, 0x25, 0x44, 0xca,
	0xca, 0x98, 0x63, 0xa5, 0xf0, 0x29, 0x28, 0xde, 0x81, 0xab, 0x52, 0x25, 0x3f, 0x48, 0x23, 0xb6,
	0x7e, 0xe6, 0x7a, 0xcd, 0xe6, 0xe7, 0xf8, 0x9f, 0xda, 0x0c, 0x95, 0xec, 0x94, 0x8c, 0x4c, 0x92,
	0xfa, 0xec, 0x45, 0x49, 0xfd, 0xd9, 0xf7, 0xd1, 0xcf, 0xa0, 0xea, 0x99, 0x7e, 0x60, 0x5b, 0xb6,
	0x67, 0x3a, 0x01, 0x3b, 0xa3, 0x8c, 0xa4, 0xb0, 0xf8, 0x2e, 0x94, 0x76, 0x47, 0xf2, 0x8d, 0xed,
	0x6c, 0x36, 0x74, 0x0d, 0xca, 0xc1, 0x28, 0xc5, 0xd9, 0xa2, 0x3e, 0xfe, 0xbb, 0x06, 0x85, 0xdd,
	0x91, 0xe2, 0xa8, 0x33, 0xe2, 0x70, 0xf1, 0xab, 0xe7, 0x05, 0xae, 0x36, 0x1f, 0x40, 0x41, 0x3c,
	0x0a, 0x8a, 0x1b, 0x69, 0x72, 0x1b, 0x29, 0xff, 0x88, 0xfc, 0xcc, 0xcf, 0x7b, 0xbd, 0xdb, 0x3b,
	0x22, 0xe6, 0x73, 0x6e, 0xec, 0x1b, 0xf2, 0x53, 0xb4, 0x04, 0x25, 0x3a, 0xa2, 0xd6, 0xee, 0x88,
	0x9f, 0x25, 0xe9, 0x67, 0x19, 0x11, 0x05, 0x12, 0x7e, 0x8e, 0x74, 0xc9, 0x73, 0x4b, 0x38, 0x52,
	0x25, 0x49, 0x11, 0xfe, 0x35, 0xe8, 0x82, 0x8f, 0x0a, 0x3e, 0x72, 0xf6, 0x2a, 0xcc, 0xa4, 0x1a,
	0xc1, 0x88, 0xed, 0x44, 0x1c, 0x8d, 0x93, 0xd5, 0x84, 0x44, 0xae, 0x1d, 0x7b, 0x64, 0x1e, 0xdb,
	0x3d, 0x91, 0x20, 0x65, 0x12, 0xf5, 0xf1, 0x6f, 0x35, 0x98, 0x93, 0x77, 0x21, 0x79, 0xe4, 0x9c,
	0xe0, 0x45, 0xda, 0x04, 0x2f, 0x7a, 0xb3, 0x47, 0x84, 0x83, 0xf8, 0x61, 0x47, 0xb4, 0xa3, 0x87,
	0x85, 0x42, 0xfc, 0xb0, 0x80, 0xff, 0xca, 0xaf, 0x91, 0x3c, 0x61, 0xa5, 0x41, 0xa7, 0x64, 0xd3,
	0x27, 0xa0, 0x47, 0x6f, 0x4c, 0x6a, 0x5b, 0x35, 0x26, 0xae, 0x76, 0x91, 0x3b, 0x24, 0x86, 0xa2,
	0xdb, 0x13, 0xdb, 0x45, 0xae, 0xdf, 0xec, 0xa1, 0xe9, 0x0d, 0xe3, 0x42, 0x85, 0xd0, 0x7e, 0xc4,
	0x34, 0x92, 0x2e, 0x6b, 0x33, 0x5c, 0xce, 0x26, 0x5c, 0xfe, 0x21, 0xe8, 0x22, 0x5d, 0x0f, 0xe4,
	0x2b, 0xd8, 0xac, 0x67, 0xa1, 0x18, 0x84, 0x3d, 0xa8, 0x7d, 0x61, 0xb2, 0x81, 0xb4, 0xea, 0xad,
	0x52, 0xdf, 0xab, 0x50, 0xf4, 0x65, 0x52, 0xaa, 0xeb, 0xa1, 0xec, 0xe1, 0x32, 0x14, 0x09, 0xf5,
	0x8e, 0xcd, 0xf1, 0xf2, 0x63, 0xf9, 0x6f, 0xc0, 0x90, 0xa1, 0x0a, 0x94, 0xf6, 0x3a, 0xf7, 0xb7,
	0x3b, 0x5f, 0x74, 0x8c, 0x0c, 0x2a, 0x43, 0xbe, 0xb3, 0xdd, 0x69, 0x19, 0x1a, 0xd2, 0xa1, 0xd0,
	0x22, 0x64, 0x9b, 0x18, 0x59, 0x54, 0x85, 0x52, 0x77, 0xaf, 0xd9, 0x6c, 0x75, 0xbb, 0xc6, 0x0b,
	0x0d, 0x19, 0x50, 0xd9, 0x58, 0xdf, 0x7c, 0x4a, 0x5a, 0x0f, 0xf7, 0x5a, 0xdd, 0x5d, 0xe3, 0xab,
	0x1c, 0xaa, 0x83, 0x7e, 0x67, 0x9b, 0x6c, 0xb4, 0x37, 0x37, 0x5b, 0x1d, 0xe3, 0x4f, 0xb9, 0xe5,
	0xaf, 0x35, 0x80, 0x78, 0x17, 0xa3, 0x2a, 0x94, 0xf7, 0x3a, 0x77, 0xda, 0x9d, 0x76, 0xf7, 0x9e,
	0x91, 0xe1, 0x3d, 0xd9, 0x6e, 0x6d, 0x1a, 0x1a, 0xef, 0x91, 0xd6, 0xdd, 0x76, 0x77, 0xb7, 0xc5,
	0x27, 0xaa, 0x03, 0x84, 0xbd, 0xd6, 0xa6, 0x91, 0x43, 0x73, 0x50, 0x69, 0x92, 0xed, 0x6e, 0xb7,
	0xdd, 0x79, 0xb4, 0x7d, 0xbf, 0x65, 0xe4, 0x39, 0x60, 0x87, 0xb4, 0x5a, 0x3f, 0x6f, 0x35, 0xf7,
	0x76, 0x5b, 0x46, 0x81, 0x03, 0xe2, 0xfe, 0xa6, 0x51, 0x44, 0x06, 0x54, 0x63, 0x01, 0x21, 0x46,
	0x09, 0x01, 0x14, 0x9b, 0xdb, 0x5b, 0x5b, 0xed, 0x5d, 0xa3, 0x8c, 0x6a, 0xa0, 0xcb, 0x36, 0x07,
	0xeb, 0x62, 0xf2, 0xed, 0x07, 0x0f, 0x36, 0xd6, 0x9b, 0xf7, 0x0d, 0xe0, 0x40, 0xde, 0x6b, 0x6d,
	0x1a, 0x95, 0xe5, 0x47, 0x50, 0x52, 0x77, 0x32, 0x2e, 0x96, 0x37, 0x34, 0x23, 0xc3, 0xdb, 0xdd,
	0xde, 0x11, 0x6f, 0xf3, 0x30, 0x54, 0x3b, 0x34, 0x68, 0xba, 0xce, 0x81, 0xdd, 0xe7, 0x92, 0x2c,
	0x97, 0x74, 0x7b, 0x47, 0xb1, 0x44, 0xd8, 0x1f, 0xd6, 0xbd, 0x03, 0xbb, 0x6f, 0xe4, 0x97, 0xff,
	0x95, 0x05, 0x88, 0xef, 0x7b, 0x08, 0x41, 0x3d, 0xa4, 0xd8, 0x4f, 0x45, 0x56, 0x1a, 0x19, 0x74,
	0x05, 0x2e, 0xc5, 0x32, 0x95, 0x6f, 0x72, 0x3a, 0xf9, 0x78, 0xa0, 0x80, 0x59, 0x34, 0x0f, 0x73,
	0xa1, 0x24, 0x84, 0x89, 0x19, 0x39, 0xb9, 0x97, 0x20, 0x66, 0xe4, 0xd1, 0x55, 0x40, 0x31, 0x05,
	0x7e, 0xaa, 0xee, 0xa2, 0x46, 0x01, 0xbd, 0x03, 0xf3, 0x29, 0xb9, 0xbc, 0x55, 0x1a, 0x45, 0x6e,
	0x93, 0x24, 0x98, 0x11, 0xb8, 0xc4, 0xa7, 0x8a, 0x64, 0x0a, 0x58, 0x46, 0x97, 0xc1, 0x08, 0x89,
	0x5b, 0x04, 0xd5, 0x85, 0xf9, 0xb1, 0x54, 0x81, 0x81, 0x9b, 0x2f, 0x22, 0x11, 0x1a, 0x56, 0xe1,
	0x3a, 0x95, 0x24, 0x24, 0x1c, 0x46, 0x95, 0x5b, 0x9b, 0x16, 0xf2, 0x6c, 0x36, 0x6a, 0xa8, 0xa1,
	0x08, 0xc4, 0xd3, 0x74, 0x6d, 0x36, 0xea, 0xcb, 0x37, 0xa0, 0x1c, 0xbe, 0xc2, 0xf1, 0xec, 0x68,
	0x77, 0xda, 0xbb, 0xed, 0xf5, 0xdd, 0xf6, 0xa3, 0x96, 0x91, 0xe1, 0x99, 0xbd, 0xb3, 0xde, 0xed,
	0xf2, 0x8e, 0xb6, 0xf6, 0xb5, 0xc6, 0xaf, 0xe2, 0x62, 0x37, 0xa1, 0xdb, 0x71, 0xdc, 0xe5, 0xd2,
	0xa0, 0xf9, 0x29, 0xff, 0x7e, 0x5c, 0x9b, 0x26, 0xc4, 0x19, 0xf4, 0x39, 0xcc, 0xed, 0xf8, 0xae,
	0x45, 0x19, 0x8b, 0x9e, 0x09, 0xa6, 0x0e, 0x9f, 0x4b, 0xdc, 0xa3, 0xf8, 0x9e, 0xc3, 0x99, 0x25,
	0x0d, 0xdd, 0x4a, 0xa5, 0xc4, 0x45, 0xe6, 0xdd, 0xf8, 0xd5, 0x8b, 0x6f, 0x16, 0x32, 0x2f, 0xbf,
	0x59, 0xc8, 0xbc, 0x78, 0xb5, 0xa0, 0xbd, 0x7c, 0xb5, 0xa0, 0xfd, 0xef, 0xd5, 0x82, 0xf6, 0xd5,
	0xeb, 0x85, 0xcc, 0xcb, 0xd7, 0x0b, 0x99, 0xff, 0xbc, 0x5e, 0xc8, 0xc0, 0x75, 0xcb, 0x1d, 0xac,
	0x1c, 0x0e, 0xcd, 0xe7, 0xd4, 0x5e, 0x79, 0x6e, 0x53, 0x87, 0xfa, 0xe2, 0xf4, 0x96, 0x7f, 0x2e,
	0x86, 0x4a, 0x1f, 0x7f, 0xd2, 0xb7, 0x83, 0x10, 0x65, 0xb9, 0x83, 0x55, 0xcf, 0xb5, 0x19, 0xe3,
	0xeb, 0x64, 0xfa, 0xd6, 0xe1, 0x6a, 0x62, 0xdc, 0xaa, 0xfc, 0x7f, 0x52, 0x8d, 0xdb, 0x2f, 0x8a,
	0xee, 0xc7, 0xdf, 0x06, 0x00, 0x00, 0xff, 0xff, 0x43, 0xcc, 0x7a, 0x19, 0xdb, 0x1c, 0x00, 0x00,
}

// Reference imports to suppress errors if they are not otherwise used.
var _ context.Context
var _ grpc.ClientConn

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
const _ = grpc.SupportPackageIsVersion4

// RelayerClient is the client API for Relayer service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://godoc.org/google.golang.org/grpc#ClientConn.NewStream.
type RelayerClient interface {
	RegisterConfig(ctx context.Context, in *RawMessage, opts ...grpc.CallOption) (*RawMessage, error)
	ProcessCrossMsg(ctx context.Context, opts ...grpc.CallOption) (Relayer_ProcessCrossMsgClient, error)
	QueryConfig(ctx context.Context, in *RawMessage, opts ...grpc.CallOption) (*RawMessage, error)
}

type relayerClient struct {
	cc *grpc.ClientConn
}

func NewRelayerClient(cc *grpc.ClientConn) RelayerClient {
	return &relayerClient{cc}
}

func (c *relayerClient) RegisterConfig(ctx context.Context, in *RawMessage, opts ...grpc.CallOption) (*RawMessage, error) {
	out := new(RawMessage)
	err := c.cc.Invoke(ctx, "/relayer.Relayer/RegisterConfig", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *relayerClient) ProcessCrossMsg(ctx context.Context, opts ...grpc.CallOption) (Relayer_ProcessCrossMsgClient, error) {
	stream, err := c.cc.NewStream(ctx, &_Relayer_serviceDesc.Streams[0], "/relayer.Relayer/ProcessCrossMsg", opts...)
	if err != nil {
		return nil, err
	}
	x := &relayerProcessCrossMsgClient{stream}
	return x, nil
}

type Relayer_ProcessCrossMsgClient interface {
	Send(*RawMessage) error
	CloseAndRecv() (*Replay, error)
	grpc.ClientStream
}

type relayerProcessCrossMsgClient struct {
	grpc.ClientStream
}

func (x *relayerProcessCrossMsgClient) Send(m *RawMessage) error {
	return x.ClientStream.SendMsg(m)
}

func (x *relayerProcessCrossMsgClient) CloseAndRecv() (*Replay, error) {
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	m := new(Replay)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *relayerClient) QueryConfig(ctx context.Context, in *RawMessage, opts ...grpc.CallOption) (*RawMessage, error) {
	out := new(RawMessage)
	err := c.cc.Invoke(ctx, "/relayer.Relayer/QueryConfig", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// RelayerServer is the server API for Relayer service.
type RelayerServer interface {
	RegisterConfig(context.Context, *RawMessage) (*RawMessage, error)
	ProcessCrossMsg(Relayer_ProcessCrossMsgServer) error
	QueryConfig(context.Context, *RawMessage) (*RawMessage, error)
}

// UnimplementedRelayerServer can be embedded to have forward compatible implementations.
type UnimplementedRelayerServer struct {
}

func (*UnimplementedRelayerServer) RegisterConfig(ctx context.Context, req *RawMessage) (*RawMessage, error) {
	return nil, status.Errorf(codes.Unimplemented, "method RegisterConfig not implemented")
}
func (*UnimplementedRelayerServer) ProcessCrossMsg(srv Relayer_ProcessCrossMsgServer) error {
	return status.Errorf(codes.Unimplemented, "method ProcessCrossMsg not implemented")
}
func (*UnimplementedRelayerServer) QueryConfig(ctx context.Context, req *RawMessage) (*RawMessage, error) {
	return nil, status.Errorf(codes.Unimplemented, "method QueryConfig not implemented")
}

func RegisterRelayerServer(s *grpc.Server, srv RelayerServer) {
	s.RegisterService(&_Relayer_serviceDesc, srv)
}

func _Relayer_RegisterConfig_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(RawMessage)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(RelayerServer).RegisterConfig(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/relayer.Relayer/RegisterConfig",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(RelayerServer).RegisterConfig(ctx, req.(*RawMessage))
	}
	return interceptor(ctx, in, info, handler)
}

func _Relayer_ProcessCrossMsg_Handler(srv interface{}, stream grpc.ServerStream) error {
	return srv.(RelayerServer).ProcessCrossMsg(&relayerProcessCrossMsgServer{stream})
}

type Relayer_ProcessCrossMsgServer interface {
	SendAndClose(*Replay) error
	Recv() (*RawMessage, error)
	grpc.ServerStream
}

type relayerProcessCrossMsgServer struct {
	grpc.ServerStream
}

func (x *relayerProcessCrossMsgServer) SendAndClose(m *Replay) error {
	return x.ServerStream.SendMsg(m)
}

func (x *relayerProcessCrossMsgServer) Recv() (*RawMessage, error) {
	m := new(RawMessage)
	if err := x.ServerStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func _Relayer_QueryConfig_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(RawMessage)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(RelayerServer).QueryConfig(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/relayer.Relayer/QueryConfig",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(RelayerServer).QueryConfig(ctx, req.(*RawMessage))
	}
	return interceptor(ctx, in, info, handler)
}

var _Relayer_serviceDesc = grpc.ServiceDesc{
	ServiceName: "relayer.Relayer",
	HandlerType: (*RelayerServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "RegisterConfig",
			Handler:    _Relayer_RegisterConfig_Handler,
		},
		{
			MethodName: "QueryConfig",
			Handler:    _Relayer_QueryConfig_Handler,
		},
	},
	Streams: []grpc.StreamDesc{
		{
			StreamName:    "ProcessCrossMsg",
			Handler:       _Relayer_ProcessCrossMsg_Handler,
			ClientStreams: true,
		},
	},
	Metadata: "relayer/relayer.proto",
}

func (m *State) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *State) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *State) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Phase != 0 {
		i = encodeVarintRelayer(dAtA, i, uint64(m.Phase))
		i--
		dAtA[i] = 0x18
	}
	if len(m.State) > 0 {
		i -= len(m.State)
		copy(dAtA[i:], m.State)
		i = encodeVarintRelayer(dAtA, i, uint64(len(m.State)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Key) > 0 {
		i -= len(m.Key)
		copy(dAtA[i:], m.Key)
		i = encodeVarintRelayer(dAtA, i, uint64(len(m.Key)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *States) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *States) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *States) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.EncryptedStates) > 0 {
		for iNdEx := len(m.EncryptedStates) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.EncryptedStates[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintRelayer(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *ExecMsg) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ExecMsg) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ExecMsg) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Msg) > 0 {
		for iNdEx := len(m.Msg) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.Msg[iNdEx])
			copy(dAtA[i:], m.Msg[iNdEx])
			i = encodeVarintRelayer(dAtA, i, uint64(len(m.Msg[iNdEx])))
			i--
			dAtA[i] = 0x12
		}
	}
	if m.Status != 0 {
		i = encodeVarintRelayer(dAtA, i, uint64(m.Status))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *DataIndex) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *DataIndex) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *DataIndex) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Indexs) > 0 {
		dAtA2 := make([]byte, len(m.Indexs)*10)
		var j1 int
		for _, num := range m.Indexs {
			for num >= 1<<7 {
				dAtA2[j1] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j1++
			}
			dAtA2[j1] = uint8(num)
			j1++
		}
		i -= j1
		copy(dAtA[i:], dAtA2[:j1])
		i = encodeVarintRelayer(dAtA, i, uint64(j1))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *ExecInput) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ExecInput) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ExecInput) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Cmd != 0 {
		i = encodeVarintRelayer(dAtA, i, uint64(m.Cmd))
		i--
		dAtA[i] = 0x18
	}
	if m.States != nil {
		{
			size, err := m.States.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintRelayer(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	if m.Msg != nil {
		{
			size, err := m.Msg.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintRelayer(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *ExecResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ExecResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ExecResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Extension) > 0 {
		i -= len(m.Extension)
		copy(dAtA[i:], m.Extension)
		i = encodeVarintRelayer(dAtA, i, uint64(len(m.Extension)))
		i--
		dAtA[i] = 0x2a
	}
	if m.NextEvent != nil {
		{
			size, err := m.NextEvent.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintRelayer(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x22
	}
	if m.UpdateStates != nil {
		{
			size, err := m.UpdateStates.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintRelayer(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1a
	}
	if len(m.StatusMsg) > 0 {
		i -= len(m.StatusMsg)
		copy(dAtA[i:], m.StatusMsg)
		i = encodeVarintRelayer(dAtA, i, uint64(len(m.StatusMsg)))
		i--
		dAtA[i] = 0x12
	}
	if m.Status != 0 {
		i = encodeVarintRelayer(dAtA, i, uint64(m.Status))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *RawMessage) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *RawMessage) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *RawMessage) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Payload) > 0 {
		i -= len(m.Payload)
		copy(dAtA[i:], m.Payload)
		i = encodeVarintRelayer(dAtA, i, uint64(len(m.Payload)))
		i--
		dAtA[i] = 0x12
	}
	if m.Signature != nil {
		{
			size, err := m.Signature.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintRelayer(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *RawMessage_Signature) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *RawMessage_Signature) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *RawMessage_Signature) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Sign) > 0 {
		i -= len(m.Sign)
		copy(dAtA[i:], m.Sign)
		i = encodeVarintRelayer(dAtA, i, uint64(len(m.Sign)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.PubKey) > 0 {
		i -= len(m.PubKey)
		copy(dAtA[i:], m.PubKey)
		i = encodeVarintRelayer(dAtA, i, uint64(len(m.PubKey)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *ChainId) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ChainId) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ChainId) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.ChainId) > 0 {
		i -= len(m.ChainId)
		copy(dAtA[i:], m.ChainId)
		i = encodeVarintRelayer(dAtA, i, uint64(len(m.ChainId)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Chain) > 0 {
		i -= len(m.Chain)
		copy(dAtA[i:], m.Chain)
		i = encodeVarintRelayer(dAtA, i, uint64(len(m.Chain)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *RegisteredChains) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *RegisteredChains) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *RegisteredChains) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.ChainIds) > 0 {
		for iNdEx := len(m.ChainIds) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.ChainIds[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintRelayer(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x12
		}
	}
	if len(m.RelayerId) > 0 {
		i -= len(m.RelayerId)
		copy(dAtA[i:], m.RelayerId)
		i = encodeVarintRelayer(dAtA, i, uint64(len(m.RelayerId)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *OrgCa) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *OrgCa) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *OrgCa) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.CaCert) > 0 {
		i -= len(m.CaCert)
		copy(dAtA[i:], m.CaCert)
		i = encodeVarintRelayer(dAtA, i, uint64(len(m.CaCert)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.OrgId) > 0 {
		i -= len(m.OrgId)
		copy(dAtA[i:], m.OrgId)
		i = encodeVarintRelayer(dAtA, i, uint64(len(m.OrgId)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *ChainCas) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ChainCas) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ChainCas) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.ChainCas) > 0 {
		for iNdEx := len(m.ChainCas) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.ChainCas[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintRelayer(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x12
		}
	}
	if len(m.Chain) > 0 {
		i -= len(m.Chain)
		copy(dAtA[i:], m.Chain)
		i = encodeVarintRelayer(dAtA, i, uint64(len(m.Chain)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *ChainContracts) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ChainContracts) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ChainContracts) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Contract) > 0 {
		for iNdEx := len(m.Contract) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.Contract[iNdEx])
			copy(dAtA[i:], m.Contract[iNdEx])
			i = encodeVarintRelayer(dAtA, i, uint64(len(m.Contract[iNdEx])))
			i--
			dAtA[i] = 0x12
		}
	}
	if len(m.Chain) > 0 {
		i -= len(m.Chain)
		copy(dAtA[i:], m.Chain)
		i = encodeVarintRelayer(dAtA, i, uint64(len(m.Chain)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *PhaseFunc) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *PhaseFunc) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *PhaseFunc) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.RollbackFunc) > 0 {
		i -= len(m.RollbackFunc)
		copy(dAtA[i:], m.RollbackFunc)
		i = encodeVarintRelayer(dAtA, i, uint64(len(m.RollbackFunc)))
		i--
		dAtA[i] = 0x2a
	}
	if len(m.CommitFunc) > 0 {
		i -= len(m.CommitFunc)
		copy(dAtA[i:], m.CommitFunc)
		i = encodeVarintRelayer(dAtA, i, uint64(len(m.CommitFunc)))
		i--
		dAtA[i] = 0x22
	}
	if len(m.PrepareFunc) > 0 {
		i -= len(m.PrepareFunc)
		copy(dAtA[i:], m.PrepareFunc)
		i = encodeVarintRelayer(dAtA, i, uint64(len(m.PrepareFunc)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.InitiatorFunc) > 0 {
		i -= len(m.InitiatorFunc)
		copy(dAtA[i:], m.InitiatorFunc)
		i = encodeVarintRelayer(dAtA, i, uint64(len(m.InitiatorFunc)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.RegisterFunc) > 0 {
		i -= len(m.RegisterFunc)
		copy(dAtA[i:], m.RegisterFunc)
		i = encodeVarintRelayer(dAtA, i, uint64(len(m.RegisterFunc)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *ContractInfo) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ContractInfo) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ContractInfo) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.InvokedList) > 0 {
		for iNdEx := len(m.InvokedList) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.InvokedList[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintRelayer(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x32
		}
	}
	if len(m.PhaseFuncGroup) > 0 {
		for iNdEx := len(m.PhaseFuncGroup) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.PhaseFuncGroup[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintRelayer(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x2a
		}
	}
	if len(m.VerifyRule) > 0 {
		i -= len(m.VerifyRule)
		copy(dAtA[i:], m.VerifyRule)
		i = encodeVarintRelayer(dAtA, i, uint64(len(m.VerifyRule)))
		i--
		dAtA[i] = 0x22
	}
	if m.Phase != 0 {
		i = encodeVarintRelayer(dAtA, i, uint64(m.Phase))
		i--
		dAtA[i] = 0x18
	}
	if len(m.Chain) > 0 {
		i -= len(m.Chain)
		copy(dAtA[i:], m.Chain)
		i = encodeVarintRelayer(dAtA, i, uint64(len(m.Chain)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Name) > 0 {
		i -= len(m.Name)
		copy(dAtA[i:], m.Name)
		i = encodeVarintRelayer(dAtA, i, uint64(len(m.Name)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *SubAction) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SubAction) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *SubAction) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Phase != 0 {
		i = encodeVarintRelayer(dAtA, i, uint64(m.Phase))
		i--
		dAtA[i] = 0x28
	}
	if len(m.Args) > 0 {
		for iNdEx := len(m.Args) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.Args[iNdEx])
			copy(dAtA[i:], m.Args[iNdEx])
			i = encodeVarintRelayer(dAtA, i, uint64(len(m.Args[iNdEx])))
			i--
			dAtA[i] = 0x22
		}
	}
	if len(m.Contract) > 0 {
		i -= len(m.Contract)
		copy(dAtA[i:], m.Contract)
		i = encodeVarintRelayer(dAtA, i, uint64(len(m.Contract)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.Chain) > 0 {
		i -= len(m.Chain)
		copy(dAtA[i:], m.Chain)
		i = encodeVarintRelayer(dAtA, i, uint64(len(m.Chain)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.ChainId) > 0 {
		i -= len(m.ChainId)
		copy(dAtA[i:], m.ChainId)
		i = encodeVarintRelayer(dAtA, i, uint64(len(m.ChainId)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *InvokePara) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *InvokePara) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *InvokePara) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Funcs != nil {
		{
			size, err := m.Funcs.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintRelayer(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	if m.Action != nil {
		{
			size, err := m.Action.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintRelayer(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *CrossContract) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CrossContract) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *CrossContract) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Phase != 0 {
		i = encodeVarintRelayer(dAtA, i, uint64(m.Phase))
		i--
		dAtA[i] = 0x18
	}
	if len(m.Contract) > 0 {
		i -= len(m.Contract)
		copy(dAtA[i:], m.Contract)
		i = encodeVarintRelayer(dAtA, i, uint64(len(m.Contract)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.ChainId) > 0 {
		i -= len(m.ChainId)
		copy(dAtA[i:], m.ChainId)
		i = encodeVarintRelayer(dAtA, i, uint64(len(m.ChainId)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *EventInfo) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *EventInfo) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *EventInfo) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Actions) > 0 {
		for iNdEx := len(m.Actions) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Actions[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintRelayer(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x32
		}
	}
	if len(m.Invoke) > 0 {
		for iNdEx := len(m.Invoke) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Invoke[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintRelayer(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x2a
		}
	}
	if m.Phase != 0 {
		i = encodeVarintRelayer(dAtA, i, uint64(m.Phase))
		i--
		dAtA[i] = 0x20
	}
	if m.Launcher != nil {
		{
			size, err := m.Launcher.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintRelayer(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1a
	}
	if len(m.EventId) > 0 {
		i -= len(m.EventId)
		copy(dAtA[i:], m.EventId)
		i = encodeVarintRelayer(dAtA, i, uint64(len(m.EventId)))
		i--
		dAtA[i] = 0x12
	}
	if m.Property != 0 {
		i = encodeVarintRelayer(dAtA, i, uint64(m.Property))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *ChainUpdate) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ChainUpdate) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ChainUpdate) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Number != 0 {
		i = encodeVarintRelayer(dAtA, i, uint64(m.Number))
		i--
		dAtA[i] = 0x20
	}
	if m.Funcs != nil {
		{
			size, err := m.Funcs.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintRelayer(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1a
	}
	if len(m.Contract) > 0 {
		i -= len(m.Contract)
		copy(dAtA[i:], m.Contract)
		i = encodeVarintRelayer(dAtA, i, uint64(len(m.Contract)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Chain) > 0 {
		i -= len(m.Chain)
		copy(dAtA[i:], m.Chain)
		i = encodeVarintRelayer(dAtA, i, uint64(len(m.Chain)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *NextExecution) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *NextExecution) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *NextExecution) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Update != nil {
		{
			size, err := m.Update.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintRelayer(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x22
	}
	if m.SignRes != nil {
		{
			size, err := m.SignRes.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintRelayer(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1a
	}
	if len(m.RemoteMsg) > 0 {
		for iNdEx := len(m.RemoteMsg) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.RemoteMsg[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintRelayer(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x12
		}
	}
	if len(m.SdkAction) > 0 {
		for iNdEx := len(m.SdkAction) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.SdkAction[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintRelayer(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *ChainMsg) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ChainMsg) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ChainMsg) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.RelayerId) > 0 {
		i -= len(m.RelayerId)
		copy(dAtA[i:], m.RelayerId)
		i = encodeVarintRelayer(dAtA, i, uint64(len(m.RelayerId)))
		i--
		dAtA[i] = 0x22
	}
	if len(m.PubKey) > 0 {
		i -= len(m.PubKey)
		copy(dAtA[i:], m.PubKey)
		i = encodeVarintRelayer(dAtA, i, uint64(len(m.PubKey)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.Sign) > 0 {
		i -= len(m.Sign)
		copy(dAtA[i:], m.Sign)
		i = encodeVarintRelayer(dAtA, i, uint64(len(m.Sign)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Payload) > 0 {
		i -= len(m.Payload)
		copy(dAtA[i:], m.Payload)
		i = encodeVarintRelayer(dAtA, i, uint64(len(m.Payload)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *SignResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SignResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *SignResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Sign) > 0 {
		i -= len(m.Sign)
		copy(dAtA[i:], m.Sign)
		i = encodeVarintRelayer(dAtA, i, uint64(len(m.Sign)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Payload) > 0 {
		i -= len(m.Payload)
		copy(dAtA[i:], m.Payload)
		i = encodeVarintRelayer(dAtA, i, uint64(len(m.Payload)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *ChainHeight) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ChainHeight) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ChainHeight) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.BlockNumber != 0 {
		i = encodeVarintRelayer(dAtA, i, uint64(m.BlockNumber))
		i--
		dAtA[i] = 0x10
	}
	if len(m.Chain) > 0 {
		i -= len(m.Chain)
		copy(dAtA[i:], m.Chain)
		i = encodeVarintRelayer(dAtA, i, uint64(len(m.Chain)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *ChainsHeight) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ChainsHeight) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ChainsHeight) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Chains) > 0 {
		for iNdEx := len(m.Chains) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Chains[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintRelayer(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x12
		}
	}
	if len(m.RelayerId) > 0 {
		i -= len(m.RelayerId)
		copy(dAtA[i:], m.RelayerId)
		i = encodeVarintRelayer(dAtA, i, uint64(len(m.RelayerId)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *Block) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Block) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Block) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Payload) > 0 {
		for iNdEx := len(m.Payload) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.Payload[iNdEx])
			copy(dAtA[i:], m.Payload[iNdEx])
			i = encodeVarintRelayer(dAtA, i, uint64(len(m.Payload[iNdEx])))
			i--
			dAtA[i] = 0x12
		}
	}
	if m.BlockNumber != 0 {
		i = encodeVarintRelayer(dAtA, i, uint64(m.BlockNumber))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *CrossMsg) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CrossMsg) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *CrossMsg) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Payload) > 0 {
		i -= len(m.Payload)
		copy(dAtA[i:], m.Payload)
		i = encodeVarintRelayer(dAtA, i, uint64(len(m.Payload)))
		i--
		dAtA[i] = 0x12
	}
	if m.Type != 0 {
		i = encodeVarintRelayer(dAtA, i, uint64(m.Type))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *Request) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Request) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Request) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Payload) > 0 {
		i -= len(m.Payload)
		copy(dAtA[i:], m.Payload)
		i = encodeVarintRelayer(dAtA, i, uint64(len(m.Payload)))
		i--
		dAtA[i] = 0x12
	}
	if m.Type != 0 {
		i = encodeVarintRelayer(dAtA, i, uint64(m.Type))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *Response) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Response) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Response) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Payload) > 0 {
		i -= len(m.Payload)
		copy(dAtA[i:], m.Payload)
		i = encodeVarintRelayer(dAtA, i, uint64(len(m.Payload)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.StatusInfo) > 0 {
		i -= len(m.StatusInfo)
		copy(dAtA[i:], m.StatusInfo)
		i = encodeVarintRelayer(dAtA, i, uint64(len(m.StatusInfo)))
		i--
		dAtA[i] = 0x12
	}
	if m.Status != 0 {
		i = encodeVarintRelayer(dAtA, i, uint64(m.Status))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *RegisterChain) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *RegisterChain) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *RegisterChain) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Height != 0 {
		i = encodeVarintRelayer(dAtA, i, uint64(m.Height))
		i--
		dAtA[i] = 0x18
	}
	if m.Cas != nil {
		{
			size, err := m.Cas.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintRelayer(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	if len(m.Name) > 0 {
		i -= len(m.Name)
		copy(dAtA[i:], m.Name)
		i = encodeVarintRelayer(dAtA, i, uint64(len(m.Name)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *RegisterChainRes) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *RegisterChainRes) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *RegisterChainRes) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.ChainAddr) > 0 {
		i -= len(m.ChainAddr)
		copy(dAtA[i:], m.ChainAddr)
		i = encodeVarintRelayer(dAtA, i, uint64(len(m.ChainAddr)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.StatusInfo) > 0 {
		i -= len(m.StatusInfo)
		copy(dAtA[i:], m.StatusInfo)
		i = encodeVarintRelayer(dAtA, i, uint64(len(m.StatusInfo)))
		i--
		dAtA[i] = 0x12
	}
	if m.Status != 0 {
		i = encodeVarintRelayer(dAtA, i, uint64(m.Status))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *RegisterContract) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *RegisterContract) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *RegisterContract) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.InvokedList) > 0 {
		for iNdEx := len(m.InvokedList) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.InvokedList[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintRelayer(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x22
		}
	}
	if len(m.VerifyRule) > 0 {
		i -= len(m.VerifyRule)
		copy(dAtA[i:], m.VerifyRule)
		i = encodeVarintRelayer(dAtA, i, uint64(len(m.VerifyRule)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.Chain) > 0 {
		i -= len(m.Chain)
		copy(dAtA[i:], m.Chain)
		i = encodeVarintRelayer(dAtA, i, uint64(len(m.Chain)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Name) > 0 {
		i -= len(m.Name)
		copy(dAtA[i:], m.Name)
		i = encodeVarintRelayer(dAtA, i, uint64(len(m.Name)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *RegisterContractRes) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *RegisterContractRes) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *RegisterContractRes) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.StatusInfo) > 0 {
		i -= len(m.StatusInfo)
		copy(dAtA[i:], m.StatusInfo)
		i = encodeVarintRelayer(dAtA, i, uint64(len(m.StatusInfo)))
		i--
		dAtA[i] = 0x12
	}
	if m.Status != 0 {
		i = encodeVarintRelayer(dAtA, i, uint64(m.Status))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *SyncChainsReq) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SyncChainsReq) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *SyncChainsReq) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Chains != nil {
		{
			size, err := m.Chains.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintRelayer(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *PreExecuteReq) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *PreExecuteReq) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *PreExecuteReq) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Action != nil {
		{
			size, err := m.Action.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintRelayer(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x22
	}
	if len(m.LaunchContract) > 0 {
		i -= len(m.LaunchContract)
		copy(dAtA[i:], m.LaunchContract)
		i = encodeVarintRelayer(dAtA, i, uint64(len(m.LaunchContract)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.LaunchChainId) > 0 {
		i -= len(m.LaunchChainId)
		copy(dAtA[i:], m.LaunchChainId)
		i = encodeVarintRelayer(dAtA, i, uint64(len(m.LaunchChainId)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.EventId) > 0 {
		i -= len(m.EventId)
		copy(dAtA[i:], m.EventId)
		i = encodeVarintRelayer(dAtA, i, uint64(len(m.EventId)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *PreExecuteResult) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *PreExecuteResult) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *PreExecuteResult) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.StatusInfo) > 0 {
		i -= len(m.StatusInfo)
		copy(dAtA[i:], m.StatusInfo)
		i = encodeVarintRelayer(dAtA, i, uint64(len(m.StatusInfo)))
		i--
		dAtA[i] = 0x22
	}
	if m.Status != 0 {
		i = encodeVarintRelayer(dAtA, i, uint64(m.Status))
		i--
		dAtA[i] = 0x18
	}
	if len(m.ChainId) > 0 {
		i -= len(m.ChainId)
		copy(dAtA[i:], m.ChainId)
		i = encodeVarintRelayer(dAtA, i, uint64(len(m.ChainId)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.EventId) > 0 {
		i -= len(m.EventId)
		copy(dAtA[i:], m.EventId)
		i = encodeVarintRelayer(dAtA, i, uint64(len(m.EventId)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *CommitReq) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CommitReq) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *CommitReq) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.ChainId) > 0 {
		i -= len(m.ChainId)
		copy(dAtA[i:], m.ChainId)
		i = encodeVarintRelayer(dAtA, i, uint64(len(m.ChainId)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.EventId) > 0 {
		i -= len(m.EventId)
		copy(dAtA[i:], m.EventId)
		i = encodeVarintRelayer(dAtA, i, uint64(len(m.EventId)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *CommitResult) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CommitResult) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *CommitResult) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.StatusInfo) > 0 {
		i -= len(m.StatusInfo)
		copy(dAtA[i:], m.StatusInfo)
		i = encodeVarintRelayer(dAtA, i, uint64(len(m.StatusInfo)))
		i--
		dAtA[i] = 0x22
	}
	if m.Status != 0 {
		i = encodeVarintRelayer(dAtA, i, uint64(m.Status))
		i--
		dAtA[i] = 0x18
	}
	if len(m.ChainId) > 0 {
		i -= len(m.ChainId)
		copy(dAtA[i:], m.ChainId)
		i = encodeVarintRelayer(dAtA, i, uint64(len(m.ChainId)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.EventId) > 0 {
		i -= len(m.EventId)
		copy(dAtA[i:], m.EventId)
		i = encodeVarintRelayer(dAtA, i, uint64(len(m.EventId)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *RollbackReq) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *RollbackReq) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *RollbackReq) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.ChainId) > 0 {
		i -= len(m.ChainId)
		copy(dAtA[i:], m.ChainId)
		i = encodeVarintRelayer(dAtA, i, uint64(len(m.ChainId)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.EventId) > 0 {
		i -= len(m.EventId)
		copy(dAtA[i:], m.EventId)
		i = encodeVarintRelayer(dAtA, i, uint64(len(m.EventId)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *RollbackResult) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *RollbackResult) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *RollbackResult) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.StatusInfo) > 0 {
		i -= len(m.StatusInfo)
		copy(dAtA[i:], m.StatusInfo)
		i = encodeVarintRelayer(dAtA, i, uint64(len(m.StatusInfo)))
		i--
		dAtA[i] = 0x22
	}
	if m.Status != 0 {
		i = encodeVarintRelayer(dAtA, i, uint64(m.Status))
		i--
		dAtA[i] = 0x18
	}
	if len(m.ChainId) > 0 {
		i -= len(m.ChainId)
		copy(dAtA[i:], m.ChainId)
		i = encodeVarintRelayer(dAtA, i, uint64(len(m.ChainId)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.EventId) > 0 {
		i -= len(m.EventId)
		copy(dAtA[i:], m.EventId)
		i = encodeVarintRelayer(dAtA, i, uint64(len(m.EventId)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *QueryChainsReq) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *QueryChainsReq) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *QueryChainsReq) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.RelayerId) > 0 {
		i -= len(m.RelayerId)
		copy(dAtA[i:], m.RelayerId)
		i = encodeVarintRelayer(dAtA, i, uint64(len(m.RelayerId)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *QueryChainsRes) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *QueryChainsRes) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *QueryChainsRes) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.RegisteredChains) > 0 {
		for iNdEx := len(m.RegisteredChains) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.RegisteredChains[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintRelayer(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x12
		}
	}
	return len(dAtA) - i, nil
}

func (m *QueryContractsReq) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *QueryContractsReq) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *QueryContractsReq) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Chain) > 0 {
		i -= len(m.Chain)
		copy(dAtA[i:], m.Chain)
		i = encodeVarintRelayer(dAtA, i, uint64(len(m.Chain)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *QueryContractsRes) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *QueryContractsRes) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *QueryContractsRes) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.RegisteredContracts != nil {
		{
			size, err := m.RegisteredContracts.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintRelayer(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	return len(dAtA) - i, nil
}

func (m *QueryContractInfoReq) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *QueryContractInfoReq) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *QueryContractInfoReq) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Contract) > 0 {
		i -= len(m.Contract)
		copy(dAtA[i:], m.Contract)
		i = encodeVarintRelayer(dAtA, i, uint64(len(m.Contract)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Chain) > 0 {
		i -= len(m.Chain)
		copy(dAtA[i:], m.Chain)
		i = encodeVarintRelayer(dAtA, i, uint64(len(m.Chain)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *QueryContractInfoRes) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *QueryContractInfoRes) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *QueryContractInfoRes) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.ContractInfo != nil {
		{
			size, err := m.ContractInfo.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintRelayer(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	return len(dAtA) - i, nil
}

func (m *QueryCrossEventInfoReq) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *QueryCrossEventInfoReq) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *QueryCrossEventInfoReq) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.EventId) > 0 {
		i -= len(m.EventId)
		copy(dAtA[i:], m.EventId)
		i = encodeVarintRelayer(dAtA, i, uint64(len(m.EventId)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.RelayerId) > 0 {
		i -= len(m.RelayerId)
		copy(dAtA[i:], m.RelayerId)
		i = encodeVarintRelayer(dAtA, i, uint64(len(m.RelayerId)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *QueryCrossEventInfoRes) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *QueryCrossEventInfoRes) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *QueryCrossEventInfoRes) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Participants) > 0 {
		for iNdEx := len(m.Participants) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Participants[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintRelayer(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x22
		}
	}
	if m.Phase != 0 {
		i = encodeVarintRelayer(dAtA, i, uint64(m.Phase))
		i--
		dAtA[i] = 0x18
	}
	if m.Launcher != nil {
		{
			size, err := m.Launcher.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintRelayer(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	if len(m.EventId) > 0 {
		i -= len(m.EventId)
		copy(dAtA[i:], m.EventId)
		i = encodeVarintRelayer(dAtA, i, uint64(len(m.EventId)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *TxIndex) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *TxIndex) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *TxIndex) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.TxNumber != 0 {
		i = encodeVarintRelayer(dAtA, i, uint64(m.TxNumber))
		i--
		dAtA[i] = 0x10
	}
	if m.BlockNumber != 0 {
		i = encodeVarintRelayer(dAtA, i, uint64(m.BlockNumber))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *TxMsg) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *TxMsg) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *TxMsg) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Index != nil {
		{
			size, err := m.Index.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintRelayer(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x2a
	}
	if m.Phase != 0 {
		i = encodeVarintRelayer(dAtA, i, uint64(m.Phase))
		i--
		dAtA[i] = 0x20
	}
	if len(m.Contract) > 0 {
		i -= len(m.Contract)
		copy(dAtA[i:], m.Contract)
		i = encodeVarintRelayer(dAtA, i, uint64(len(m.Contract)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.Chain) > 0 {
		i -= len(m.Chain)
		copy(dAtA[i:], m.Chain)
		i = encodeVarintRelayer(dAtA, i, uint64(len(m.Chain)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.EventId) > 0 {
		i -= len(m.EventId)
		copy(dAtA[i:], m.EventId)
		i = encodeVarintRelayer(dAtA, i, uint64(len(m.EventId)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *SdkRawMsg) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SdkRawMsg) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *SdkRawMsg) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.BlockResult) > 0 {
		i -= len(m.BlockResult)
		copy(dAtA[i:], m.BlockResult)
		i = encodeVarintRelayer(dAtA, i, uint64(len(m.BlockResult)))
		i--
		dAtA[i] = 0x22
	}
	if len(m.ExecTxs) > 0 {
		for iNdEx := len(m.ExecTxs) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.ExecTxs[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintRelayer(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x1a
		}
	}
	if m.BlockNumber != 0 {
		i = encodeVarintRelayer(dAtA, i, uint64(m.BlockNumber))
		i--
		dAtA[i] = 0x10
	}
	if len(m.Chain) > 0 {
		i -= len(m.Chain)
		copy(dAtA[i:], m.Chain)
		i = encodeVarintRelayer(dAtA, i, uint64(len(m.Chain)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *BlockInfo) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *BlockInfo) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *BlockInfo) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.TxsValid) > 0 {
		for iNdEx := len(m.TxsValid) - 1; iNdEx >= 0; iNdEx-- {
			i--
			if m.TxsValid[iNdEx] {
				dAtA[i] = 1
			} else {
				dAtA[i] = 0
			}
		}
		i = encodeVarintRelayer(dAtA, i, uint64(len(m.TxsValid)))
		i--
		dAtA[i] = 0x22
	}
	if len(m.TxsPayload) > 0 {
		for iNdEx := len(m.TxsPayload) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.TxsPayload[iNdEx])
			copy(dAtA[i:], m.TxsPayload[iNdEx])
			i = encodeVarintRelayer(dAtA, i, uint64(len(m.TxsPayload[iNdEx])))
			i--
			dAtA[i] = 0x1a
		}
	}
	if len(m.Chain) > 0 {
		i -= len(m.Chain)
		copy(dAtA[i:], m.Chain)
		i = encodeVarintRelayer(dAtA, i, uint64(len(m.Chain)))
		i--
		dAtA[i] = 0x12
	}
	if m.BlockNumber != 0 {
		i = encodeVarintRelayer(dAtA, i, uint64(m.BlockNumber))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *InvokeChainInfo) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *InvokeChainInfo) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *InvokeChainInfo) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Args) > 0 {
		for iNdEx := len(m.Args) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.Args[iNdEx])
			copy(dAtA[i:], m.Args[iNdEx])
			i = encodeVarintRelayer(dAtA, i, uint64(len(m.Args[iNdEx])))
			i--
			dAtA[i] = 0x2a
		}
	}
	if len(m.Func) > 0 {
		i -= len(m.Func)
		copy(dAtA[i:], m.Func)
		i = encodeVarintRelayer(dAtA, i, uint64(len(m.Func)))
		i--
		dAtA[i] = 0x22
	}
	if len(m.Contract) > 0 {
		i -= len(m.Contract)
		copy(dAtA[i:], m.Contract)
		i = encodeVarintRelayer(dAtA, i, uint64(len(m.Contract)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.Chain) > 0 {
		i -= len(m.Chain)
		copy(dAtA[i:], m.Chain)
		i = encodeVarintRelayer(dAtA, i, uint64(len(m.Chain)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.ChainAddr) > 0 {
		i -= len(m.ChainAddr)
		copy(dAtA[i:], m.ChainAddr)
		i = encodeVarintRelayer(dAtA, i, uint64(len(m.ChainAddr)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *CrossInvoke) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CrossInvoke) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *CrossInvoke) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Participants) > 0 {
		for iNdEx := len(m.Participants) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Participants[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintRelayer(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x1a
		}
	}
	if m.Initiator != nil {
		{
			size, err := m.Initiator.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintRelayer(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	if len(m.EventId) > 0 {
		i -= len(m.EventId)
		copy(dAtA[i:], m.EventId)
		i = encodeVarintRelayer(dAtA, i, uint64(len(m.EventId)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *RegContract) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *RegContract) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *RegContract) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Phasefunc) > 0 {
		for iNdEx := len(m.Phasefunc) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Phasefunc[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintRelayer(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x1a
		}
	}
	if len(m.Func) > 0 {
		i -= len(m.Func)
		copy(dAtA[i:], m.Func)
		i = encodeVarintRelayer(dAtA, i, uint64(len(m.Func)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Contract) > 0 {
		i -= len(m.Contract)
		copy(dAtA[i:], m.Contract)
		i = encodeVarintRelayer(dAtA, i, uint64(len(m.Contract)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *WasmInvokeRes) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *WasmInvokeRes) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *WasmInvokeRes) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Result) > 0 {
		i -= len(m.Result)
		copy(dAtA[i:], m.Result)
		i = encodeVarintRelayer(dAtA, i, uint64(len(m.Result)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.StatusInfo) > 0 {
		i -= len(m.StatusInfo)
		copy(dAtA[i:], m.StatusInfo)
		i = encodeVarintRelayer(dAtA, i, uint64(len(m.StatusInfo)))
		i--
		dAtA[i] = 0x12
	}
	if m.Status != 0 {
		i = encodeVarintRelayer(dAtA, i, uint64(m.Status))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *Replay) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Replay) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Replay) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	return len(dAtA) - i, nil
}

func encodeVarintRelayer(dAtA []byte, offset int, v uint64) int {
	offset -= sovRelayer(v)
	base := offset
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return base
}
func (m *State) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Key)
	if l > 0 {
		n += 1 + l + sovRelayer(uint64(l))
	}
	l = len(m.State)
	if l > 0 {
		n += 1 + l + sovRelayer(uint64(l))
	}
	if m.Phase != 0 {
		n += 1 + sovRelayer(uint64(m.Phase))
	}
	return n
}

func (m *States) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.EncryptedStates) > 0 {
		for _, e := range m.EncryptedStates {
			l = e.Size()
			n += 1 + l + sovRelayer(uint64(l))
		}
	}
	return n
}

func (m *ExecMsg) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Status != 0 {
		n += 1 + sovRelayer(uint64(m.Status))
	}
	if len(m.Msg) > 0 {
		for _, b := range m.Msg {
			l = len(b)
			n += 1 + l + sovRelayer(uint64(l))
		}
	}
	return n
}

func (m *DataIndex) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Indexs) > 0 {
		l = 0
		for _, e := range m.Indexs {
			l += sovRelayer(uint64(e))
		}
		n += 1 + sovRelayer(uint64(l)) + l
	}
	return n
}

func (m *ExecInput) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Msg != nil {
		l = m.Msg.Size()
		n += 1 + l + sovRelayer(uint64(l))
	}
	if m.States != nil {
		l = m.States.Size()
		n += 1 + l + sovRelayer(uint64(l))
	}
	if m.Cmd != 0 {
		n += 1 + sovRelayer(uint64(m.Cmd))
	}
	return n
}

func (m *ExecResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Status != 0 {
		n += 1 + sovRelayer(uint64(m.Status))
	}
	l = len(m.StatusMsg)
	if l > 0 {
		n += 1 + l + sovRelayer(uint64(l))
	}
	if m.UpdateStates != nil {
		l = m.UpdateStates.Size()
		n += 1 + l + sovRelayer(uint64(l))
	}
	if m.NextEvent != nil {
		l = m.NextEvent.Size()
		n += 1 + l + sovRelayer(uint64(l))
	}
	l = len(m.Extension)
	if l > 0 {
		n += 1 + l + sovRelayer(uint64(l))
	}
	return n
}

func (m *RawMessage) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Signature != nil {
		l = m.Signature.Size()
		n += 1 + l + sovRelayer(uint64(l))
	}
	l = len(m.Payload)
	if l > 0 {
		n += 1 + l + sovRelayer(uint64(l))
	}
	return n
}

func (m *RawMessage_Signature) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.PubKey)
	if l > 0 {
		n += 1 + l + sovRelayer(uint64(l))
	}
	l = len(m.Sign)
	if l > 0 {
		n += 1 + l + sovRelayer(uint64(l))
	}
	return n
}

func (m *ChainId) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Chain)
	if l > 0 {
		n += 1 + l + sovRelayer(uint64(l))
	}
	l = len(m.ChainId)
	if l > 0 {
		n += 1 + l + sovRelayer(uint64(l))
	}
	return n
}

func (m *RegisteredChains) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.RelayerId)
	if l > 0 {
		n += 1 + l + sovRelayer(uint64(l))
	}
	if len(m.ChainIds) > 0 {
		for _, e := range m.ChainIds {
			l = e.Size()
			n += 1 + l + sovRelayer(uint64(l))
		}
	}
	return n
}

func (m *OrgCa) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.OrgId)
	if l > 0 {
		n += 1 + l + sovRelayer(uint64(l))
	}
	l = len(m.CaCert)
	if l > 0 {
		n += 1 + l + sovRelayer(uint64(l))
	}
	return n
}

func (m *ChainCas) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Chain)
	if l > 0 {
		n += 1 + l + sovRelayer(uint64(l))
	}
	if len(m.ChainCas) > 0 {
		for _, e := range m.ChainCas {
			l = e.Size()
			n += 1 + l + sovRelayer(uint64(l))
		}
	}
	return n
}

func (m *ChainContracts) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Chain)
	if l > 0 {
		n += 1 + l + sovRelayer(uint64(l))
	}
	if len(m.Contract) > 0 {
		for _, s := range m.Contract {
			l = len(s)
			n += 1 + l + sovRelayer(uint64(l))
		}
	}
	return n
}

func (m *PhaseFunc) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.RegisterFunc)
	if l > 0 {
		n += 1 + l + sovRelayer(uint64(l))
	}
	l = len(m.InitiatorFunc)
	if l > 0 {
		n += 1 + l + sovRelayer(uint64(l))
	}
	l = len(m.PrepareFunc)
	if l > 0 {
		n += 1 + l + sovRelayer(uint64(l))
	}
	l = len(m.CommitFunc)
	if l > 0 {
		n += 1 + l + sovRelayer(uint64(l))
	}
	l = len(m.RollbackFunc)
	if l > 0 {
		n += 1 + l + sovRelayer(uint64(l))
	}
	return n
}

func (m *ContractInfo) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovRelayer(uint64(l))
	}
	l = len(m.Chain)
	if l > 0 {
		n += 1 + l + sovRelayer(uint64(l))
	}
	if m.Phase != 0 {
		n += 1 + sovRelayer(uint64(m.Phase))
	}
	l = len(m.VerifyRule)
	if l > 0 {
		n += 1 + l + sovRelayer(uint64(l))
	}
	if len(m.PhaseFuncGroup) > 0 {
		for _, e := range m.PhaseFuncGroup {
			l = e.Size()
			n += 1 + l + sovRelayer(uint64(l))
		}
	}
	if len(m.InvokedList) > 0 {
		for _, e := range m.InvokedList {
			l = e.Size()
			n += 1 + l + sovRelayer(uint64(l))
		}
	}
	return n
}

func (m *SubAction) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.ChainId)
	if l > 0 {
		n += 1 + l + sovRelayer(uint64(l))
	}
	l = len(m.Chain)
	if l > 0 {
		n += 1 + l + sovRelayer(uint64(l))
	}
	l = len(m.Contract)
	if l > 0 {
		n += 1 + l + sovRelayer(uint64(l))
	}
	if len(m.Args) > 0 {
		for _, b := range m.Args {
			l = len(b)
			n += 1 + l + sovRelayer(uint64(l))
		}
	}
	if m.Phase != 0 {
		n += 1 + sovRelayer(uint64(m.Phase))
	}
	return n
}

func (m *InvokePara) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Action != nil {
		l = m.Action.Size()
		n += 1 + l + sovRelayer(uint64(l))
	}
	if m.Funcs != nil {
		l = m.Funcs.Size()
		n += 1 + l + sovRelayer(uint64(l))
	}
	return n
}

func (m *CrossContract) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.ChainId)
	if l > 0 {
		n += 1 + l + sovRelayer(uint64(l))
	}
	l = len(m.Contract)
	if l > 0 {
		n += 1 + l + sovRelayer(uint64(l))
	}
	if m.Phase != 0 {
		n += 1 + sovRelayer(uint64(m.Phase))
	}
	return n
}

func (m *EventInfo) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Property != 0 {
		n += 1 + sovRelayer(uint64(m.Property))
	}
	l = len(m.EventId)
	if l > 0 {
		n += 1 + l + sovRelayer(uint64(l))
	}
	if m.Launcher != nil {
		l = m.Launcher.Size()
		n += 1 + l + sovRelayer(uint64(l))
	}
	if m.Phase != 0 {
		n += 1 + sovRelayer(uint64(m.Phase))
	}
	if len(m.Invoke) > 0 {
		for _, e := range m.Invoke {
			l = e.Size()
			n += 1 + l + sovRelayer(uint64(l))
		}
	}
	if len(m.Actions) > 0 {
		for _, e := range m.Actions {
			l = e.Size()
			n += 1 + l + sovRelayer(uint64(l))
		}
	}
	return n
}

func (m *ChainUpdate) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Chain)
	if l > 0 {
		n += 1 + l + sovRelayer(uint64(l))
	}
	l = len(m.Contract)
	if l > 0 {
		n += 1 + l + sovRelayer(uint64(l))
	}
	if m.Funcs != nil {
		l = m.Funcs.Size()
		n += 1 + l + sovRelayer(uint64(l))
	}
	if m.Number != 0 {
		n += 1 + sovRelayer(uint64(m.Number))
	}
	return n
}

func (m *NextExecution) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.SdkAction) > 0 {
		for _, e := range m.SdkAction {
			l = e.Size()
			n += 1 + l + sovRelayer(uint64(l))
		}
	}
	if len(m.RemoteMsg) > 0 {
		for _, e := range m.RemoteMsg {
			l = e.Size()
			n += 1 + l + sovRelayer(uint64(l))
		}
	}
	if m.SignRes != nil {
		l = m.SignRes.Size()
		n += 1 + l + sovRelayer(uint64(l))
	}
	if m.Update != nil {
		l = m.Update.Size()
		n += 1 + l + sovRelayer(uint64(l))
	}
	return n
}

func (m *ChainMsg) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Payload)
	if l > 0 {
		n += 1 + l + sovRelayer(uint64(l))
	}
	l = len(m.Sign)
	if l > 0 {
		n += 1 + l + sovRelayer(uint64(l))
	}
	l = len(m.PubKey)
	if l > 0 {
		n += 1 + l + sovRelayer(uint64(l))
	}
	l = len(m.RelayerId)
	if l > 0 {
		n += 1 + l + sovRelayer(uint64(l))
	}
	return n
}

func (m *SignResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Payload)
	if l > 0 {
		n += 1 + l + sovRelayer(uint64(l))
	}
	l = len(m.Sign)
	if l > 0 {
		n += 1 + l + sovRelayer(uint64(l))
	}
	return n
}

func (m *ChainHeight) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Chain)
	if l > 0 {
		n += 1 + l + sovRelayer(uint64(l))
	}
	if m.BlockNumber != 0 {
		n += 1 + sovRelayer(uint64(m.BlockNumber))
	}
	return n
}

func (m *ChainsHeight) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.RelayerId)
	if l > 0 {
		n += 1 + l + sovRelayer(uint64(l))
	}
	if len(m.Chains) > 0 {
		for _, e := range m.Chains {
			l = e.Size()
			n += 1 + l + sovRelayer(uint64(l))
		}
	}
	return n
}

func (m *Block) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.BlockNumber != 0 {
		n += 1 + sovRelayer(uint64(m.BlockNumber))
	}
	if len(m.Payload) > 0 {
		for _, b := range m.Payload {
			l = len(b)
			n += 1 + l + sovRelayer(uint64(l))
		}
	}
	return n
}

func (m *CrossMsg) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Type != 0 {
		n += 1 + sovRelayer(uint64(m.Type))
	}
	l = len(m.Payload)
	if l > 0 {
		n += 1 + l + sovRelayer(uint64(l))
	}
	return n
}

func (m *Request) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Type != 0 {
		n += 1 + sovRelayer(uint64(m.Type))
	}
	l = len(m.Payload)
	if l > 0 {
		n += 1 + l + sovRelayer(uint64(l))
	}
	return n
}

func (m *Response) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Status != 0 {
		n += 1 + sovRelayer(uint64(m.Status))
	}
	l = len(m.StatusInfo)
	if l > 0 {
		n += 1 + l + sovRelayer(uint64(l))
	}
	l = len(m.Payload)
	if l > 0 {
		n += 1 + l + sovRelayer(uint64(l))
	}
	return n
}

func (m *RegisterChain) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovRelayer(uint64(l))
	}
	if m.Cas != nil {
		l = m.Cas.Size()
		n += 1 + l + sovRelayer(uint64(l))
	}
	if m.Height != 0 {
		n += 1 + sovRelayer(uint64(m.Height))
	}
	return n
}

func (m *RegisterChainRes) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Status != 0 {
		n += 1 + sovRelayer(uint64(m.Status))
	}
	l = len(m.StatusInfo)
	if l > 0 {
		n += 1 + l + sovRelayer(uint64(l))
	}
	l = len(m.ChainAddr)
	if l > 0 {
		n += 1 + l + sovRelayer(uint64(l))
	}
	return n
}

func (m *RegisterContract) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovRelayer(uint64(l))
	}
	l = len(m.Chain)
	if l > 0 {
		n += 1 + l + sovRelayer(uint64(l))
	}
	l = len(m.VerifyRule)
	if l > 0 {
		n += 1 + l + sovRelayer(uint64(l))
	}
	if len(m.InvokedList) > 0 {
		for _, e := range m.InvokedList {
			l = e.Size()
			n += 1 + l + sovRelayer(uint64(l))
		}
	}
	return n
}

func (m *RegisterContractRes) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Status != 0 {
		n += 1 + sovRelayer(uint64(m.Status))
	}
	l = len(m.StatusInfo)
	if l > 0 {
		n += 1 + l + sovRelayer(uint64(l))
	}
	return n
}

func (m *SyncChainsReq) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Chains != nil {
		l = m.Chains.Size()
		n += 1 + l + sovRelayer(uint64(l))
	}
	return n
}

func (m *PreExecuteReq) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.EventId)
	if l > 0 {
		n += 1 + l + sovRelayer(uint64(l))
	}
	l = len(m.LaunchChainId)
	if l > 0 {
		n += 1 + l + sovRelayer(uint64(l))
	}
	l = len(m.LaunchContract)
	if l > 0 {
		n += 1 + l + sovRelayer(uint64(l))
	}
	if m.Action != nil {
		l = m.Action.Size()
		n += 1 + l + sovRelayer(uint64(l))
	}
	return n
}

func (m *PreExecuteResult) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.EventId)
	if l > 0 {
		n += 1 + l + sovRelayer(uint64(l))
	}
	l = len(m.ChainId)
	if l > 0 {
		n += 1 + l + sovRelayer(uint64(l))
	}
	if m.Status != 0 {
		n += 1 + sovRelayer(uint64(m.Status))
	}
	l = len(m.StatusInfo)
	if l > 0 {
		n += 1 + l + sovRelayer(uint64(l))
	}
	return n
}

func (m *CommitReq) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.EventId)
	if l > 0 {
		n += 1 + l + sovRelayer(uint64(l))
	}
	l = len(m.ChainId)
	if l > 0 {
		n += 1 + l + sovRelayer(uint64(l))
	}
	return n
}

func (m *CommitResult) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.EventId)
	if l > 0 {
		n += 1 + l + sovRelayer(uint64(l))
	}
	l = len(m.ChainId)
	if l > 0 {
		n += 1 + l + sovRelayer(uint64(l))
	}
	if m.Status != 0 {
		n += 1 + sovRelayer(uint64(m.Status))
	}
	l = len(m.StatusInfo)
	if l > 0 {
		n += 1 + l + sovRelayer(uint64(l))
	}
	return n
}

func (m *RollbackReq) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.EventId)
	if l > 0 {
		n += 1 + l + sovRelayer(uint64(l))
	}
	l = len(m.ChainId)
	if l > 0 {
		n += 1 + l + sovRelayer(uint64(l))
	}
	return n
}

func (m *RollbackResult) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.EventId)
	if l > 0 {
		n += 1 + l + sovRelayer(uint64(l))
	}
	l = len(m.ChainId)
	if l > 0 {
		n += 1 + l + sovRelayer(uint64(l))
	}
	if m.Status != 0 {
		n += 1 + sovRelayer(uint64(m.Status))
	}
	l = len(m.StatusInfo)
	if l > 0 {
		n += 1 + l + sovRelayer(uint64(l))
	}
	return n
}

func (m *QueryChainsReq) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.RelayerId)
	if l > 0 {
		n += 1 + l + sovRelayer(uint64(l))
	}
	return n
}

func (m *QueryChainsRes) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.RegisteredChains) > 0 {
		for _, e := range m.RegisteredChains {
			l = e.Size()
			n += 1 + l + sovRelayer(uint64(l))
		}
	}
	return n
}

func (m *QueryContractsReq) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Chain)
	if l > 0 {
		n += 1 + l + sovRelayer(uint64(l))
	}
	return n
}

func (m *QueryContractsRes) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.RegisteredContracts != nil {
		l = m.RegisteredContracts.Size()
		n += 1 + l + sovRelayer(uint64(l))
	}
	return n
}

func (m *QueryContractInfoReq) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Chain)
	if l > 0 {
		n += 1 + l + sovRelayer(uint64(l))
	}
	l = len(m.Contract)
	if l > 0 {
		n += 1 + l + sovRelayer(uint64(l))
	}
	return n
}

func (m *QueryContractInfoRes) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.ContractInfo != nil {
		l = m.ContractInfo.Size()
		n += 1 + l + sovRelayer(uint64(l))
	}
	return n
}

func (m *QueryCrossEventInfoReq) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.RelayerId)
	if l > 0 {
		n += 1 + l + sovRelayer(uint64(l))
	}
	l = len(m.EventId)
	if l > 0 {
		n += 1 + l + sovRelayer(uint64(l))
	}
	return n
}

func (m *QueryCrossEventInfoRes) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.EventId)
	if l > 0 {
		n += 1 + l + sovRelayer(uint64(l))
	}
	if m.Launcher != nil {
		l = m.Launcher.Size()
		n += 1 + l + sovRelayer(uint64(l))
	}
	if m.Phase != 0 {
		n += 1 + sovRelayer(uint64(m.Phase))
	}
	if len(m.Participants) > 0 {
		for _, e := range m.Participants {
			l = e.Size()
			n += 1 + l + sovRelayer(uint64(l))
		}
	}
	return n
}

func (m *TxIndex) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.BlockNumber != 0 {
		n += 1 + sovRelayer(uint64(m.BlockNumber))
	}
	if m.TxNumber != 0 {
		n += 1 + sovRelayer(uint64(m.TxNumber))
	}
	return n
}

func (m *TxMsg) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.EventId)
	if l > 0 {
		n += 1 + l + sovRelayer(uint64(l))
	}
	l = len(m.Chain)
	if l > 0 {
		n += 1 + l + sovRelayer(uint64(l))
	}
	l = len(m.Contract)
	if l > 0 {
		n += 1 + l + sovRelayer(uint64(l))
	}
	if m.Phase != 0 {
		n += 1 + sovRelayer(uint64(m.Phase))
	}
	if m.Index != nil {
		l = m.Index.Size()
		n += 1 + l + sovRelayer(uint64(l))
	}
	return n
}

func (m *SdkRawMsg) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Chain)
	if l > 0 {
		n += 1 + l + sovRelayer(uint64(l))
	}
	if m.BlockNumber != 0 {
		n += 1 + sovRelayer(uint64(m.BlockNumber))
	}
	if len(m.ExecTxs) > 0 {
		for _, e := range m.ExecTxs {
			l = e.Size()
			n += 1 + l + sovRelayer(uint64(l))
		}
	}
	l = len(m.BlockResult)
	if l > 0 {
		n += 1 + l + sovRelayer(uint64(l))
	}
	return n
}

func (m *BlockInfo) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.BlockNumber != 0 {
		n += 1 + sovRelayer(uint64(m.BlockNumber))
	}
	l = len(m.Chain)
	if l > 0 {
		n += 1 + l + sovRelayer(uint64(l))
	}
	if len(m.TxsPayload) > 0 {
		for _, b := range m.TxsPayload {
			l = len(b)
			n += 1 + l + sovRelayer(uint64(l))
		}
	}
	if len(m.TxsValid) > 0 {
		n += 1 + sovRelayer(uint64(len(m.TxsValid))) + len(m.TxsValid)*1
	}
	return n
}

func (m *InvokeChainInfo) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.ChainAddr)
	if l > 0 {
		n += 1 + l + sovRelayer(uint64(l))
	}
	l = len(m.Chain)
	if l > 0 {
		n += 1 + l + sovRelayer(uint64(l))
	}
	l = len(m.Contract)
	if l > 0 {
		n += 1 + l + sovRelayer(uint64(l))
	}
	l = len(m.Func)
	if l > 0 {
		n += 1 + l + sovRelayer(uint64(l))
	}
	if len(m.Args) > 0 {
		for _, b := range m.Args {
			l = len(b)
			n += 1 + l + sovRelayer(uint64(l))
		}
	}
	return n
}

func (m *CrossInvoke) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.EventId)
	if l > 0 {
		n += 1 + l + sovRelayer(uint64(l))
	}
	if m.Initiator != nil {
		l = m.Initiator.Size()
		n += 1 + l + sovRelayer(uint64(l))
	}
	if len(m.Participants) > 0 {
		for _, e := range m.Participants {
			l = e.Size()
			n += 1 + l + sovRelayer(uint64(l))
		}
	}
	return n
}

func (m *RegContract) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Contract)
	if l > 0 {
		n += 1 + l + sovRelayer(uint64(l))
	}
	l = len(m.Func)
	if l > 0 {
		n += 1 + l + sovRelayer(uint64(l))
	}
	if len(m.Phasefunc) > 0 {
		for _, e := range m.Phasefunc {
			l = e.Size()
			n += 1 + l + sovRelayer(uint64(l))
		}
	}
	return n
}

func (m *WasmInvokeRes) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Status != 0 {
		n += 1 + sovRelayer(uint64(m.Status))
	}
	l = len(m.StatusInfo)
	if l > 0 {
		n += 1 + l + sovRelayer(uint64(l))
	}
	l = len(m.Result)
	if l > 0 {
		n += 1 + l + sovRelayer(uint64(l))
	}
	return n
}

func (m *Replay) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	return n
}

func sovRelayer(x uint64) (n int) {
	return (math_bits.Len64(x|1) + 6) / 7
}
func sozRelayer(x uint64) (n int) {
	return sovRelayer(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (m *State) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowRelayer
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: State: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: State: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Key", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRelayer
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthRelayer
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthRelayer
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Key = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field State", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRelayer
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthRelayer
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthRelayer
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.State = append(m.State[:0], dAtA[iNdEx:postIndex]...)
			if m.State == nil {
				m.State = []byte{}
			}
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Phase", wireType)
			}
			m.Phase = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRelayer
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Phase |= StatePhase(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipRelayer(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthRelayer
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *States) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowRelayer
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: States: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: States: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field EncryptedStates", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRelayer
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthRelayer
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthRelayer
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.EncryptedStates = append(m.EncryptedStates, &State{})
			if err := m.EncryptedStates[len(m.EncryptedStates)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipRelayer(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthRelayer
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ExecMsg) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowRelayer
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ExecMsg: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ExecMsg: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Status", wireType)
			}
			m.Status = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRelayer
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Status |= Status(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Msg", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRelayer
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthRelayer
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthRelayer
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Msg = append(m.Msg, make([]byte, postIndex-iNdEx))
			copy(m.Msg[len(m.Msg)-1], dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipRelayer(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthRelayer
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *DataIndex) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowRelayer
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: DataIndex: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: DataIndex: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType == 0 {
				var v uint32
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowRelayer
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= uint32(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.Indexs = append(m.Indexs, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowRelayer
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthRelayer
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLengthRelayer
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				var count int
				for _, integer := range dAtA[iNdEx:postIndex] {
					if integer < 128 {
						count++
					}
				}
				elementCount = count
				if elementCount != 0 && len(m.Indexs) == 0 {
					m.Indexs = make([]uint32, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v uint32
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowRelayer
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= uint32(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.Indexs = append(m.Indexs, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field Indexs", wireType)
			}
		default:
			iNdEx = preIndex
			skippy, err := skipRelayer(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthRelayer
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ExecInput) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowRelayer
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ExecInput: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ExecInput: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Msg", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRelayer
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthRelayer
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthRelayer
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Msg == nil {
				m.Msg = &ExecMsg{}
			}
			if err := m.Msg.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field States", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRelayer
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthRelayer
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthRelayer
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.States == nil {
				m.States = &States{}
			}
			if err := m.States.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Cmd", wireType)
			}
			m.Cmd = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRelayer
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Cmd |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipRelayer(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthRelayer
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ExecResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowRelayer
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ExecResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ExecResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Status", wireType)
			}
			m.Status = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRelayer
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Status |= Status(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field StatusMsg", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRelayer
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthRelayer
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthRelayer
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.StatusMsg = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field UpdateStates", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRelayer
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthRelayer
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthRelayer
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.UpdateStates == nil {
				m.UpdateStates = &States{}
			}
			if err := m.UpdateStates.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field NextEvent", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRelayer
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthRelayer
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthRelayer
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.NextEvent == nil {
				m.NextEvent = &NextExecution{}
			}
			if err := m.NextEvent.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Extension", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRelayer
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthRelayer
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthRelayer
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Extension = append(m.Extension[:0], dAtA[iNdEx:postIndex]...)
			if m.Extension == nil {
				m.Extension = []byte{}
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipRelayer(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthRelayer
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *RawMessage) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowRelayer
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: RawMessage: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: RawMessage: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Signature", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRelayer
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthRelayer
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthRelayer
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Signature == nil {
				m.Signature = &RawMessage_Signature{}
			}
			if err := m.Signature.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Payload", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRelayer
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthRelayer
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthRelayer
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Payload = append(m.Payload[:0], dAtA[iNdEx:postIndex]...)
			if m.Payload == nil {
				m.Payload = []byte{}
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipRelayer(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthRelayer
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *RawMessage_Signature) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowRelayer
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Signature: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Signature: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PubKey", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRelayer
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthRelayer
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthRelayer
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.PubKey = append(m.PubKey[:0], dAtA[iNdEx:postIndex]...)
			if m.PubKey == nil {
				m.PubKey = []byte{}
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Sign", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRelayer
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthRelayer
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthRelayer
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Sign = append(m.Sign[:0], dAtA[iNdEx:postIndex]...)
			if m.Sign == nil {
				m.Sign = []byte{}
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipRelayer(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthRelayer
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ChainId) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowRelayer
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ChainId: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ChainId: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Chain", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRelayer
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthRelayer
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthRelayer
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Chain = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ChainId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRelayer
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthRelayer
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthRelayer
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ChainId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipRelayer(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthRelayer
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *RegisteredChains) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowRelayer
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: RegisteredChains: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: RegisteredChains: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RelayerId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRelayer
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthRelayer
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthRelayer
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.RelayerId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ChainIds", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRelayer
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthRelayer
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthRelayer
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ChainIds = append(m.ChainIds, &ChainId{})
			if err := m.ChainIds[len(m.ChainIds)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipRelayer(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthRelayer
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *OrgCa) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowRelayer
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: OrgCa: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: OrgCa: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field OrgId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRelayer
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthRelayer
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthRelayer
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.OrgId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CaCert", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRelayer
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthRelayer
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthRelayer
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.CaCert = append(m.CaCert[:0], dAtA[iNdEx:postIndex]...)
			if m.CaCert == nil {
				m.CaCert = []byte{}
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipRelayer(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthRelayer
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ChainCas) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowRelayer
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ChainCas: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ChainCas: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Chain", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRelayer
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthRelayer
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthRelayer
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Chain = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ChainCas", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRelayer
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthRelayer
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthRelayer
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ChainCas = append(m.ChainCas, &OrgCa{})
			if err := m.ChainCas[len(m.ChainCas)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipRelayer(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthRelayer
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ChainContracts) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowRelayer
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ChainContracts: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ChainContracts: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Chain", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRelayer
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthRelayer
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthRelayer
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Chain = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Contract", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRelayer
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthRelayer
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthRelayer
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Contract = append(m.Contract, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipRelayer(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthRelayer
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *PhaseFunc) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowRelayer
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: PhaseFunc: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: PhaseFunc: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RegisterFunc", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRelayer
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthRelayer
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthRelayer
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.RegisterFunc = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field InitiatorFunc", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRelayer
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthRelayer
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthRelayer
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.InitiatorFunc = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PrepareFunc", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRelayer
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthRelayer
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthRelayer
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.PrepareFunc = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CommitFunc", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRelayer
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthRelayer
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthRelayer
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.CommitFunc = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RollbackFunc", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRelayer
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthRelayer
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthRelayer
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.RollbackFunc = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipRelayer(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthRelayer
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ContractInfo) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowRelayer
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ContractInfo: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ContractInfo: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRelayer
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthRelayer
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthRelayer
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Chain", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRelayer
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthRelayer
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthRelayer
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Chain = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Phase", wireType)
			}
			m.Phase = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRelayer
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Phase |= StatePhase(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field VerifyRule", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRelayer
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthRelayer
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthRelayer
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.VerifyRule = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PhaseFuncGroup", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRelayer
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthRelayer
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthRelayer
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.PhaseFuncGroup = append(m.PhaseFuncGroup, &PhaseFunc{})
			if err := m.PhaseFuncGroup[len(m.PhaseFuncGroup)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field InvokedList", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRelayer
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthRelayer
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthRelayer
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.InvokedList = append(m.InvokedList, &CrossContract{})
			if err := m.InvokedList[len(m.InvokedList)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipRelayer(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthRelayer
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SubAction) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowRelayer
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SubAction: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SubAction: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ChainId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRelayer
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthRelayer
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthRelayer
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ChainId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Chain", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRelayer
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthRelayer
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthRelayer
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Chain = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Contract", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRelayer
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthRelayer
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthRelayer
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Contract = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Args", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRelayer
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthRelayer
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthRelayer
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Args = append(m.Args, make([]byte, postIndex-iNdEx))
			copy(m.Args[len(m.Args)-1], dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Phase", wireType)
			}
			m.Phase = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRelayer
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Phase |= StatePhase(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipRelayer(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthRelayer
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *InvokePara) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowRelayer
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: InvokePara: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: InvokePara: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Action", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRelayer
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthRelayer
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthRelayer
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Action == nil {
				m.Action = &SubAction{}
			}
			if err := m.Action.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Funcs", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRelayer
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthRelayer
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthRelayer
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Funcs == nil {
				m.Funcs = &PhaseFunc{}
			}
			if err := m.Funcs.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipRelayer(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthRelayer
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CrossContract) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowRelayer
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CrossContract: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CrossContract: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ChainId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRelayer
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthRelayer
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthRelayer
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ChainId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Contract", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRelayer
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthRelayer
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthRelayer
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Contract = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Phase", wireType)
			}
			m.Phase = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRelayer
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Phase |= StatePhase(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipRelayer(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthRelayer
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *EventInfo) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowRelayer
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: EventInfo: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: EventInfo: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Property", wireType)
			}
			m.Property = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRelayer
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Property |= Property(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field EventId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRelayer
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthRelayer
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthRelayer
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.EventId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Launcher", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRelayer
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthRelayer
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthRelayer
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Launcher == nil {
				m.Launcher = &CrossContract{}
			}
			if err := m.Launcher.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Phase", wireType)
			}
			m.Phase = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRelayer
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Phase |= StatePhase(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Invoke", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRelayer
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthRelayer
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthRelayer
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Invoke = append(m.Invoke, &InvokePara{})
			if err := m.Invoke[len(m.Invoke)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Actions", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRelayer
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthRelayer
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthRelayer
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Actions = append(m.Actions, &SubAction{})
			if err := m.Actions[len(m.Actions)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipRelayer(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthRelayer
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ChainUpdate) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowRelayer
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ChainUpdate: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ChainUpdate: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Chain", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRelayer
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthRelayer
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthRelayer
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Chain = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Contract", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRelayer
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthRelayer
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthRelayer
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Contract = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Funcs", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRelayer
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthRelayer
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthRelayer
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Funcs == nil {
				m.Funcs = &PhaseFunc{}
			}
			if err := m.Funcs.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Number", wireType)
			}
			m.Number = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRelayer
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Number |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipRelayer(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthRelayer
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *NextExecution) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowRelayer
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: NextExecution: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: NextExecution: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SdkAction", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRelayer
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthRelayer
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthRelayer
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.SdkAction = append(m.SdkAction, &InvokePara{})
			if err := m.SdkAction[len(m.SdkAction)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RemoteMsg", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRelayer
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthRelayer
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthRelayer
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.RemoteMsg = append(m.RemoteMsg, &ChainMsg{})
			if err := m.RemoteMsg[len(m.RemoteMsg)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SignRes", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRelayer
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthRelayer
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthRelayer
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.SignRes == nil {
				m.SignRes = &SignResponse{}
			}
			if err := m.SignRes.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Update", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRelayer
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthRelayer
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthRelayer
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Update == nil {
				m.Update = &ChainUpdate{}
			}
			if err := m.Update.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipRelayer(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthRelayer
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ChainMsg) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowRelayer
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ChainMsg: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ChainMsg: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Payload", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRelayer
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthRelayer
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthRelayer
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Payload = append(m.Payload[:0], dAtA[iNdEx:postIndex]...)
			if m.Payload == nil {
				m.Payload = []byte{}
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Sign", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRelayer
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthRelayer
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthRelayer
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Sign = append(m.Sign[:0], dAtA[iNdEx:postIndex]...)
			if m.Sign == nil {
				m.Sign = []byte{}
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PubKey", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRelayer
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthRelayer
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthRelayer
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.PubKey = append(m.PubKey[:0], dAtA[iNdEx:postIndex]...)
			if m.PubKey == nil {
				m.PubKey = []byte{}
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RelayerId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRelayer
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthRelayer
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthRelayer
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.RelayerId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipRelayer(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthRelayer
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SignResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowRelayer
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SignResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SignResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Payload", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRelayer
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthRelayer
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthRelayer
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Payload = append(m.Payload[:0], dAtA[iNdEx:postIndex]...)
			if m.Payload == nil {
				m.Payload = []byte{}
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Sign", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRelayer
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthRelayer
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthRelayer
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Sign = append(m.Sign[:0], dAtA[iNdEx:postIndex]...)
			if m.Sign == nil {
				m.Sign = []byte{}
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipRelayer(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthRelayer
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ChainHeight) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowRelayer
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ChainHeight: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ChainHeight: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Chain", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRelayer
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthRelayer
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthRelayer
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Chain = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field BlockNumber", wireType)
			}
			m.BlockNumber = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRelayer
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.BlockNumber |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipRelayer(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthRelayer
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ChainsHeight) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowRelayer
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ChainsHeight: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ChainsHeight: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RelayerId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRelayer
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthRelayer
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthRelayer
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.RelayerId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Chains", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRelayer
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthRelayer
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthRelayer
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Chains = append(m.Chains, &ChainHeight{})
			if err := m.Chains[len(m.Chains)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipRelayer(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthRelayer
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Block) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowRelayer
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Block: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Block: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field BlockNumber", wireType)
			}
			m.BlockNumber = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRelayer
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.BlockNumber |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Payload", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRelayer
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthRelayer
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthRelayer
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Payload = append(m.Payload, make([]byte, postIndex-iNdEx))
			copy(m.Payload[len(m.Payload)-1], dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipRelayer(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthRelayer
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CrossMsg) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowRelayer
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CrossMsg: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CrossMsg: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Type", wireType)
			}
			m.Type = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRelayer
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Type |= MsgType(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Payload", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRelayer
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthRelayer
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthRelayer
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Payload = append(m.Payload[:0], dAtA[iNdEx:postIndex]...)
			if m.Payload == nil {
				m.Payload = []byte{}
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipRelayer(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthRelayer
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Request) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowRelayer
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Request: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Request: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Type", wireType)
			}
			m.Type = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRelayer
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Type |= NetMsgType(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Payload", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRelayer
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthRelayer
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthRelayer
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Payload = append(m.Payload[:0], dAtA[iNdEx:postIndex]...)
			if m.Payload == nil {
				m.Payload = []byte{}
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipRelayer(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthRelayer
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Response) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowRelayer
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Response: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Response: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Status", wireType)
			}
			m.Status = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRelayer
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Status |= Status(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field StatusInfo", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRelayer
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthRelayer
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthRelayer
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.StatusInfo = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Payload", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRelayer
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthRelayer
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthRelayer
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Payload = append(m.Payload[:0], dAtA[iNdEx:postIndex]...)
			if m.Payload == nil {
				m.Payload = []byte{}
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipRelayer(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthRelayer
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *RegisterChain) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowRelayer
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: RegisterChain: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: RegisterChain: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRelayer
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthRelayer
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthRelayer
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Cas", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRelayer
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthRelayer
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthRelayer
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Cas == nil {
				m.Cas = &ChainCas{}
			}
			if err := m.Cas.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Height", wireType)
			}
			m.Height = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRelayer
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Height |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipRelayer(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthRelayer
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *RegisterChainRes) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowRelayer
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: RegisterChainRes: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: RegisterChainRes: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Status", wireType)
			}
			m.Status = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRelayer
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Status |= Status(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field StatusInfo", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRelayer
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthRelayer
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthRelayer
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.StatusInfo = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ChainAddr", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRelayer
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthRelayer
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthRelayer
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ChainAddr = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipRelayer(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthRelayer
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *RegisterContract) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowRelayer
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: RegisterContract: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: RegisterContract: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRelayer
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthRelayer
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthRelayer
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Chain", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRelayer
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthRelayer
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthRelayer
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Chain = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field VerifyRule", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRelayer
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthRelayer
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthRelayer
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.VerifyRule = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field InvokedList", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRelayer
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthRelayer
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthRelayer
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.InvokedList = append(m.InvokedList, &CrossContract{})
			if err := m.InvokedList[len(m.InvokedList)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipRelayer(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthRelayer
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *RegisterContractRes) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowRelayer
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: RegisterContractRes: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: RegisterContractRes: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Status", wireType)
			}
			m.Status = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRelayer
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Status |= Status(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field StatusInfo", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRelayer
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthRelayer
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthRelayer
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.StatusInfo = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipRelayer(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthRelayer
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SyncChainsReq) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowRelayer
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SyncChainsReq: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SyncChainsReq: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Chains", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRelayer
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthRelayer
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthRelayer
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Chains == nil {
				m.Chains = &RegisteredChains{}
			}
			if err := m.Chains.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipRelayer(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthRelayer
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *PreExecuteReq) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowRelayer
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: PreExecuteReq: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: PreExecuteReq: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field EventId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRelayer
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthRelayer
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthRelayer
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.EventId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field LaunchChainId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRelayer
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthRelayer
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthRelayer
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.LaunchChainId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field LaunchContract", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRelayer
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthRelayer
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthRelayer
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.LaunchContract = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Action", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRelayer
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthRelayer
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthRelayer
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Action == nil {
				m.Action = &SubAction{}
			}
			if err := m.Action.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipRelayer(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthRelayer
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *PreExecuteResult) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowRelayer
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: PreExecuteResult: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: PreExecuteResult: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field EventId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRelayer
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthRelayer
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthRelayer
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.EventId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ChainId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRelayer
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthRelayer
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthRelayer
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ChainId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Status", wireType)
			}
			m.Status = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRelayer
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Status |= Status(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field StatusInfo", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRelayer
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthRelayer
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthRelayer
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.StatusInfo = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipRelayer(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthRelayer
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CommitReq) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowRelayer
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CommitReq: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CommitReq: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field EventId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRelayer
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthRelayer
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthRelayer
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.EventId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ChainId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRelayer
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthRelayer
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthRelayer
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ChainId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipRelayer(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthRelayer
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CommitResult) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowRelayer
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CommitResult: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CommitResult: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field EventId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRelayer
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthRelayer
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthRelayer
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.EventId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ChainId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRelayer
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthRelayer
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthRelayer
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ChainId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Status", wireType)
			}
			m.Status = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRelayer
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Status |= Status(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field StatusInfo", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRelayer
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthRelayer
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthRelayer
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.StatusInfo = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipRelayer(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthRelayer
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *RollbackReq) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowRelayer
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: RollbackReq: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: RollbackReq: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field EventId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRelayer
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthRelayer
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthRelayer
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.EventId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ChainId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRelayer
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthRelayer
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthRelayer
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ChainId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipRelayer(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthRelayer
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *RollbackResult) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowRelayer
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: RollbackResult: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: RollbackResult: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field EventId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRelayer
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthRelayer
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthRelayer
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.EventId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ChainId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRelayer
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthRelayer
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthRelayer
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ChainId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Status", wireType)
			}
			m.Status = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRelayer
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Status |= Status(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field StatusInfo", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRelayer
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthRelayer
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthRelayer
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.StatusInfo = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipRelayer(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthRelayer
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *QueryChainsReq) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowRelayer
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: QueryChainsReq: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: QueryChainsReq: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RelayerId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRelayer
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthRelayer
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthRelayer
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.RelayerId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipRelayer(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthRelayer
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *QueryChainsRes) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowRelayer
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: QueryChainsRes: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: QueryChainsRes: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RegisteredChains", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRelayer
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthRelayer
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthRelayer
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.RegisteredChains = append(m.RegisteredChains, &ChainId{})
			if err := m.RegisteredChains[len(m.RegisteredChains)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipRelayer(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthRelayer
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *QueryContractsReq) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowRelayer
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: QueryContractsReq: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: QueryContractsReq: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Chain", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRelayer
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthRelayer
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthRelayer
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Chain = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipRelayer(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthRelayer
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *QueryContractsRes) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowRelayer
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: QueryContractsRes: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: QueryContractsRes: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RegisteredContracts", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRelayer
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthRelayer
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthRelayer
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.RegisteredContracts == nil {
				m.RegisteredContracts = &ChainContracts{}
			}
			if err := m.RegisteredContracts.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipRelayer(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthRelayer
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *QueryContractInfoReq) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowRelayer
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: QueryContractInfoReq: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: QueryContractInfoReq: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Chain", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRelayer
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthRelayer
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthRelayer
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Chain = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Contract", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRelayer
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthRelayer
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthRelayer
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Contract = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipRelayer(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthRelayer
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *QueryContractInfoRes) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowRelayer
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: QueryContractInfoRes: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: QueryContractInfoRes: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ContractInfo", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRelayer
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthRelayer
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthRelayer
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.ContractInfo == nil {
				m.ContractInfo = &ContractInfo{}
			}
			if err := m.ContractInfo.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipRelayer(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthRelayer
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *QueryCrossEventInfoReq) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowRelayer
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: QueryCrossEventInfoReq: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: QueryCrossEventInfoReq: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RelayerId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRelayer
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthRelayer
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthRelayer
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.RelayerId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field EventId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRelayer
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthRelayer
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthRelayer
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.EventId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipRelayer(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthRelayer
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *QueryCrossEventInfoRes) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowRelayer
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: QueryCrossEventInfoRes: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: QueryCrossEventInfoRes: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field EventId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRelayer
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthRelayer
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthRelayer
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.EventId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Launcher", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRelayer
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthRelayer
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthRelayer
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Launcher == nil {
				m.Launcher = &CrossContract{}
			}
			if err := m.Launcher.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Phase", wireType)
			}
			m.Phase = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRelayer
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Phase |= StatePhase(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Participants", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRelayer
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthRelayer
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthRelayer
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Participants = append(m.Participants, &CrossContract{})
			if err := m.Participants[len(m.Participants)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipRelayer(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthRelayer
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *TxIndex) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowRelayer
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: TxIndex: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: TxIndex: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field BlockNumber", wireType)
			}
			m.BlockNumber = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRelayer
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.BlockNumber |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TxNumber", wireType)
			}
			m.TxNumber = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRelayer
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TxNumber |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipRelayer(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthRelayer
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *TxMsg) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowRelayer
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: TxMsg: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: TxMsg: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field EventId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRelayer
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthRelayer
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthRelayer
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.EventId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Chain", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRelayer
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthRelayer
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthRelayer
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Chain = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Contract", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRelayer
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthRelayer
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthRelayer
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Contract = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Phase", wireType)
			}
			m.Phase = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRelayer
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Phase |= StatePhase(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Index", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRelayer
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthRelayer
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthRelayer
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Index == nil {
				m.Index = &TxIndex{}
			}
			if err := m.Index.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipRelayer(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthRelayer
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SdkRawMsg) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowRelayer
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SdkRawMsg: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SdkRawMsg: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Chain", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRelayer
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthRelayer
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthRelayer
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Chain = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field BlockNumber", wireType)
			}
			m.BlockNumber = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRelayer
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.BlockNumber |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ExecTxs", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRelayer
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthRelayer
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthRelayer
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ExecTxs = append(m.ExecTxs, &TxMsg{})
			if err := m.ExecTxs[len(m.ExecTxs)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field BlockResult", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRelayer
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthRelayer
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthRelayer
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.BlockResult = append(m.BlockResult[:0], dAtA[iNdEx:postIndex]...)
			if m.BlockResult == nil {
				m.BlockResult = []byte{}
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipRelayer(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthRelayer
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *BlockInfo) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowRelayer
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: BlockInfo: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: BlockInfo: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field BlockNumber", wireType)
			}
			m.BlockNumber = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRelayer
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.BlockNumber |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Chain", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRelayer
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthRelayer
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthRelayer
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Chain = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TxsPayload", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRelayer
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthRelayer
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthRelayer
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.TxsPayload = append(m.TxsPayload, make([]byte, postIndex-iNdEx))
			copy(m.TxsPayload[len(m.TxsPayload)-1], dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType == 0 {
				var v int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowRelayer
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.TxsValid = append(m.TxsValid, bool(v != 0))
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowRelayer
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthRelayer
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLengthRelayer
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				elementCount = packedLen
				if elementCount != 0 && len(m.TxsValid) == 0 {
					m.TxsValid = make([]bool, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v int
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowRelayer
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= int(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.TxsValid = append(m.TxsValid, bool(v != 0))
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field TxsValid", wireType)
			}
		default:
			iNdEx = preIndex
			skippy, err := skipRelayer(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthRelayer
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *InvokeChainInfo) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowRelayer
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: InvokeChainInfo: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: InvokeChainInfo: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ChainAddr", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRelayer
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthRelayer
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthRelayer
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ChainAddr = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Chain", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRelayer
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthRelayer
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthRelayer
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Chain = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Contract", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRelayer
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthRelayer
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthRelayer
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Contract = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Func", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRelayer
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthRelayer
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthRelayer
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Func = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Args", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRelayer
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthRelayer
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthRelayer
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Args = append(m.Args, make([]byte, postIndex-iNdEx))
			copy(m.Args[len(m.Args)-1], dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipRelayer(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthRelayer
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CrossInvoke) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowRelayer
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CrossInvoke: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CrossInvoke: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field EventId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRelayer
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthRelayer
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthRelayer
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.EventId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Initiator", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRelayer
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthRelayer
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthRelayer
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Initiator == nil {
				m.Initiator = &InvokeChainInfo{}
			}
			if err := m.Initiator.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Participants", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRelayer
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthRelayer
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthRelayer
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Participants = append(m.Participants, &InvokeChainInfo{})
			if err := m.Participants[len(m.Participants)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipRelayer(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthRelayer
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *RegContract) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowRelayer
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: RegContract: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: RegContract: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Contract", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRelayer
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthRelayer
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthRelayer
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Contract = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Func", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRelayer
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthRelayer
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthRelayer
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Func = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Phasefunc", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRelayer
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthRelayer
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthRelayer
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Phasefunc = append(m.Phasefunc, &PhaseFunc{})
			if err := m.Phasefunc[len(m.Phasefunc)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipRelayer(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthRelayer
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *WasmInvokeRes) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowRelayer
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: WasmInvokeRes: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: WasmInvokeRes: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Status", wireType)
			}
			m.Status = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRelayer
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Status |= Status(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field StatusInfo", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRelayer
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthRelayer
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthRelayer
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.StatusInfo = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Result", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRelayer
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthRelayer
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthRelayer
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Result = append(m.Result[:0], dAtA[iNdEx:postIndex]...)
			if m.Result == nil {
				m.Result = []byte{}
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipRelayer(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthRelayer
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Replay) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowRelayer
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Replay: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Replay: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipRelayer(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthRelayer
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipRelayer(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	depth := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowRelayer
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowRelayer
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
		case 1:
			iNdEx += 8
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowRelayer
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if length < 0 {
				return 0, ErrInvalidLengthRelayer
			}
			iNdEx += length
		case 3:
			depth++
		case 4:
			if depth == 0 {
				return 0, ErrUnexpectedEndOfGroupRelayer
			}
			depth--
		case 5:
			iNdEx += 4
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
		if iNdEx < 0 {
			return 0, ErrInvalidLengthRelayer
		}
		if depth == 0 {
			return iNdEx, nil
		}
	}
	return 0, io.ErrUnexpectedEOF
}

var (
	ErrInvalidLengthRelayer        = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowRelayer          = fmt.Errorf("proto: integer overflow")
	ErrUnexpectedEndOfGroupRelayer = fmt.Errorf("proto: unexpected end of group")
)
