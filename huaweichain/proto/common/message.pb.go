// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: common/message.proto

package common

import (
	fmt "fmt"
	_ "github.com/gogo/protobuf/gogoproto"
	proto "github.com/gogo/protobuf/proto"
	io "io"
	math "math"
	math_bits "math/bits"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.GoGoProtoPackageIsVersion3 // please upgrade the proto package

type Status int32

const (
	UNKNOWN                  Status = 0
	SUCCESS                  Status = 200
	HASH                     Status = 201
	BAD_REQUEST              Status = 400
	FORBIDDEN                Status = 403
	NOT_FOUND                Status = 404
	CONTRACT_NOT_READY       Status = 405
	CONTRACT_LAUNCHING       Status = 406
	CONTRACT_LAUNCH_ERR      Status = 407
	CONTRACT_RUNTIME_ERR     Status = 408
	VOTE_NOT_COMPLETE        Status = 409
	FREEZE                   Status = 410
	REQUEST_ENTITY_TOO_LARGE Status = 413
	INTERNAL_SERVER_ERROR    Status = 500
	NOT_IMPLEMENTED          Status = 501
	SERVICE_UNAVAILABLE      Status = 503
)

var Status_name = map[int32]string{
	0:   "UNKNOWN",
	200: "SUCCESS",
	201: "HASH",
	400: "BAD_REQUEST",
	403: "FORBIDDEN",
	404: "NOT_FOUND",
	405: "CONTRACT_NOT_READY",
	406: "CONTRACT_LAUNCHING",
	407: "CONTRACT_LAUNCH_ERR",
	408: "CONTRACT_RUNTIME_ERR",
	409: "VOTE_NOT_COMPLETE",
	410: "FREEZE",
	413: "REQUEST_ENTITY_TOO_LARGE",
	500: "INTERNAL_SERVER_ERROR",
	501: "NOT_IMPLEMENTED",
	503: "SERVICE_UNAVAILABLE",
}

var Status_value = map[string]int32{
	"UNKNOWN":                  0,
	"SUCCESS":                  200,
	"HASH":                     201,
	"BAD_REQUEST":              400,
	"FORBIDDEN":                403,
	"NOT_FOUND":                404,
	"CONTRACT_NOT_READY":       405,
	"CONTRACT_LAUNCHING":       406,
	"CONTRACT_LAUNCH_ERR":      407,
	"CONTRACT_RUNTIME_ERR":     408,
	"VOTE_NOT_COMPLETE":        409,
	"FREEZE":                   410,
	"REQUEST_ENTITY_TOO_LARGE": 413,
	"INTERNAL_SERVER_ERROR":    500,
	"NOT_IMPLEMENTED":          501,
	"SERVICE_UNAVAILABLE":      503,
}

func (x Status) String() string {
	return proto.EnumName(Status_name, int32(x))
}

func (Status) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_8de410db4f60bbbc, []int{0}
}

type RawMessage_Type int32

const (
	DIRECT RawMessage_Type = 0
	PROXY  RawMessage_Type = 1
)

var RawMessage_Type_name = map[int32]string{
	0: "DIRECT",
	1: "PROXY",
}

var RawMessage_Type_value = map[string]int32{
	"DIRECT": 0,
	"PROXY":  1,
}

func (x RawMessage_Type) String() string {
	return proto.EnumName(RawMessage_Type_name, int32(x))
}

func (RawMessage_Type) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_8de410db4f60bbbc, []int{0, 0}
}

// RawMessage is the message that delivers through grpc service.
// If RawMessage is a request message, the payload is the info
// for the request, i.e. CreateInfo.  If RawMessge is a response
// message, in most cases the payload is Response defined below,
// but it can be any other struct based on actual requirement.
type RawMessage struct {
	Signature *RawMessage_Signature `protobuf:"bytes,1,opt,name=signature,proto3" json:"signature,omitempty"`
	Payload   []byte                `protobuf:"bytes,2,opt,name=payload,proto3" json:"payload,omitempty"`
	Type      RawMessage_Type       `protobuf:"varint,3,opt,name=type,proto3,enum=common.RawMessage_Type" json:"type,omitempty"`
	//
	// proxy message attachment information,
	// common.EndorseTarget when invoking contract,
	// common.ProposeTarget when sending transcation
	ProxyInfo       []byte `protobuf:"bytes,4,opt,name=proxy_info,json=proxyInfo,proto3" json:"proxy_info,omitempty"`
	PlatformVersion string `protobuf:"bytes,5,opt,name=platform_version,json=platformVersion,proto3" json:"platform_version,omitempty"`
}

func (m *RawMessage) Reset()         { *m = RawMessage{} }
func (m *RawMessage) String() string { return proto.CompactTextString(m) }
func (*RawMessage) ProtoMessage()    {}
func (*RawMessage) Descriptor() ([]byte, []int) {
	return fileDescriptor_8de410db4f60bbbc, []int{0}
}
func (m *RawMessage) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *RawMessage) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_RawMessage.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *RawMessage) XXX_Merge(src proto.Message) {
	xxx_messageInfo_RawMessage.Merge(m, src)
}
func (m *RawMessage) XXX_Size() int {
	return m.Size()
}
func (m *RawMessage) XXX_DiscardUnknown() {
	xxx_messageInfo_RawMessage.DiscardUnknown(m)
}

var xxx_messageInfo_RawMessage proto.InternalMessageInfo

type RawMessage_Signature struct {
	Cert []byte `protobuf:"bytes,1,opt,name=cert,proto3" json:"cert,omitempty"`
	Sign []byte `protobuf:"bytes,2,opt,name=sign,proto3" json:"sign,omitempty"`
}

func (m *RawMessage_Signature) Reset()         { *m = RawMessage_Signature{} }
func (m *RawMessage_Signature) String() string { return proto.CompactTextString(m) }
func (*RawMessage_Signature) ProtoMessage()    {}
func (*RawMessage_Signature) Descriptor() ([]byte, []int) {
	return fileDescriptor_8de410db4f60bbbc, []int{0, 0}
}
func (m *RawMessage_Signature) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *RawMessage_Signature) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_RawMessage_Signature.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *RawMessage_Signature) XXX_Merge(src proto.Message) {
	xxx_messageInfo_RawMessage_Signature.Merge(m, src)
}
func (m *RawMessage_Signature) XXX_Size() int {
	return m.Size()
}
func (m *RawMessage_Signature) XXX_DiscardUnknown() {
	xxx_messageInfo_RawMessage_Signature.DiscardUnknown(m)
}

var xxx_messageInfo_RawMessage_Signature proto.InternalMessageInfo

type Response struct {
	Status     Status `protobuf:"varint,1,opt,name=status,proto3,enum=common.Status" json:"status,omitempty"`
	StatusInfo string `protobuf:"bytes,2,opt,name=status_info,json=statusInfo,proto3" json:"status_info,omitempty"`
	Payload    []byte `protobuf:"bytes,3,opt,name=payload,proto3" json:"payload,omitempty"`
}

func (m *Response) Reset()         { *m = Response{} }
func (m *Response) String() string { return proto.CompactTextString(m) }
func (*Response) ProtoMessage()    {}
func (*Response) Descriptor() ([]byte, []int) {
	return fileDescriptor_8de410db4f60bbbc, []int{1}
}
func (m *Response) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Response) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Response.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Response) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Response.Merge(m, src)
}
func (m *Response) XXX_Size() int {
	return m.Size()
}
func (m *Response) XXX_DiscardUnknown() {
	xxx_messageInfo_Response.DiscardUnknown(m)
}

var xxx_messageInfo_Response proto.InternalMessageInfo

type StatusResponse struct {
	Status     Status `protobuf:"varint,1,opt,name=status,proto3,enum=common.Status" json:"status,omitempty"`
	StatusInfo string `protobuf:"bytes,2,opt,name=status_info,json=statusInfo,proto3" json:"status_info,omitempty"`
}

func (m *StatusResponse) Reset()         { *m = StatusResponse{} }
func (m *StatusResponse) String() string { return proto.CompactTextString(m) }
func (*StatusResponse) ProtoMessage()    {}
func (*StatusResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_8de410db4f60bbbc, []int{2}
}
func (m *StatusResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *StatusResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_StatusResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *StatusResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_StatusResponse.Merge(m, src)
}
func (m *StatusResponse) XXX_Size() int {
	return m.Size()
}
func (m *StatusResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_StatusResponse.DiscardUnknown(m)
}

var xxx_messageInfo_StatusResponse proto.InternalMessageInfo

func init() {
	proto.RegisterEnum("common.Status", Status_name, Status_value)
	proto.RegisterEnum("common.RawMessage_Type", RawMessage_Type_name, RawMessage_Type_value)
	proto.RegisterType((*RawMessage)(nil), "common.RawMessage")
	proto.RegisterType((*RawMessage_Signature)(nil), "common.RawMessage.Signature")
	proto.RegisterType((*Response)(nil), "common.Response")
	proto.RegisterType((*StatusResponse)(nil), "common.StatusResponse")
}

func init() { proto.RegisterFile("common/message.proto", fileDescriptor_8de410db4f60bbbc) }

var fileDescriptor_8de410db4f60bbbc = []byte{
	// 669 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xac, 0x53, 0xcb, 0x6e, 0xdb, 0x46,
	0x14, 0x15, 0x45, 0x59, 0xae, 0xae, 0x0c, 0x79, 0x3a, 0x55, 0x6b, 0xd6, 0xa8, 0x59, 0x41, 0x05,
	0x0a, 0xb5, 0x05, 0x24, 0xc0, 0x46, 0x37, 0xd9, 0x51, 0xd4, 0xd8, 0x26, 0x22, 0x0d, 0x9d, 0x21,
	0xa5, 0x44, 0xde, 0x10, 0x8c, 0x42, 0xcb, 0x04, 0x2c, 0x0e, 0x41, 0xd2, 0x71, 0x04, 0xe4, 0x23,
	0x0c, 0xe4, 0x1d, 0x20, 0x9f, 0x90, 0xff, 0x70, 0x76, 0xde, 0x25, 0xcb, 0xd8, 0xfe, 0x85, 0x04,
	0xd9, 0x06, 0x1c, 0x4a, 0x7e, 0x04, 0x59, 0x66, 0x77, 0xef, 0x39, 0xe7, 0x9e, 0x39, 0x77, 0xc8,
	0x81, 0xea, 0x88, 0x4f, 0x26, 0x3c, 0x68, 0x4d, 0xbc, 0x38, 0x76, 0xc7, 0x5e, 0x33, 0x8c, 0x78,
	0xc2, 0x71, 0x31, 0x43, 0x57, 0xab, 0x63, 0x3e, 0xe6, 0x02, 0x6a, 0xa5, 0x55, 0xc6, 0xd6, 0xdf,
	0xe6, 0x01, 0x98, 0x7b, 0xd4, 0xcb, 0x46, 0xf0, 0x2d, 0x28, 0xc5, 0xfe, 0x38, 0x70, 0x93, 0xc3,
	0xc8, 0x53, 0xa4, 0x9a, 0xd4, 0x28, 0xaf, 0xff, 0xd1, 0xcc, 0x0c, 0x9a, 0x57, 0xb2, 0xa6, 0x35,
	0xd7, 0xb0, 0x2b, 0x39, 0x56, 0x60, 0x31, 0x74, 0xa7, 0x07, 0xdc, 0x7d, 0xa0, 0xe4, 0x6b, 0x52,
	0x63, 0x89, 0xcd, 0x5b, 0xfc, 0x1f, 0x14, 0x92, 0x69, 0xe8, 0x29, 0x72, 0x4d, 0x6a, 0x54, 0xd6,
	0x57, 0xbe, 0x63, 0x68, 0x4f, 0x43, 0x8f, 0x09, 0x11, 0x5e, 0x03, 0x08, 0x23, 0xfe, 0x68, 0xea,
	0xf8, 0xc1, 0x1e, 0x57, 0x0a, 0xc2, 0xa9, 0x24, 0x10, 0x23, 0xd8, 0xe3, 0xf8, 0x1f, 0x40, 0xe1,
	0x81, 0x9b, 0xec, 0xf1, 0x68, 0xe2, 0x3c, 0xf4, 0xa2, 0xd8, 0xe7, 0x81, 0xb2, 0x50, 0x93, 0x1a,
	0x25, 0xb6, 0x3c, 0xc7, 0x07, 0x19, 0xbc, 0xba, 0x01, 0xa5, 0xcb, 0xa0, 0x18, 0x43, 0x61, 0xe4,
	0x45, 0x89, 0x58, 0x6a, 0x89, 0x89, 0x3a, 0xc5, 0xd2, 0xf8, 0xb3, 0xb8, 0xa2, 0xae, 0xaf, 0x41,
	0x21, 0x0d, 0x83, 0x01, 0x8a, 0x1d, 0x83, 0x11, 0xdd, 0x46, 0x39, 0x5c, 0x82, 0x85, 0x1d, 0x66,
	0xde, 0x1b, 0x22, 0xa9, 0x3e, 0x81, 0x9f, 0x98, 0x17, 0x87, 0x3c, 0x88, 0x3d, 0xfc, 0x37, 0x14,
	0xe3, 0xc4, 0x4d, 0x0e, 0x63, 0x61, 0x5a, 0x59, 0xaf, 0xcc, 0x17, 0xb3, 0x04, 0xca, 0x66, 0x2c,
	0xfe, 0x13, 0xca, 0x59, 0x95, 0xad, 0x94, 0x17, 0x69, 0x21, 0x83, 0xc4, 0x4e, 0xd7, 0x6e, 0x4e,
	0xbe, 0x71, 0x73, 0xf5, 0x21, 0x54, 0x66, 0x66, 0x3f, 0xfa, 0xd0, 0x7f, 0xdf, 0xe7, 0xa1, 0x98,
	0xcd, 0xe0, 0x32, 0x2c, 0xf6, 0xe9, 0x6d, 0x6a, 0xde, 0xa5, 0x28, 0x87, 0x97, 0x60, 0xd1, 0xea,
	0xeb, 0x3a, 0xb1, 0x2c, 0x74, 0x22, 0xe1, 0x12, 0x14, 0xb6, 0x35, 0x6b, 0x1b, 0xbd, 0x93, 0x30,
	0x82, 0x72, 0x5b, 0xeb, 0x38, 0x8c, 0xdc, 0xe9, 0x13, 0xcb, 0x46, 0xc7, 0x32, 0xae, 0x40, 0x69,
	0xd3, 0x64, 0x6d, 0xa3, 0xd3, 0x21, 0x14, 0x3d, 0x11, 0x3d, 0x35, 0x6d, 0x67, 0xd3, 0xec, 0xd3,
	0x0e, 0x7a, 0x2a, 0xe3, 0x15, 0xc0, 0xba, 0x49, 0x6d, 0xa6, 0xe9, 0xb6, 0x93, 0x12, 0x8c, 0x68,
	0x9d, 0x21, 0x7a, 0x76, 0x93, 0xe8, 0x6a, 0x7d, 0xaa, 0x6f, 0x1b, 0x74, 0x0b, 0x3d, 0x97, 0xb1,
	0x02, 0xbf, 0x7c, 0x43, 0x38, 0x84, 0x31, 0xf4, 0x42, 0xc6, 0xbf, 0x43, 0xf5, 0x92, 0x61, 0x7d,
	0x6a, 0x1b, 0x3d, 0x22, 0xa8, 0x97, 0x32, 0xfe, 0x0d, 0x7e, 0x1e, 0x98, 0x36, 0x11, 0x47, 0xe8,
	0x66, 0x6f, 0xa7, 0x4b, 0x6c, 0x82, 0x5e, 0xc9, 0xb8, 0x0c, 0xc5, 0x4d, 0x46, 0xc8, 0x2e, 0x41,
	0xaf, 0x65, 0xbc, 0x06, 0xca, 0x2c, 0xb9, 0x43, 0xa8, 0x6d, 0xd8, 0x43, 0xc7, 0x36, 0x4d, 0xa7,
	0xab, 0xb1, 0x2d, 0x82, 0xde, 0xc8, 0x78, 0x15, 0x7e, 0x35, 0xa8, 0x4d, 0x18, 0xd5, 0xba, 0x8e,
	0x45, 0xd8, 0x80, 0xb0, 0xd4, 0xdd, 0x64, 0xe8, 0x93, 0x8c, 0xab, 0xb0, 0x9c, 0x5a, 0x1b, 0xa9,
	0x73, 0x8f, 0x50, 0x9b, 0x74, 0xd0, 0x67, 0x11, 0x35, 0x15, 0x1a, 0x3a, 0x71, 0xfa, 0x54, 0x1b,
	0x68, 0x46, 0x57, 0x6b, 0x77, 0x09, 0xfa, 0x22, 0xb7, 0x1f, 0x9f, 0x9c, 0xa9, 0xb9, 0xd3, 0x33,
	0x35, 0x77, 0x72, 0xae, 0x4a, 0xa7, 0xe7, 0xaa, 0xf4, 0xf1, 0x5c, 0x95, 0x8e, 0x2f, 0xd4, 0xdc,
	0xe9, 0x85, 0x9a, 0xfb, 0x70, 0xa1, 0xe6, 0xe0, 0xaf, 0x11, 0x9f, 0x34, 0xf7, 0x0f, 0xdd, 0x23,
	0xcf, 0x6f, 0x1e, 0xf9, 0x5e, 0xe0, 0x45, 0xa3, 0x7d, 0xd7, 0x0f, 0xb2, 0x37, 0x39, 0xfb, 0xa0,
	0xbb, 0xff, 0x8f, 0xfd, 0x64, 0x2e, 0x1a, 0xf1, 0x49, 0x2b, 0xe4, 0x7e, 0x1c, 0xa7, 0xff, 0x80,
	0x1b, 0x8d, 0xf6, 0x5b, 0xd7, 0xc6, 0x5a, 0xd9, 0xab, 0xce, 0xc6, 0xee, 0x17, 0x45, 0xb7, 0xf1,
	0x35, 0x00, 0x00, 0xff, 0xff, 0x46, 0xa9, 0xc3, 0x14, 0x0e, 0x04, 0x00, 0x00,
}

func (m *RawMessage) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *RawMessage) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *RawMessage) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.PlatformVersion) > 0 {
		i -= len(m.PlatformVersion)
		copy(dAtA[i:], m.PlatformVersion)
		i = encodeVarintMessage(dAtA, i, uint64(len(m.PlatformVersion)))
		i--
		dAtA[i] = 0x2a
	}
	if len(m.ProxyInfo) > 0 {
		i -= len(m.ProxyInfo)
		copy(dAtA[i:], m.ProxyInfo)
		i = encodeVarintMessage(dAtA, i, uint64(len(m.ProxyInfo)))
		i--
		dAtA[i] = 0x22
	}
	if m.Type != 0 {
		i = encodeVarintMessage(dAtA, i, uint64(m.Type))
		i--
		dAtA[i] = 0x18
	}
	if len(m.Payload) > 0 {
		i -= len(m.Payload)
		copy(dAtA[i:], m.Payload)
		i = encodeVarintMessage(dAtA, i, uint64(len(m.Payload)))
		i--
		dAtA[i] = 0x12
	}
	if m.Signature != nil {
		{
			size, err := m.Signature.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintMessage(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *RawMessage_Signature) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *RawMessage_Signature) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *RawMessage_Signature) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Sign) > 0 {
		i -= len(m.Sign)
		copy(dAtA[i:], m.Sign)
		i = encodeVarintMessage(dAtA, i, uint64(len(m.Sign)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Cert) > 0 {
		i -= len(m.Cert)
		copy(dAtA[i:], m.Cert)
		i = encodeVarintMessage(dAtA, i, uint64(len(m.Cert)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *Response) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Response) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Response) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Payload) > 0 {
		i -= len(m.Payload)
		copy(dAtA[i:], m.Payload)
		i = encodeVarintMessage(dAtA, i, uint64(len(m.Payload)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.StatusInfo) > 0 {
		i -= len(m.StatusInfo)
		copy(dAtA[i:], m.StatusInfo)
		i = encodeVarintMessage(dAtA, i, uint64(len(m.StatusInfo)))
		i--
		dAtA[i] = 0x12
	}
	if m.Status != 0 {
		i = encodeVarintMessage(dAtA, i, uint64(m.Status))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *StatusResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *StatusResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *StatusResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.StatusInfo) > 0 {
		i -= len(m.StatusInfo)
		copy(dAtA[i:], m.StatusInfo)
		i = encodeVarintMessage(dAtA, i, uint64(len(m.StatusInfo)))
		i--
		dAtA[i] = 0x12
	}
	if m.Status != 0 {
		i = encodeVarintMessage(dAtA, i, uint64(m.Status))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func encodeVarintMessage(dAtA []byte, offset int, v uint64) int {
	offset -= sovMessage(v)
	base := offset
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return base
}
func (m *RawMessage) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Signature != nil {
		l = m.Signature.Size()
		n += 1 + l + sovMessage(uint64(l))
	}
	l = len(m.Payload)
	if l > 0 {
		n += 1 + l + sovMessage(uint64(l))
	}
	if m.Type != 0 {
		n += 1 + sovMessage(uint64(m.Type))
	}
	l = len(m.ProxyInfo)
	if l > 0 {
		n += 1 + l + sovMessage(uint64(l))
	}
	l = len(m.PlatformVersion)
	if l > 0 {
		n += 1 + l + sovMessage(uint64(l))
	}
	return n
}

func (m *RawMessage_Signature) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Cert)
	if l > 0 {
		n += 1 + l + sovMessage(uint64(l))
	}
	l = len(m.Sign)
	if l > 0 {
		n += 1 + l + sovMessage(uint64(l))
	}
	return n
}

func (m *Response) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Status != 0 {
		n += 1 + sovMessage(uint64(m.Status))
	}
	l = len(m.StatusInfo)
	if l > 0 {
		n += 1 + l + sovMessage(uint64(l))
	}
	l = len(m.Payload)
	if l > 0 {
		n += 1 + l + sovMessage(uint64(l))
	}
	return n
}

func (m *StatusResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Status != 0 {
		n += 1 + sovMessage(uint64(m.Status))
	}
	l = len(m.StatusInfo)
	if l > 0 {
		n += 1 + l + sovMessage(uint64(l))
	}
	return n
}

func sovMessage(x uint64) (n int) {
	return (math_bits.Len64(x|1) + 6) / 7
}
func sozMessage(x uint64) (n int) {
	return sovMessage(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (m *RawMessage) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMessage
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: RawMessage: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: RawMessage: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Signature", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessage
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthMessage
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthMessage
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Signature == nil {
				m.Signature = &RawMessage_Signature{}
			}
			if err := m.Signature.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Payload", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessage
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthMessage
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthMessage
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Payload = append(m.Payload[:0], dAtA[iNdEx:postIndex]...)
			if m.Payload == nil {
				m.Payload = []byte{}
			}
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Type", wireType)
			}
			m.Type = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessage
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Type |= RawMessage_Type(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ProxyInfo", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessage
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthMessage
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthMessage
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ProxyInfo = append(m.ProxyInfo[:0], dAtA[iNdEx:postIndex]...)
			if m.ProxyInfo == nil {
				m.ProxyInfo = []byte{}
			}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PlatformVersion", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessage
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMessage
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthMessage
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.PlatformVersion = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipMessage(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthMessage
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *RawMessage_Signature) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMessage
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Signature: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Signature: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Cert", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessage
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthMessage
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthMessage
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Cert = append(m.Cert[:0], dAtA[iNdEx:postIndex]...)
			if m.Cert == nil {
				m.Cert = []byte{}
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Sign", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessage
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthMessage
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthMessage
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Sign = append(m.Sign[:0], dAtA[iNdEx:postIndex]...)
			if m.Sign == nil {
				m.Sign = []byte{}
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipMessage(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthMessage
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Response) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMessage
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Response: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Response: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Status", wireType)
			}
			m.Status = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessage
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Status |= Status(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field StatusInfo", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessage
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMessage
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthMessage
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.StatusInfo = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Payload", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessage
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthMessage
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthMessage
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Payload = append(m.Payload[:0], dAtA[iNdEx:postIndex]...)
			if m.Payload == nil {
				m.Payload = []byte{}
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipMessage(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthMessage
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *StatusResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowMessage
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: StatusResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: StatusResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Status", wireType)
			}
			m.Status = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessage
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Status |= Status(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field StatusInfo", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowMessage
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthMessage
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthMessage
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.StatusInfo = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipMessage(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthMessage
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipMessage(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	depth := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowMessage
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowMessage
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
		case 1:
			iNdEx += 8
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowMessage
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if length < 0 {
				return 0, ErrInvalidLengthMessage
			}
			iNdEx += length
		case 3:
			depth++
		case 4:
			if depth == 0 {
				return 0, ErrUnexpectedEndOfGroupMessage
			}
			depth--
		case 5:
			iNdEx += 4
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
		if iNdEx < 0 {
			return 0, ErrInvalidLengthMessage
		}
		if depth == 0 {
			return iNdEx, nil
		}
	}
	return 0, io.ErrUnexpectedEOF
}

var (
	ErrInvalidLengthMessage        = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowMessage          = fmt.Errorf("proto: integer overflow")
	ErrUnexpectedEndOfGroupMessage = fmt.Errorf("proto: unexpected end of group")
)
