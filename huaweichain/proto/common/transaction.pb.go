// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: common/transaction.proto

package common

import (
	fmt "fmt"
	_ "github.com/gogo/protobuf/gogoproto"
	proto "github.com/gogo/protobuf/proto"
	io "io"
	math "math"
	math_bits "math/bits"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.GoGoProtoPackageIsVersion3 // please upgrade the proto package

type TxType int32

const (
	COMMON_TRANSACTION TxType = 0
	VOTE_TRANSACTION   TxType = 1
)

var TxType_name = map[int32]string{
	0: "COMMON_TRANSACTION",
	1: "VOTE_TRANSACTION",
}

var TxType_value = map[string]int32{
	"COMMON_TRANSACTION": 0,
	"VOTE_TRANSACTION":   1,
}

func (x TxType) String() string {
	return proto.EnumName(TxType_name, int32(x))
}

func (TxType) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_f6296da495f91d72, []int{0}
}

type CertStatus int32

const (
	CERT_NORMAL     CertStatus = 0
	CERT_REVOCATION CertStatus = 1
	CERT_FREEZE     CertStatus = 2
)

var CertStatus_name = map[int32]string{
	0: "CERT_NORMAL",
	1: "CERT_REVOCATION",
	2: "CERT_FREEZE",
}

var CertStatus_value = map[string]int32{
	"CERT_NORMAL":     0,
	"CERT_REVOCATION": 1,
	"CERT_FREEZE":     2,
}

func (x CertStatus) String() string {
	return proto.EnumName(CertStatus_name, int32(x))
}

func (CertStatus) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_f6296da495f91d72, []int{1}
}

type ContractRunEnv int32

const (
	Docker     ContractRunEnv = 0
	Native     ContractRunEnv = 1
	NativeWasm ContractRunEnv = 2
	TEEWasm    ContractRunEnv = 3
)

var ContractRunEnv_name = map[int32]string{
	0: "Docker",
	1: "Native",
	2: "NativeWasm",
	3: "TEEWasm",
}

var ContractRunEnv_value = map[string]int32{
	"Docker":     0,
	"Native":     1,
	"NativeWasm": 2,
	"TEEWasm":    3,
}

func (x ContractRunEnv) String() string {
	return proto.EnumName(ContractRunEnv_name, int32(x))
}

func (ContractRunEnv) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_f6296da495f91d72, []int{2}
}

type TxStatus int32

const (
	VALID                        TxStatus = 0
	INVALID_TX_PAYLOAD           TxStatus = 1
	INVALID_TX_HEADER            TxStatus = 2
	INVALID_TX_TYPE              TxStatus = 3
	UNKNOWN_TX_TYPE              TxStatus = 4
	DUPLICATE_TX                 TxStatus = 5
	INVALID_STATE_UPDATES_TYPE   TxStatus = 6
	INVALID_INSERT_STATEMENTS    TxStatus = 7
	INVALID_SELECT_STATEMENTS    TxStatus = 8
	INVALID_SQL_SYNTAX           TxStatus = 9
	INVALID_SQL_SCHEMA           TxStatus = 10
	INVALID_COMMON_TX_DATA       TxStatus = 11
	INVALID_VOTE_TX_DATA         TxStatus = 12
	INVALID_CHAIN_CONFIG         TxStatus = 13
	INVALID_ARCHIVE_TX_DATA      TxStatus = 14
	INVALID_CONTRACT_INVOCATION  TxStatus = 21
	INVALID_APPROVAL_SIGNATURE   TxStatus = 22
	APPROVALS_VALIDATION_FAILURE TxStatus = 23
	UNKNOWN_VOTE_HANDLER         TxStatus = 31
	INVALID_VOTE_PAYLOAD         TxStatus = 32
	INVALID_MVCC                 TxStatus = 41
	CONTRACT_ALREADY_INIT        TxStatus = 42
	CONTRACT_NOT_INIT            TxStatus = 43
	INVALID_LATEST_BLOCK         TxStatus = 44
	INVALID                      TxStatus = 255
)

var TxStatus_name = map[int32]string{
	0:   "VALID",
	1:   "INVALID_TX_PAYLOAD",
	2:   "INVALID_TX_HEADER",
	3:   "INVALID_TX_TYPE",
	4:   "UNKNOWN_TX_TYPE",
	5:   "DUPLICATE_TX",
	6:   "INVALID_STATE_UPDATES_TYPE",
	7:   "INVALID_INSERT_STATEMENTS",
	8:   "INVALID_SELECT_STATEMENTS",
	9:   "INVALID_SQL_SYNTAX",
	10:  "INVALID_SQL_SCHEMA",
	11:  "INVALID_COMMON_TX_DATA",
	12:  "INVALID_VOTE_TX_DATA",
	13:  "INVALID_CHAIN_CONFIG",
	14:  "INVALID_ARCHIVE_TX_DATA",
	21:  "INVALID_CONTRACT_INVOCATION",
	22:  "INVALID_APPROVAL_SIGNATURE",
	23:  "APPROVALS_VALIDATION_FAILURE",
	31:  "UNKNOWN_VOTE_HANDLER",
	32:  "INVALID_VOTE_PAYLOAD",
	41:  "INVALID_MVCC",
	42:  "CONTRACT_ALREADY_INIT",
	43:  "CONTRACT_NOT_INIT",
	44:  "INVALID_LATEST_BLOCK",
	255: "INVALID",
}

var TxStatus_value = map[string]int32{
	"VALID":                        0,
	"INVALID_TX_PAYLOAD":           1,
	"INVALID_TX_HEADER":            2,
	"INVALID_TX_TYPE":              3,
	"UNKNOWN_TX_TYPE":              4,
	"DUPLICATE_TX":                 5,
	"INVALID_STATE_UPDATES_TYPE":   6,
	"INVALID_INSERT_STATEMENTS":    7,
	"INVALID_SELECT_STATEMENTS":    8,
	"INVALID_SQL_SYNTAX":           9,
	"INVALID_SQL_SCHEMA":           10,
	"INVALID_COMMON_TX_DATA":       11,
	"INVALID_VOTE_TX_DATA":         12,
	"INVALID_CHAIN_CONFIG":         13,
	"INVALID_ARCHIVE_TX_DATA":      14,
	"INVALID_CONTRACT_INVOCATION":  21,
	"INVALID_APPROVAL_SIGNATURE":   22,
	"APPROVALS_VALIDATION_FAILURE": 23,
	"UNKNOWN_VOTE_HANDLER":         31,
	"INVALID_VOTE_PAYLOAD":         32,
	"INVALID_MVCC":                 41,
	"CONTRACT_ALREADY_INIT":        42,
	"CONTRACT_NOT_INIT":            43,
	"INVALID_LATEST_BLOCK":         44,
	"INVALID":                      255,
}

func (x TxStatus) String() string {
	return proto.EnumName(TxStatus_name, int32(x))
}

func (TxStatus) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_f6296da495f91d72, []int{3}
}

type Identity_Type int32

const (
	COMMON_NAME Identity_Type = 0
	CERT        Identity_Type = 1
)

var Identity_Type_name = map[int32]string{
	0: "COMMON_NAME",
	1: "CERT",
}

var Identity_Type_value = map[string]int32{
	"COMMON_NAME": 0,
	"CERT":        1,
}

func (x Identity_Type) String() string {
	return proto.EnumName(Identity_Type_name, int32(x))
}

func (Identity_Type) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_f6296da495f91d72, []int{0, 0}
}

type Identity struct {
	Org  string        `protobuf:"bytes,1,opt,name=org,proto3" json:"org,omitempty"`
	Type Identity_Type `protobuf:"varint,2,opt,name=type,proto3,enum=common.Identity_Type" json:"type,omitempty"`
	Id   []byte        `protobuf:"bytes,3,opt,name=id,proto3" json:"id,omitempty"`
}

func (m *Identity) Reset()         { *m = Identity{} }
func (m *Identity) String() string { return proto.CompactTextString(m) }
func (*Identity) ProtoMessage()    {}
func (*Identity) Descriptor() ([]byte, []int) {
	return fileDescriptor_f6296da495f91d72, []int{0}
}
func (m *Identity) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Identity) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Identity.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Identity) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Identity.Merge(m, src)
}
func (m *Identity) XXX_Size() int {
	return m.Size()
}
func (m *Identity) XXX_DiscardUnknown() {
	xxx_messageInfo_Identity.DiscardUnknown(m)
}

var xxx_messageInfo_Identity proto.InternalMessageInfo

type TxHeader struct {
	Type        TxType    `protobuf:"varint,1,opt,name=type,proto3,enum=common.TxType" json:"type,omitempty"`
	ChainId     string    `protobuf:"bytes,2,opt,name=chain_id,json=chainId,proto3" json:"chain_id,omitempty"`
	Creator     *Identity `protobuf:"bytes,3,opt,name=creator,proto3" json:"creator,omitempty"`
	Timestamp   uint64    `protobuf:"varint,4,opt,name=timestamp,proto3" json:"timestamp,omitempty"`
	Nonce       uint64    `protobuf:"varint,5,opt,name=nonce,proto3" json:"nonce,omitempty"`
	LatestBlock uint64    `protobuf:"varint,6,opt,name=latest_block,json=latestBlock,proto3" json:"latest_block,omitempty"`
	Domains     []string  `protobuf:"bytes,7,rep,name=domains,proto3" json:"domains,omitempty"`
	Version     string    `protobuf:"bytes,8,opt,name=version,proto3" json:"version,omitempty"`
}

func (m *TxHeader) Reset()         { *m = TxHeader{} }
func (m *TxHeader) String() string { return proto.CompactTextString(m) }
func (*TxHeader) ProtoMessage()    {}
func (*TxHeader) Descriptor() ([]byte, []int) {
	return fileDescriptor_f6296da495f91d72, []int{1}
}
func (m *TxHeader) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *TxHeader) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_TxHeader.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *TxHeader) XXX_Merge(src proto.Message) {
	xxx_messageInfo_TxHeader.Merge(m, src)
}
func (m *TxHeader) XXX_Size() int {
	return m.Size()
}
func (m *TxHeader) XXX_DiscardUnknown() {
	xxx_messageInfo_TxHeader.DiscardUnknown(m)
}

var xxx_messageInfo_TxHeader proto.InternalMessageInfo

type Transaction struct {
	Payload    []byte            `protobuf:"bytes,1,opt,name=payload,proto3" json:"payload,omitempty"`
	Approvals  []*Approval       `protobuf:"bytes,2,rep,name=approvals,proto3" json:"approvals,omitempty"`
	Extensions map[string][]byte `protobuf:"bytes,3,rep,name=extensions,proto3" json:"extensions,omitempty" protobuf_key:"bytes,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value,proto3"`
}

func (m *Transaction) Reset()         { *m = Transaction{} }
func (m *Transaction) String() string { return proto.CompactTextString(m) }
func (*Transaction) ProtoMessage()    {}
func (*Transaction) Descriptor() ([]byte, []int) {
	return fileDescriptor_f6296da495f91d72, []int{2}
}
func (m *Transaction) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Transaction) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Transaction.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Transaction) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Transaction.Merge(m, src)
}
func (m *Transaction) XXX_Size() int {
	return m.Size()
}
func (m *Transaction) XXX_DiscardUnknown() {
	xxx_messageInfo_Transaction.DiscardUnknown(m)
}

var xxx_messageInfo_Transaction proto.InternalMessageInfo

type TxPayload struct {
	Header *TxHeader `protobuf:"bytes,1,opt,name=header,proto3" json:"header,omitempty"`
	Data   []byte    `protobuf:"bytes,2,opt,name=data,proto3" json:"data,omitempty"`
}

func (m *TxPayload) Reset()         { *m = TxPayload{} }
func (m *TxPayload) String() string { return proto.CompactTextString(m) }
func (*TxPayload) ProtoMessage()    {}
func (*TxPayload) Descriptor() ([]byte, []int) {
	return fileDescriptor_f6296da495f91d72, []int{3}
}
func (m *TxPayload) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *TxPayload) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_TxPayload.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *TxPayload) XXX_Merge(src proto.Message) {
	xxx_messageInfo_TxPayload.Merge(m, src)
}
func (m *TxPayload) XXX_Size() int {
	return m.Size()
}
func (m *TxPayload) XXX_DiscardUnknown() {
	xxx_messageInfo_TxPayload.DiscardUnknown(m)
}

var xxx_messageInfo_TxPayload proto.InternalMessageInfo

// if this is a config update, the handler is "config"
// and payload is Chainconfig
type VoteTxData struct {
	Handler string `protobuf:"bytes,1,opt,name=handler,proto3" json:"handler,omitempty"`
	Subject string `protobuf:"bytes,2,opt,name=subject,proto3" json:"subject,omitempty"`
	Payload []byte `protobuf:"bytes,3,opt,name=payload,proto3" json:"payload,omitempty"`
}

func (m *VoteTxData) Reset()         { *m = VoteTxData{} }
func (m *VoteTxData) String() string { return proto.CompactTextString(m) }
func (*VoteTxData) ProtoMessage()    {}
func (*VoteTxData) Descriptor() ([]byte, []int) {
	return fileDescriptor_f6296da495f91d72, []int{4}
}
func (m *VoteTxData) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *VoteTxData) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_VoteTxData.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *VoteTxData) XXX_Merge(src proto.Message) {
	xxx_messageInfo_VoteTxData.Merge(m, src)
}
func (m *VoteTxData) XXX_Size() int {
	return m.Size()
}
func (m *VoteTxData) XXX_DiscardUnknown() {
	xxx_messageInfo_VoteTxData.DiscardUnknown(m)
}

var xxx_messageInfo_VoteTxData proto.InternalMessageInfo

type CertWithStatus struct {
	Cert   []byte     `protobuf:"bytes,1,opt,name=cert,proto3" json:"cert,omitempty"`
	Status CertStatus `protobuf:"varint,2,opt,name=status,proto3,enum=common.CertStatus" json:"status,omitempty"`
}

func (m *CertWithStatus) Reset()         { *m = CertWithStatus{} }
func (m *CertWithStatus) String() string { return proto.CompactTextString(m) }
func (*CertWithStatus) ProtoMessage()    {}
func (*CertWithStatus) Descriptor() ([]byte, []int) {
	return fileDescriptor_f6296da495f91d72, []int{5}
}
func (m *CertWithStatus) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *CertWithStatus) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_CertWithStatus.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *CertWithStatus) XXX_Merge(src proto.Message) {
	xxx_messageInfo_CertWithStatus.Merge(m, src)
}
func (m *CertWithStatus) XXX_Size() int {
	return m.Size()
}
func (m *CertWithStatus) XXX_DiscardUnknown() {
	xxx_messageInfo_CertWithStatus.DiscardUnknown(m)
}

var xxx_messageInfo_CertWithStatus proto.InternalMessageInfo

type CommonTxData struct {
	ContractInvocation []byte              `protobuf:"bytes,1,opt,name=contractInvocation,proto3" json:"contractInvocation,omitempty"`
	Response           *InvocationResponse `protobuf:"bytes,2,opt,name=response,proto3" json:"response,omitempty"`
	StateUpdates       []*StateUpdates     `protobuf:"bytes,3,rep,name=stateUpdates,proto3" json:"stateUpdates,omitempty"`
}

func (m *CommonTxData) Reset()         { *m = CommonTxData{} }
func (m *CommonTxData) String() string { return proto.CompactTextString(m) }
func (*CommonTxData) ProtoMessage()    {}
func (*CommonTxData) Descriptor() ([]byte, []int) {
	return fileDescriptor_f6296da495f91d72, []int{6}
}
func (m *CommonTxData) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *CommonTxData) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_CommonTxData.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *CommonTxData) XXX_Merge(src proto.Message) {
	xxx_messageInfo_CommonTxData.Merge(m, src)
}
func (m *CommonTxData) XXX_Size() int {
	return m.Size()
}
func (m *CommonTxData) XXX_DiscardUnknown() {
	xxx_messageInfo_CommonTxData.DiscardUnknown(m)
}

var xxx_messageInfo_CommonTxData proto.InternalMessageInfo

type ContractInvocation struct {
	ContractName string   `protobuf:"bytes,1,opt,name=contract_name,json=contractName,proto3" json:"contract_name,omitempty"`
	FuncName     string   `protobuf:"bytes,2,opt,name=func_name,json=funcName,proto3" json:"func_name,omitempty"`
	Args         [][]byte `protobuf:"bytes,3,rep,name=args,proto3" json:"args,omitempty"`
	EncryptedKey []byte   `protobuf:"bytes,4,opt,name=encryptedKey,proto3" json:"encryptedKey,omitempty"`
	IsCompressed bool     `protobuf:"varint,5,opt,name=is_compressed,json=isCompressed,proto3" json:"is_compressed,omitempty"`
}

func (m *ContractInvocation) Reset()         { *m = ContractInvocation{} }
func (m *ContractInvocation) String() string { return proto.CompactTextString(m) }
func (*ContractInvocation) ProtoMessage()    {}
func (*ContractInvocation) Descriptor() ([]byte, []int) {
	return fileDescriptor_f6296da495f91d72, []int{7}
}
func (m *ContractInvocation) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ContractInvocation) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ContractInvocation.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ContractInvocation) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ContractInvocation.Merge(m, src)
}
func (m *ContractInvocation) XXX_Size() int {
	return m.Size()
}
func (m *ContractInvocation) XXX_DiscardUnknown() {
	xxx_messageInfo_ContractInvocation.DiscardUnknown(m)
}

var xxx_messageInfo_ContractInvocation proto.InternalMessageInfo

type InvocationResponse struct {
	Status     Status `protobuf:"varint,1,opt,name=status,proto3,enum=common.Status" json:"status,omitempty"`
	StatusInfo string `protobuf:"bytes,2,opt,name=status_info,json=statusInfo,proto3" json:"status_info,omitempty"`
	Payload    []byte `protobuf:"bytes,3,opt,name=payload,proto3" json:"payload,omitempty"`
}

func (m *InvocationResponse) Reset()         { *m = InvocationResponse{} }
func (m *InvocationResponse) String() string { return proto.CompactTextString(m) }
func (*InvocationResponse) ProtoMessage()    {}
func (*InvocationResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_f6296da495f91d72, []int{8}
}
func (m *InvocationResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *InvocationResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_InvocationResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *InvocationResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_InvocationResponse.Merge(m, src)
}
func (m *InvocationResponse) XXX_Size() int {
	return m.Size()
}
func (m *InvocationResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_InvocationResponse.DiscardUnknown(m)
}

var xxx_messageInfo_InvocationResponse proto.InternalMessageInfo

type Approval struct {
	Identity []byte         `protobuf:"bytes,1,opt,name=identity,proto3" json:"identity,omitempty"`
	Sign     []byte         `protobuf:"bytes,2,opt,name=sign,proto3" json:"sign,omitempty"`
	Type     ContractRunEnv `protobuf:"varint,3,opt,name=type,proto3,enum=common.ContractRunEnv" json:"type,omitempty"`
	OrgName  string         `protobuf:"bytes,4,opt,name=org_name,json=orgName,proto3" json:"org_name,omitempty"`
	NodeName string         `protobuf:"bytes,5,opt,name=node_name,json=nodeName,proto3" json:"node_name,omitempty"`
}

func (m *Approval) Reset()         { *m = Approval{} }
func (m *Approval) String() string { return proto.CompactTextString(m) }
func (*Approval) ProtoMessage()    {}
func (*Approval) Descriptor() ([]byte, []int) {
	return fileDescriptor_f6296da495f91d72, []int{9}
}
func (m *Approval) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Approval) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Approval.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Approval) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Approval.Merge(m, src)
}
func (m *Approval) XXX_Size() int {
	return m.Size()
}
func (m *Approval) XXX_DiscardUnknown() {
	xxx_messageInfo_Approval.DiscardUnknown(m)
}

var xxx_messageInfo_Approval proto.InternalMessageInfo

type TxResult struct {
	TxHash []byte   `protobuf:"bytes,1,opt,name=tx_hash,json=txHash,proto3" json:"tx_hash,omitempty"`
	Status TxStatus `protobuf:"varint,2,opt,name=status,proto3,enum=common.TxStatus" json:"status,omitempty"`
}

func (m *TxResult) Reset()         { *m = TxResult{} }
func (m *TxResult) String() string { return proto.CompactTextString(m) }
func (*TxResult) ProtoMessage()    {}
func (*TxResult) Descriptor() ([]byte, []int) {
	return fileDescriptor_f6296da495f91d72, []int{10}
}
func (m *TxResult) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *TxResult) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_TxResult.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *TxResult) XXX_Merge(src proto.Message) {
	xxx_messageInfo_TxResult.Merge(m, src)
}
func (m *TxResult) XXX_Size() int {
	return m.Size()
}
func (m *TxResult) XXX_DiscardUnknown() {
	xxx_messageInfo_TxResult.DiscardUnknown(m)
}

var xxx_messageInfo_TxResult proto.InternalMessageInfo

type BlockResult struct {
	BlockNum  uint64      `protobuf:"varint,1,opt,name=blockNum,proto3" json:"blockNum,omitempty"`
	TxResults []*TxResult `protobuf:"bytes,2,rep,name=txResults,proto3" json:"txResults,omitempty"`
}

func (m *BlockResult) Reset()         { *m = BlockResult{} }
func (m *BlockResult) String() string { return proto.CompactTextString(m) }
func (*BlockResult) ProtoMessage()    {}
func (*BlockResult) Descriptor() ([]byte, []int) {
	return fileDescriptor_f6296da495f91d72, []int{11}
}
func (m *BlockResult) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *BlockResult) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_BlockResult.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *BlockResult) XXX_Merge(src proto.Message) {
	xxx_messageInfo_BlockResult.Merge(m, src)
}
func (m *BlockResult) XXX_Size() int {
	return m.Size()
}
func (m *BlockResult) XXX_DiscardUnknown() {
	xxx_messageInfo_BlockResult.DiscardUnknown(m)
}

var xxx_messageInfo_BlockResult proto.InternalMessageInfo

type KeyModification struct {
	Value     []byte `protobuf:"bytes,1,opt,name=value,proto3" json:"value,omitempty"`
	BlockNum  uint64 `protobuf:"varint,2,opt,name=block_num,json=blockNum,proto3" json:"block_num,omitempty"`
	TxNum     int32  `protobuf:"varint,3,opt,name=tx_num,json=txNum,proto3" json:"tx_num,omitempty"`
	TxHash    []byte `protobuf:"bytes,4,opt,name=tx_hash,json=txHash,proto3" json:"tx_hash,omitempty"`
	IsDeleted bool   `protobuf:"varint,5,opt,name=is_deleted,json=isDeleted,proto3" json:"is_deleted,omitempty"`
	Timestamp uint64 `protobuf:"varint,6,opt,name=timestamp,proto3" json:"timestamp,omitempty"`
}

func (m *KeyModification) Reset()         { *m = KeyModification{} }
func (m *KeyModification) String() string { return proto.CompactTextString(m) }
func (*KeyModification) ProtoMessage()    {}
func (*KeyModification) Descriptor() ([]byte, []int) {
	return fileDescriptor_f6296da495f91d72, []int{12}
}
func (m *KeyModification) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *KeyModification) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_KeyModification.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *KeyModification) XXX_Merge(src proto.Message) {
	xxx_messageInfo_KeyModification.Merge(m, src)
}
func (m *KeyModification) XXX_Size() int {
	return m.Size()
}
func (m *KeyModification) XXX_DiscardUnknown() {
	xxx_messageInfo_KeyModification.DiscardUnknown(m)
}

var xxx_messageInfo_KeyModification proto.InternalMessageInfo

type CompactTx struct {
	Height int32 `protobuf:"varint,1,opt,name=height,proto3" json:"height,omitempty"`
	Begin  int32 `protobuf:"varint,2,opt,name=begin,proto3" json:"begin,omitempty"`
	End    int32 `protobuf:"varint,3,opt,name=end,proto3" json:"end,omitempty"`
}

func (m *CompactTx) Reset()         { *m = CompactTx{} }
func (m *CompactTx) String() string { return proto.CompactTextString(m) }
func (*CompactTx) ProtoMessage()    {}
func (*CompactTx) Descriptor() ([]byte, []int) {
	return fileDescriptor_f6296da495f91d72, []int{13}
}
func (m *CompactTx) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *CompactTx) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_CompactTx.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *CompactTx) XXX_Merge(src proto.Message) {
	xxx_messageInfo_CompactTx.Merge(m, src)
}
func (m *CompactTx) XXX_Size() int {
	return m.Size()
}
func (m *CompactTx) XXX_DiscardUnknown() {
	xxx_messageInfo_CompactTx.DiscardUnknown(m)
}

var xxx_messageInfo_CompactTx proto.InternalMessageInfo

type Tx struct {
	Hash []byte `protobuf:"bytes,1,opt,name=hash,proto3" json:"hash,omitempty"`
	// Types that are valid to be assigned to Data:
	//	*Tx_Full
	//	*Tx_Compact
	Data isTx_Data `protobuf_oneof:"data"`
}

func (m *Tx) Reset()         { *m = Tx{} }
func (m *Tx) String() string { return proto.CompactTextString(m) }
func (*Tx) ProtoMessage()    {}
func (*Tx) Descriptor() ([]byte, []int) {
	return fileDescriptor_f6296da495f91d72, []int{14}
}
func (m *Tx) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Tx) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Tx.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Tx) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Tx.Merge(m, src)
}
func (m *Tx) XXX_Size() int {
	return m.Size()
}
func (m *Tx) XXX_DiscardUnknown() {
	xxx_messageInfo_Tx.DiscardUnknown(m)
}

var xxx_messageInfo_Tx proto.InternalMessageInfo

type isTx_Data interface {
	isTx_Data()
	MarshalTo([]byte) (int, error)
	Size() int
}

type Tx_Full struct {
	Full *Transaction `protobuf:"bytes,2,opt,name=full,proto3,oneof" json:"full,omitempty"`
}
type Tx_Compact struct {
	Compact *CompactTx `protobuf:"bytes,3,opt,name=compact,proto3,oneof" json:"compact,omitempty"`
}

func (*Tx_Full) isTx_Data()    {}
func (*Tx_Compact) isTx_Data() {}

func (m *Tx) GetData() isTx_Data {
	if m != nil {
		return m.Data
	}
	return nil
}

func (m *Tx) GetFull() *Transaction {
	if x, ok := m.GetData().(*Tx_Full); ok {
		return x.Full
	}
	return nil
}

func (m *Tx) GetCompact() *CompactTx {
	if x, ok := m.GetData().(*Tx_Compact); ok {
		return x.Compact
	}
	return nil
}

// XXX_OneofWrappers is for the internal use of the proto package.
func (*Tx) XXX_OneofWrappers() []interface{} {
	return []interface{}{
		(*Tx_Full)(nil),
		(*Tx_Compact)(nil),
	}
}

func init() {
	proto.RegisterEnum("common.TxType", TxType_name, TxType_value)
	proto.RegisterEnum("common.CertStatus", CertStatus_name, CertStatus_value)
	proto.RegisterEnum("common.ContractRunEnv", ContractRunEnv_name, ContractRunEnv_value)
	proto.RegisterEnum("common.TxStatus", TxStatus_name, TxStatus_value)
	proto.RegisterEnum("common.Identity_Type", Identity_Type_name, Identity_Type_value)
	proto.RegisterType((*Identity)(nil), "common.Identity")
	proto.RegisterType((*TxHeader)(nil), "common.TxHeader")
	proto.RegisterType((*Transaction)(nil), "common.Transaction")
	proto.RegisterMapType((map[string][]byte)(nil), "common.Transaction.ExtensionsEntry")
	proto.RegisterType((*TxPayload)(nil), "common.TxPayload")
	proto.RegisterType((*VoteTxData)(nil), "common.VoteTxData")
	proto.RegisterType((*CertWithStatus)(nil), "common.CertWithStatus")
	proto.RegisterType((*CommonTxData)(nil), "common.CommonTxData")
	proto.RegisterType((*ContractInvocation)(nil), "common.ContractInvocation")
	proto.RegisterType((*InvocationResponse)(nil), "common.InvocationResponse")
	proto.RegisterType((*Approval)(nil), "common.Approval")
	proto.RegisterType((*TxResult)(nil), "common.TxResult")
	proto.RegisterType((*BlockResult)(nil), "common.BlockResult")
	proto.RegisterType((*KeyModification)(nil), "common.KeyModification")
	proto.RegisterType((*CompactTx)(nil), "common.CompactTx")
	proto.RegisterType((*Tx)(nil), "common.Tx")
}

func init() { proto.RegisterFile("common/transaction.proto", fileDescriptor_f6296da495f91d72) }

var fileDescriptor_f6296da495f91d72 = []byte{
	// 1564 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0x7c, 0x56, 0xdd, 0x6e, 0xdb, 0xc8,
	0x15, 0x16, 0xf5, 0xaf, 0x23, 0xad, 0xc3, 0x9d, 0xd8, 0x8e, 0xe2, 0xec, 0x2a, 0x5e, 0x05, 0x28,
	0xbc, 0x6e, 0x6b, 0x03, 0x29, 0xba, 0x58, 0x14, 0xe8, 0x05, 0x43, 0x31, 0x2b, 0xc2, 0x12, 0xa5,
	0x8e, 0x68, 0x27, 0xce, 0x0d, 0xc1, 0x90, 0x63, 0x89, 0x8d, 0x44, 0x0a, 0xe4, 0xc8, 0x91, 0x16,
	0xbd, 0xe8, 0x23, 0xf4, 0x09, 0xfa, 0x0c, 0x2d, 0xfa, 0x12, 0x7b, 0x99, 0xcb, 0x02, 0xbd, 0xe9,
	0x26, 0xef, 0xd1, 0x16, 0xf3, 0x43, 0x8a, 0xb2, 0x83, 0xde, 0xcd, 0xf9, 0xbe, 0x73, 0x38, 0xdf,
	0x9c, 0x73, 0xe6, 0x0c, 0xa1, 0xed, 0x45, 0x8b, 0x45, 0x14, 0x9e, 0xd3, 0xd8, 0x0d, 0x13, 0xd7,
	0xa3, 0x41, 0x14, 0x9e, 0x2d, 0xe3, 0x88, 0x46, 0xa8, 0x2a, 0x98, 0xa3, 0xfd, 0x69, 0x34, 0x8d,
	0x38, 0x74, 0xce, 0x56, 0x82, 0x3d, 0x7a, 0x28, 0xe3, 0xe6, 0xc4, 0x9f, 0x92, 0x58, 0x82, 0xfb,
	0x12, 0x5c, 0x90, 0x24, 0x71, 0xa7, 0x44, 0xa0, 0xdd, 0x1f, 0xa1, 0x6e, 0xfa, 0x24, 0xa4, 0x01,
	0xdd, 0x20, 0x15, 0x4a, 0x51, 0x3c, 0x6d, 0x2b, 0xc7, 0xca, 0x49, 0x03, 0xb3, 0x25, 0xfa, 0x16,
	0xca, 0x74, 0xb3, 0x24, 0xed, 0xe2, 0xb1, 0x72, 0xb2, 0xf7, 0xfc, 0xe0, 0x4c, 0x7c, 0xe2, 0x2c,
	0x8d, 0x38, 0xb3, 0x37, 0x4b, 0x82, 0xb9, 0x0b, 0xda, 0x83, 0x62, 0xe0, 0xb7, 0x4b, 0xc7, 0xca,
	0x49, 0x0b, 0x17, 0x03, 0xbf, 0xfb, 0x0d, 0x94, 0x19, 0x8b, 0x1e, 0x40, 0x53, 0x1f, 0x0d, 0x87,
	0x23, 0xcb, 0xb1, 0xb4, 0xa1, 0xa1, 0x16, 0x50, 0x1d, 0xca, 0xba, 0x81, 0x6d, 0x55, 0xe9, 0xfe,
	0xb9, 0x08, 0x75, 0x7b, 0xdd, 0x27, 0xae, 0x4f, 0x62, 0xd4, 0x95, 0x5b, 0x29, 0x7c, 0xab, 0xbd,
	0x74, 0x2b, 0x7b, 0x9d, 0xdb, 0xe3, 0x31, 0xd4, 0xbd, 0x99, 0x1b, 0x84, 0x4e, 0xe0, 0x73, 0x49,
	0x0d, 0x5c, 0xe3, 0xb6, 0xe9, 0xa3, 0x53, 0xa8, 0x79, 0x31, 0x71, 0x69, 0x14, 0x73, 0x0d, 0xcd,
	0xe7, 0xea, 0x5d, 0xb1, 0x38, 0x75, 0x40, 0x5f, 0x41, 0x83, 0x06, 0x0b, 0x92, 0x50, 0x77, 0xb1,
	0x6c, 0x97, 0x8f, 0x95, 0x93, 0x32, 0xde, 0x02, 0x68, 0x1f, 0x2a, 0x61, 0x14, 0x7a, 0xa4, 0x5d,
	0xe1, 0x8c, 0x30, 0xd0, 0x37, 0xd0, 0x9a, 0xbb, 0x94, 0x24, 0xd4, 0x79, 0x3b, 0x8f, 0xbc, 0x77,
	0xed, 0x2a, 0x27, 0x9b, 0x02, 0x7b, 0xc1, 0x20, 0xd4, 0x86, 0x9a, 0x1f, 0x2d, 0xdc, 0x20, 0x4c,
	0xda, 0xb5, 0xe3, 0x12, 0x13, 0x27, 0x4d, 0xc6, 0xdc, 0x92, 0x38, 0x09, 0xa2, 0xb0, 0x5d, 0x17,
	0xb2, 0xa5, 0xd9, 0xfd, 0x97, 0x02, 0x4d, 0x7b, 0x5b, 0x5d, 0xe6, 0xb9, 0x74, 0x37, 0xf3, 0xc8,
	0xf5, 0x79, 0x22, 0x5a, 0x38, 0x35, 0xd1, 0x19, 0x34, 0xdc, 0xe5, 0x32, 0x8e, 0x6e, 0xdd, 0x79,
	0xd2, 0x2e, 0x1e, 0x97, 0xf2, 0x47, 0xd4, 0x24, 0x81, 0xb7, 0x2e, 0x48, 0x07, 0x20, 0x6b, 0x4a,
	0x42, 0xb6, 0x4d, 0xd2, 0x2e, 0xf1, 0x80, 0x67, 0x59, 0x56, 0x73, 0x0d, 0x65, 0x64, 0x5e, 0x46,
	0x48, 0xe3, 0x0d, 0xce, 0x85, 0x1d, 0xfd, 0x1e, 0x1e, 0xdc, 0xa1, 0x59, 0x93, 0xbc, 0x23, 0x9b,
	0xb4, 0x49, 0xde, 0x91, 0x0d, 0x4b, 0xd8, 0xad, 0x3b, 0x5f, 0x89, 0x2e, 0x69, 0x61, 0x61, 0xfc,
	0xae, 0xf8, 0xbd, 0xd2, 0x35, 0xa1, 0x61, 0xaf, 0xc7, 0xf2, 0x00, 0x27, 0x50, 0x9d, 0xf1, 0x52,
	0xf3, 0xd8, 0x9c, 0xfa, 0xb4, 0x05, 0xb0, 0xe4, 0x11, 0x82, 0xb2, 0xef, 0x52, 0x57, 0x7e, 0x8f,
	0xaf, 0xbb, 0x6f, 0x00, 0xae, 0x22, 0x4a, 0xec, 0x75, 0xcf, 0xa5, 0x2e, 0x4b, 0xd3, 0xcc, 0x0d,
	0xfd, 0xb9, 0xfc, 0x58, 0x03, 0xa7, 0x26, 0x63, 0x92, 0xd5, 0xdb, 0x3f, 0x12, 0x8f, 0xa6, 0x1d,
	0x22, 0xcd, 0x7c, 0x6a, 0x4b, 0x3b, 0xa9, 0xed, 0x8e, 0x61, 0x4f, 0x27, 0x31, 0x7d, 0x15, 0xd0,
	0xd9, 0x84, 0xba, 0x74, 0x95, 0x30, 0x05, 0x1e, 0x89, 0xa9, 0xac, 0x01, 0x5f, 0xa3, 0x53, 0xa8,
	0x26, 0x9c, 0x95, 0xb7, 0x01, 0xa5, 0xfa, 0x59, 0xac, 0x88, 0xc3, 0xd2, 0xa3, 0xfb, 0x37, 0x05,
	0x5a, 0x3a, 0x67, 0xa5, 0xe0, 0x33, 0x40, 0x5e, 0x14, 0xd2, 0xd8, 0xf5, 0xa8, 0x19, 0xde, 0x46,
	0x9e, 0xcb, 0x52, 0x2f, 0x3f, 0xff, 0x19, 0x06, 0x7d, 0x07, 0xf5, 0x98, 0x24, 0xcb, 0x28, 0x4c,
	0x44, 0x5a, 0x9b, 0xcf, 0x8f, 0xb2, 0x7e, 0xce, 0xbc, 0xb0, 0xf4, 0xc0, 0x99, 0x2f, 0xfa, 0x1e,
	0x5a, 0x4c, 0x02, 0xb9, 0x5c, 0xfa, 0xac, 0x33, 0x65, 0xdd, 0xf7, 0xd3, 0xd8, 0x49, 0x8e, 0xc3,
	0x3b, 0x9e, 0xdd, 0x7f, 0x28, 0x80, 0xf4, 0xfb, 0x42, 0x9e, 0xc1, 0x17, 0xa9, 0x3c, 0x27, 0x74,
	0x17, 0x44, 0xe6, 0xbb, 0x95, 0x82, 0x96, 0xbb, 0x20, 0xe8, 0x09, 0x34, 0x6e, 0x56, 0xa1, 0x27,
	0x1c, 0x44, 0xda, 0xeb, 0x0c, 0xe0, 0x24, 0x82, 0xb2, 0x1b, 0x4f, 0x85, 0x94, 0x16, 0xe6, 0x6b,
	0xd4, 0x85, 0x16, 0x09, 0xbd, 0x78, 0xb3, 0xa4, 0xc4, 0xbf, 0x20, 0x1b, 0x7e, 0x09, 0x5b, 0x78,
	0x07, 0x63, 0x3b, 0x07, 0x89, 0xe3, 0x45, 0x8b, 0x65, 0x4c, 0x92, 0x84, 0xf8, 0xfc, 0x3e, 0xd6,
	0x71, 0x2b, 0x48, 0xf4, 0x0c, 0xeb, 0xbe, 0x07, 0x74, 0x3f, 0x1f, 0xe8, 0x17, 0x59, 0xa9, 0xee,
	0x4c, 0x93, 0xdd, 0x32, 0xa1, 0xa7, 0xd0, 0x14, 0x2b, 0x27, 0x08, 0x6f, 0x22, 0xa9, 0x1c, 0x04,
	0x64, 0x86, 0x37, 0xd1, 0xff, 0xe9, 0x99, 0xbf, 0x2a, 0x50, 0x4f, 0xaf, 0x1d, 0x3a, 0x82, 0x7a,
	0x20, 0xa7, 0x8c, 0xac, 0x69, 0x66, 0xb3, 0xe3, 0x27, 0xc1, 0x34, 0x4c, 0x9b, 0x99, 0xad, 0xd1,
	0xa9, 0x9c, 0x75, 0x25, 0xae, 0xee, 0x30, 0x6b, 0x24, 0x99, 0x53, 0xbc, 0x0a, 0x8d, 0xf0, 0x76,
	0x3b, 0xf3, 0xa2, 0x78, 0x2a, 0x52, 0x5b, 0x16, 0x1d, 0x1d, 0xc5, 0xd3, 0x34, 0xed, 0x61, 0xe4,
	0x13, 0xc1, 0x55, 0x44, 0xda, 0x19, 0xc0, 0xc8, 0xee, 0x90, 0xcd, 0x56, 0x4c, 0x92, 0xd5, 0x9c,
	0xa2, 0x47, 0x50, 0xa3, 0x6b, 0x67, 0xe6, 0x26, 0x33, 0x29, 0xaf, 0x4a, 0xd7, 0x7d, 0x37, 0x99,
	0xb1, 0x3b, 0xb9, 0xd3, 0xd3, 0xb9, 0x3b, 0x79, 0xa7, 0xa3, 0xaf, 0xa1, 0xc9, 0xa7, 0x9c, 0xfc,
	0xe2, 0x11, 0xd4, 0xf9, 0x1c, 0xb4, 0x56, 0x0b, 0xfe, 0xc9, 0x32, 0xce, 0x6c, 0x36, 0xa9, 0xa8,
	0xdc, 0xf9, 0xde, 0xa4, 0x4a, 0x25, 0xe1, 0xad, 0x4b, 0xf7, 0xef, 0x0a, 0x3c, 0xb8, 0x20, 0x9b,
	0x61, 0xe4, 0x07, 0x37, 0x81, 0x6c, 0xbb, 0x6c, 0xa6, 0x28, 0xb9, 0x99, 0xc2, 0x0e, 0xcc, 0x77,
	0x71, 0xc2, 0xd5, 0x82, 0x2b, 0xce, 0x6f, 0x7b, 0x00, 0x55, 0xba, 0xe6, 0x0c, 0x4b, 0x6b, 0x05,
	0x57, 0xe8, 0x9a, 0xc1, 0xb9, 0xb3, 0x97, 0x77, 0xce, 0xfe, 0x35, 0x40, 0x90, 0x38, 0x3e, 0x99,
	0x13, 0x9a, 0x35, 0x57, 0x23, 0x48, 0x7a, 0x02, 0xd8, 0x7d, 0x24, 0xaa, 0x77, 0x1e, 0x89, 0xee,
	0x05, 0x34, 0x58, 0x17, 0xba, 0x1e, 0xb5, 0xd7, 0xe8, 0x90, 0x4d, 0xb6, 0x60, 0x3a, 0x13, 0xf3,
	0xa2, 0x82, 0xa5, 0xc5, 0x0e, 0xf1, 0x96, 0x4c, 0x03, 0x51, 0xfb, 0x0a, 0x16, 0x06, 0x1b, 0xa0,
	0x24, 0xf4, 0xa5, 0x48, 0xb6, 0xec, 0xfe, 0x08, 0x45, 0x7b, 0xcd, 0x1a, 0x25, 0x57, 0x21, 0xbe,
	0x66, 0xef, 0xef, 0xcd, 0x6a, 0x3e, 0x97, 0x23, 0xe0, 0xe1, 0x67, 0xc6, 0x77, 0xbf, 0x80, 0xb9,
	0x0b, 0xfa, 0x35, 0xd4, 0x3c, 0xa1, 0x48, 0x3e, 0x80, 0x5f, 0x6e, 0xdb, 0x4a, 0x0a, 0xed, 0x17,
	0x70, 0xea, 0xf3, 0xa2, 0x2a, 0x66, 0xec, 0xe9, 0x77, 0x50, 0x15, 0x4f, 0x2c, 0x3a, 0x04, 0x24,
	0x1f, 0x6a, 0x1b, 0x6b, 0xd6, 0x44, 0xd3, 0x6d, 0x73, 0x64, 0xa9, 0x05, 0xb4, 0x0f, 0xea, 0xd5,
	0xc8, 0x36, 0x76, 0x50, 0xe5, 0x54, 0x07, 0xd8, 0xce, 0x3d, 0xfe, 0xc8, 0x1b, 0xd8, 0x76, 0xac,
	0x11, 0x1e, 0x6a, 0x03, 0xb5, 0x80, 0x1e, 0xc2, 0x03, 0x0e, 0x60, 0xe3, 0x6a, 0xa4, 0x6b, 0x22,
	0x26, 0xf3, 0x7a, 0x89, 0x0d, 0xe3, 0x8d, 0xa1, 0x16, 0x4f, 0x0d, 0xd8, 0xdb, 0xed, 0x79, 0x04,
	0x50, 0xed, 0x45, 0xde, 0x3b, 0x12, 0xab, 0x05, 0xb6, 0xb6, 0x5c, 0x1a, 0xdc, 0x12, 0x55, 0x41,
	0x7b, 0x00, 0x62, 0xfd, 0xca, 0x4d, 0x16, 0x6a, 0x11, 0x35, 0xa1, 0x66, 0x1b, 0x06, 0x37, 0x4a,
	0xa7, 0xff, 0x29, 0xb3, 0x5e, 0x97, 0x52, 0x1a, 0x50, 0xb9, 0xd2, 0x06, 0x66, 0x4f, 0x2d, 0xb0,
	0x13, 0x99, 0x16, 0x37, 0x1c, 0xfb, 0xb5, 0x33, 0xd6, 0xae, 0x07, 0x23, 0xad, 0xa7, 0x2a, 0xe8,
	0x00, 0xbe, 0xcc, 0xe1, 0x7d, 0x43, 0xeb, 0x19, 0x58, 0x2d, 0x32, 0xcd, 0x39, 0xd8, 0xbe, 0x1e,
	0x1b, 0x6a, 0x89, 0x81, 0x97, 0xd6, 0x85, 0x35, 0x7a, 0x65, 0x65, 0x60, 0x19, 0xa9, 0xd0, 0xea,
	0x5d, 0x8e, 0x07, 0xa6, 0xae, 0xb1, 0xbc, 0xbc, 0x56, 0x2b, 0xa8, 0x03, 0x47, 0x69, 0xec, 0xc4,
	0x66, 0xe8, 0xe5, 0xb8, 0xa7, 0xd9, 0xc6, 0x44, 0x44, 0x54, 0xd1, 0xd7, 0xf0, 0x38, 0xe5, 0x4d,
	0x6b, 0xc2, 0x92, 0xc0, 0xdd, 0x86, 0x86, 0x65, 0x4f, 0xd4, 0x5a, 0x9e, 0x9e, 0x18, 0x03, 0x43,
	0xdf, 0xa1, 0xeb, 0xf9, 0x83, 0x4c, 0xfe, 0x30, 0x70, 0x26, 0xd7, 0x96, 0xad, 0xbd, 0x56, 0x1b,
	0xf7, 0x70, 0xbd, 0x6f, 0x0c, 0x35, 0x15, 0xd0, 0x11, 0x1c, 0xa6, 0x78, 0x5a, 0xd2, 0xd7, 0x4e,
	0x4f, 0xb3, 0x35, 0xb5, 0x89, 0xda, 0xb0, 0x9f, 0x72, 0xa2, 0xac, 0x92, 0x69, 0xe5, 0x19, 0xbd,
	0xaf, 0x99, 0x96, 0xa3, 0x8f, 0xac, 0x97, 0xe6, 0x0f, 0xea, 0x17, 0xe8, 0x09, 0x3c, 0x4a, 0x19,
	0x0d, 0xeb, 0x7d, 0xf3, 0x6a, 0x1b, 0xb6, 0x87, 0x9e, 0xc2, 0x93, 0xed, 0x66, 0x96, 0x8d, 0x35,
	0xdd, 0x76, 0x4c, 0x2b, 0x2b, 0xfb, 0x41, 0x3e, 0x37, 0xda, 0x78, 0x8c, 0x47, 0x57, 0xda, 0xc0,
	0x99, 0x98, 0x3f, 0x58, 0x9a, 0x7d, 0x89, 0x0d, 0xf5, 0x10, 0x1d, 0xc3, 0x57, 0x29, 0x3e, 0x71,
	0xb8, 0x1f, 0x8f, 0x74, 0x5e, 0x6a, 0xe6, 0x80, 0x79, 0x3c, 0x62, 0xca, 0xd2, 0x22, 0x70, 0xcd,
	0x7d, 0xcd, 0xea, 0x0d, 0x0c, 0xac, 0x3e, 0xbd, 0x77, 0x9a, 0xb4, 0xc8, 0xc7, 0xac, 0x46, 0x29,
	0x33, 0xbc, 0xd2, 0x75, 0xf5, 0x5b, 0xf4, 0x18, 0x0e, 0x32, 0x81, 0xda, 0x00, 0x1b, 0x5a, 0xef,
	0xda, 0x31, 0x2d, 0xd3, 0x56, 0x4f, 0x59, 0x47, 0x64, 0x94, 0x35, 0xb2, 0x05, 0xfc, 0xcb, 0xfc,
	0xd7, 0x07, 0xac, 0x9a, 0xb6, 0xf3, 0x62, 0x30, 0xd2, 0x2f, 0xd4, 0x5f, 0xa1, 0x16, 0xd4, 0x24,
	0xa3, 0xfe, 0x57, 0x79, 0xf1, 0xa7, 0x9f, 0x7e, 0xee, 0x14, 0x3e, 0xfc, 0xdc, 0x29, 0xfc, 0xf4,
	0xb1, 0xa3, 0x7c, 0xf8, 0xd8, 0x51, 0xfe, 0xfd, 0xb1, 0xa3, 0xfc, 0xe5, 0x53, 0xa7, 0xf0, 0xe1,
	0x53, 0xa7, 0xf0, 0xcf, 0x4f, 0x9d, 0x02, 0x3c, 0xf3, 0xa2, 0xc5, 0xd9, 0x6c, 0xe5, 0xbe, 0x27,
	0xc1, 0xd9, 0xfb, 0x80, 0x84, 0x24, 0xe6, 0x3f, 0xae, 0xe2, 0x27, 0x5c, 0x5e, 0xd4, 0x37, 0xbf,
	0x9d, 0x06, 0x34, 0x75, 0xf2, 0xa2, 0xc5, 0xf9, 0x32, 0x0a, 0x92, 0x84, 0x3d, 0x68, 0x6e, 0xec,
	0xcd, 0xce, 0x73, 0x61, 0xe7, 0xe2, 0x8f, 0x5f, 0x84, 0xbd, 0xad, 0x72, 0xeb, 0x37, 0xff, 0x0b,
	0x00, 0x00, 0xff, 0xff, 0xec, 0x4a, 0x53, 0x2b, 0x2e, 0x0c, 0x00, 0x00,
}

func (m *Identity) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Identity) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Identity) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Id) > 0 {
		i -= len(m.Id)
		copy(dAtA[i:], m.Id)
		i = encodeVarintTransaction(dAtA, i, uint64(len(m.Id)))
		i--
		dAtA[i] = 0x1a
	}
	if m.Type != 0 {
		i = encodeVarintTransaction(dAtA, i, uint64(m.Type))
		i--
		dAtA[i] = 0x10
	}
	if len(m.Org) > 0 {
		i -= len(m.Org)
		copy(dAtA[i:], m.Org)
		i = encodeVarintTransaction(dAtA, i, uint64(len(m.Org)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *TxHeader) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *TxHeader) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *TxHeader) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Version) > 0 {
		i -= len(m.Version)
		copy(dAtA[i:], m.Version)
		i = encodeVarintTransaction(dAtA, i, uint64(len(m.Version)))
		i--
		dAtA[i] = 0x42
	}
	if len(m.Domains) > 0 {
		for iNdEx := len(m.Domains) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.Domains[iNdEx])
			copy(dAtA[i:], m.Domains[iNdEx])
			i = encodeVarintTransaction(dAtA, i, uint64(len(m.Domains[iNdEx])))
			i--
			dAtA[i] = 0x3a
		}
	}
	if m.LatestBlock != 0 {
		i = encodeVarintTransaction(dAtA, i, uint64(m.LatestBlock))
		i--
		dAtA[i] = 0x30
	}
	if m.Nonce != 0 {
		i = encodeVarintTransaction(dAtA, i, uint64(m.Nonce))
		i--
		dAtA[i] = 0x28
	}
	if m.Timestamp != 0 {
		i = encodeVarintTransaction(dAtA, i, uint64(m.Timestamp))
		i--
		dAtA[i] = 0x20
	}
	if m.Creator != nil {
		{
			size, err := m.Creator.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTransaction(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1a
	}
	if len(m.ChainId) > 0 {
		i -= len(m.ChainId)
		copy(dAtA[i:], m.ChainId)
		i = encodeVarintTransaction(dAtA, i, uint64(len(m.ChainId)))
		i--
		dAtA[i] = 0x12
	}
	if m.Type != 0 {
		i = encodeVarintTransaction(dAtA, i, uint64(m.Type))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *Transaction) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Transaction) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Transaction) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Extensions) > 0 {
		for k := range m.Extensions {
			v := m.Extensions[k]
			baseI := i
			if len(v) > 0 {
				i -= len(v)
				copy(dAtA[i:], v)
				i = encodeVarintTransaction(dAtA, i, uint64(len(v)))
				i--
				dAtA[i] = 0x12
			}
			i -= len(k)
			copy(dAtA[i:], k)
			i = encodeVarintTransaction(dAtA, i, uint64(len(k)))
			i--
			dAtA[i] = 0xa
			i = encodeVarintTransaction(dAtA, i, uint64(baseI-i))
			i--
			dAtA[i] = 0x1a
		}
	}
	if len(m.Approvals) > 0 {
		for iNdEx := len(m.Approvals) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Approvals[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintTransaction(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x12
		}
	}
	if len(m.Payload) > 0 {
		i -= len(m.Payload)
		copy(dAtA[i:], m.Payload)
		i = encodeVarintTransaction(dAtA, i, uint64(len(m.Payload)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *TxPayload) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *TxPayload) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *TxPayload) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Data) > 0 {
		i -= len(m.Data)
		copy(dAtA[i:], m.Data)
		i = encodeVarintTransaction(dAtA, i, uint64(len(m.Data)))
		i--
		dAtA[i] = 0x12
	}
	if m.Header != nil {
		{
			size, err := m.Header.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTransaction(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *VoteTxData) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *VoteTxData) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *VoteTxData) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Payload) > 0 {
		i -= len(m.Payload)
		copy(dAtA[i:], m.Payload)
		i = encodeVarintTransaction(dAtA, i, uint64(len(m.Payload)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.Subject) > 0 {
		i -= len(m.Subject)
		copy(dAtA[i:], m.Subject)
		i = encodeVarintTransaction(dAtA, i, uint64(len(m.Subject)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Handler) > 0 {
		i -= len(m.Handler)
		copy(dAtA[i:], m.Handler)
		i = encodeVarintTransaction(dAtA, i, uint64(len(m.Handler)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *CertWithStatus) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CertWithStatus) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *CertWithStatus) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Status != 0 {
		i = encodeVarintTransaction(dAtA, i, uint64(m.Status))
		i--
		dAtA[i] = 0x10
	}
	if len(m.Cert) > 0 {
		i -= len(m.Cert)
		copy(dAtA[i:], m.Cert)
		i = encodeVarintTransaction(dAtA, i, uint64(len(m.Cert)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *CommonTxData) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CommonTxData) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *CommonTxData) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.StateUpdates) > 0 {
		for iNdEx := len(m.StateUpdates) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.StateUpdates[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintTransaction(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x1a
		}
	}
	if m.Response != nil {
		{
			size, err := m.Response.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTransaction(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	if len(m.ContractInvocation) > 0 {
		i -= len(m.ContractInvocation)
		copy(dAtA[i:], m.ContractInvocation)
		i = encodeVarintTransaction(dAtA, i, uint64(len(m.ContractInvocation)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *ContractInvocation) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ContractInvocation) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ContractInvocation) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.IsCompressed {
		i--
		if m.IsCompressed {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x28
	}
	if len(m.EncryptedKey) > 0 {
		i -= len(m.EncryptedKey)
		copy(dAtA[i:], m.EncryptedKey)
		i = encodeVarintTransaction(dAtA, i, uint64(len(m.EncryptedKey)))
		i--
		dAtA[i] = 0x22
	}
	if len(m.Args) > 0 {
		for iNdEx := len(m.Args) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.Args[iNdEx])
			copy(dAtA[i:], m.Args[iNdEx])
			i = encodeVarintTransaction(dAtA, i, uint64(len(m.Args[iNdEx])))
			i--
			dAtA[i] = 0x1a
		}
	}
	if len(m.FuncName) > 0 {
		i -= len(m.FuncName)
		copy(dAtA[i:], m.FuncName)
		i = encodeVarintTransaction(dAtA, i, uint64(len(m.FuncName)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.ContractName) > 0 {
		i -= len(m.ContractName)
		copy(dAtA[i:], m.ContractName)
		i = encodeVarintTransaction(dAtA, i, uint64(len(m.ContractName)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *InvocationResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *InvocationResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *InvocationResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Payload) > 0 {
		i -= len(m.Payload)
		copy(dAtA[i:], m.Payload)
		i = encodeVarintTransaction(dAtA, i, uint64(len(m.Payload)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.StatusInfo) > 0 {
		i -= len(m.StatusInfo)
		copy(dAtA[i:], m.StatusInfo)
		i = encodeVarintTransaction(dAtA, i, uint64(len(m.StatusInfo)))
		i--
		dAtA[i] = 0x12
	}
	if m.Status != 0 {
		i = encodeVarintTransaction(dAtA, i, uint64(m.Status))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *Approval) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Approval) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Approval) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.NodeName) > 0 {
		i -= len(m.NodeName)
		copy(dAtA[i:], m.NodeName)
		i = encodeVarintTransaction(dAtA, i, uint64(len(m.NodeName)))
		i--
		dAtA[i] = 0x2a
	}
	if len(m.OrgName) > 0 {
		i -= len(m.OrgName)
		copy(dAtA[i:], m.OrgName)
		i = encodeVarintTransaction(dAtA, i, uint64(len(m.OrgName)))
		i--
		dAtA[i] = 0x22
	}
	if m.Type != 0 {
		i = encodeVarintTransaction(dAtA, i, uint64(m.Type))
		i--
		dAtA[i] = 0x18
	}
	if len(m.Sign) > 0 {
		i -= len(m.Sign)
		copy(dAtA[i:], m.Sign)
		i = encodeVarintTransaction(dAtA, i, uint64(len(m.Sign)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Identity) > 0 {
		i -= len(m.Identity)
		copy(dAtA[i:], m.Identity)
		i = encodeVarintTransaction(dAtA, i, uint64(len(m.Identity)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *TxResult) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *TxResult) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *TxResult) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Status != 0 {
		i = encodeVarintTransaction(dAtA, i, uint64(m.Status))
		i--
		dAtA[i] = 0x10
	}
	if len(m.TxHash) > 0 {
		i -= len(m.TxHash)
		copy(dAtA[i:], m.TxHash)
		i = encodeVarintTransaction(dAtA, i, uint64(len(m.TxHash)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *BlockResult) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *BlockResult) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *BlockResult) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.TxResults) > 0 {
		for iNdEx := len(m.TxResults) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.TxResults[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintTransaction(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x12
		}
	}
	if m.BlockNum != 0 {
		i = encodeVarintTransaction(dAtA, i, uint64(m.BlockNum))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *KeyModification) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *KeyModification) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *KeyModification) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Timestamp != 0 {
		i = encodeVarintTransaction(dAtA, i, uint64(m.Timestamp))
		i--
		dAtA[i] = 0x30
	}
	if m.IsDeleted {
		i--
		if m.IsDeleted {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x28
	}
	if len(m.TxHash) > 0 {
		i -= len(m.TxHash)
		copy(dAtA[i:], m.TxHash)
		i = encodeVarintTransaction(dAtA, i, uint64(len(m.TxHash)))
		i--
		dAtA[i] = 0x22
	}
	if m.TxNum != 0 {
		i = encodeVarintTransaction(dAtA, i, uint64(m.TxNum))
		i--
		dAtA[i] = 0x18
	}
	if m.BlockNum != 0 {
		i = encodeVarintTransaction(dAtA, i, uint64(m.BlockNum))
		i--
		dAtA[i] = 0x10
	}
	if len(m.Value) > 0 {
		i -= len(m.Value)
		copy(dAtA[i:], m.Value)
		i = encodeVarintTransaction(dAtA, i, uint64(len(m.Value)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *CompactTx) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CompactTx) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *CompactTx) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.End != 0 {
		i = encodeVarintTransaction(dAtA, i, uint64(m.End))
		i--
		dAtA[i] = 0x18
	}
	if m.Begin != 0 {
		i = encodeVarintTransaction(dAtA, i, uint64(m.Begin))
		i--
		dAtA[i] = 0x10
	}
	if m.Height != 0 {
		i = encodeVarintTransaction(dAtA, i, uint64(m.Height))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *Tx) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Tx) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Tx) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Data != nil {
		{
			size := m.Data.Size()
			i -= size
			if _, err := m.Data.MarshalTo(dAtA[i:]); err != nil {
				return 0, err
			}
		}
	}
	if len(m.Hash) > 0 {
		i -= len(m.Hash)
		copy(dAtA[i:], m.Hash)
		i = encodeVarintTransaction(dAtA, i, uint64(len(m.Hash)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *Tx_Full) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Tx_Full) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.Full != nil {
		{
			size, err := m.Full.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTransaction(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	return len(dAtA) - i, nil
}
func (m *Tx_Compact) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Tx_Compact) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.Compact != nil {
		{
			size, err := m.Compact.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTransaction(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1a
	}
	return len(dAtA) - i, nil
}
func encodeVarintTransaction(dAtA []byte, offset int, v uint64) int {
	offset -= sovTransaction(v)
	base := offset
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return base
}
func (m *Identity) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Org)
	if l > 0 {
		n += 1 + l + sovTransaction(uint64(l))
	}
	if m.Type != 0 {
		n += 1 + sovTransaction(uint64(m.Type))
	}
	l = len(m.Id)
	if l > 0 {
		n += 1 + l + sovTransaction(uint64(l))
	}
	return n
}

func (m *TxHeader) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Type != 0 {
		n += 1 + sovTransaction(uint64(m.Type))
	}
	l = len(m.ChainId)
	if l > 0 {
		n += 1 + l + sovTransaction(uint64(l))
	}
	if m.Creator != nil {
		l = m.Creator.Size()
		n += 1 + l + sovTransaction(uint64(l))
	}
	if m.Timestamp != 0 {
		n += 1 + sovTransaction(uint64(m.Timestamp))
	}
	if m.Nonce != 0 {
		n += 1 + sovTransaction(uint64(m.Nonce))
	}
	if m.LatestBlock != 0 {
		n += 1 + sovTransaction(uint64(m.LatestBlock))
	}
	if len(m.Domains) > 0 {
		for _, s := range m.Domains {
			l = len(s)
			n += 1 + l + sovTransaction(uint64(l))
		}
	}
	l = len(m.Version)
	if l > 0 {
		n += 1 + l + sovTransaction(uint64(l))
	}
	return n
}

func (m *Transaction) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Payload)
	if l > 0 {
		n += 1 + l + sovTransaction(uint64(l))
	}
	if len(m.Approvals) > 0 {
		for _, e := range m.Approvals {
			l = e.Size()
			n += 1 + l + sovTransaction(uint64(l))
		}
	}
	if len(m.Extensions) > 0 {
		for k, v := range m.Extensions {
			_ = k
			_ = v
			l = 0
			if len(v) > 0 {
				l = 1 + len(v) + sovTransaction(uint64(len(v)))
			}
			mapEntrySize := 1 + len(k) + sovTransaction(uint64(len(k))) + l
			n += mapEntrySize + 1 + sovTransaction(uint64(mapEntrySize))
		}
	}
	return n
}

func (m *TxPayload) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Header != nil {
		l = m.Header.Size()
		n += 1 + l + sovTransaction(uint64(l))
	}
	l = len(m.Data)
	if l > 0 {
		n += 1 + l + sovTransaction(uint64(l))
	}
	return n
}

func (m *VoteTxData) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Handler)
	if l > 0 {
		n += 1 + l + sovTransaction(uint64(l))
	}
	l = len(m.Subject)
	if l > 0 {
		n += 1 + l + sovTransaction(uint64(l))
	}
	l = len(m.Payload)
	if l > 0 {
		n += 1 + l + sovTransaction(uint64(l))
	}
	return n
}

func (m *CertWithStatus) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Cert)
	if l > 0 {
		n += 1 + l + sovTransaction(uint64(l))
	}
	if m.Status != 0 {
		n += 1 + sovTransaction(uint64(m.Status))
	}
	return n
}

func (m *CommonTxData) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.ContractInvocation)
	if l > 0 {
		n += 1 + l + sovTransaction(uint64(l))
	}
	if m.Response != nil {
		l = m.Response.Size()
		n += 1 + l + sovTransaction(uint64(l))
	}
	if len(m.StateUpdates) > 0 {
		for _, e := range m.StateUpdates {
			l = e.Size()
			n += 1 + l + sovTransaction(uint64(l))
		}
	}
	return n
}

func (m *ContractInvocation) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.ContractName)
	if l > 0 {
		n += 1 + l + sovTransaction(uint64(l))
	}
	l = len(m.FuncName)
	if l > 0 {
		n += 1 + l + sovTransaction(uint64(l))
	}
	if len(m.Args) > 0 {
		for _, b := range m.Args {
			l = len(b)
			n += 1 + l + sovTransaction(uint64(l))
		}
	}
	l = len(m.EncryptedKey)
	if l > 0 {
		n += 1 + l + sovTransaction(uint64(l))
	}
	if m.IsCompressed {
		n += 2
	}
	return n
}

func (m *InvocationResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Status != 0 {
		n += 1 + sovTransaction(uint64(m.Status))
	}
	l = len(m.StatusInfo)
	if l > 0 {
		n += 1 + l + sovTransaction(uint64(l))
	}
	l = len(m.Payload)
	if l > 0 {
		n += 1 + l + sovTransaction(uint64(l))
	}
	return n
}

func (m *Approval) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Identity)
	if l > 0 {
		n += 1 + l + sovTransaction(uint64(l))
	}
	l = len(m.Sign)
	if l > 0 {
		n += 1 + l + sovTransaction(uint64(l))
	}
	if m.Type != 0 {
		n += 1 + sovTransaction(uint64(m.Type))
	}
	l = len(m.OrgName)
	if l > 0 {
		n += 1 + l + sovTransaction(uint64(l))
	}
	l = len(m.NodeName)
	if l > 0 {
		n += 1 + l + sovTransaction(uint64(l))
	}
	return n
}

func (m *TxResult) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.TxHash)
	if l > 0 {
		n += 1 + l + sovTransaction(uint64(l))
	}
	if m.Status != 0 {
		n += 1 + sovTransaction(uint64(m.Status))
	}
	return n
}

func (m *BlockResult) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.BlockNum != 0 {
		n += 1 + sovTransaction(uint64(m.BlockNum))
	}
	if len(m.TxResults) > 0 {
		for _, e := range m.TxResults {
			l = e.Size()
			n += 1 + l + sovTransaction(uint64(l))
		}
	}
	return n
}

func (m *KeyModification) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Value)
	if l > 0 {
		n += 1 + l + sovTransaction(uint64(l))
	}
	if m.BlockNum != 0 {
		n += 1 + sovTransaction(uint64(m.BlockNum))
	}
	if m.TxNum != 0 {
		n += 1 + sovTransaction(uint64(m.TxNum))
	}
	l = len(m.TxHash)
	if l > 0 {
		n += 1 + l + sovTransaction(uint64(l))
	}
	if m.IsDeleted {
		n += 2
	}
	if m.Timestamp != 0 {
		n += 1 + sovTransaction(uint64(m.Timestamp))
	}
	return n
}

func (m *CompactTx) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Height != 0 {
		n += 1 + sovTransaction(uint64(m.Height))
	}
	if m.Begin != 0 {
		n += 1 + sovTransaction(uint64(m.Begin))
	}
	if m.End != 0 {
		n += 1 + sovTransaction(uint64(m.End))
	}
	return n
}

func (m *Tx) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Hash)
	if l > 0 {
		n += 1 + l + sovTransaction(uint64(l))
	}
	if m.Data != nil {
		n += m.Data.Size()
	}
	return n
}

func (m *Tx_Full) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Full != nil {
		l = m.Full.Size()
		n += 1 + l + sovTransaction(uint64(l))
	}
	return n
}
func (m *Tx_Compact) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Compact != nil {
		l = m.Compact.Size()
		n += 1 + l + sovTransaction(uint64(l))
	}
	return n
}

func sovTransaction(x uint64) (n int) {
	return (math_bits.Len64(x|1) + 6) / 7
}
func sozTransaction(x uint64) (n int) {
	return sovTransaction(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (m *Identity) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTransaction
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Identity: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Identity: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Org", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTransaction
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTransaction
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTransaction
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Org = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Type", wireType)
			}
			m.Type = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTransaction
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Type |= Identity_Type(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTransaction
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthTransaction
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthTransaction
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Id = append(m.Id[:0], dAtA[iNdEx:postIndex]...)
			if m.Id == nil {
				m.Id = []byte{}
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTransaction(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTransaction
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *TxHeader) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTransaction
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: TxHeader: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: TxHeader: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Type", wireType)
			}
			m.Type = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTransaction
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Type |= TxType(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ChainId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTransaction
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTransaction
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTransaction
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ChainId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Creator", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTransaction
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTransaction
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTransaction
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Creator == nil {
				m.Creator = &Identity{}
			}
			if err := m.Creator.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Timestamp", wireType)
			}
			m.Timestamp = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTransaction
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Timestamp |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Nonce", wireType)
			}
			m.Nonce = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTransaction
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Nonce |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field LatestBlock", wireType)
			}
			m.LatestBlock = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTransaction
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.LatestBlock |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Domains", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTransaction
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTransaction
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTransaction
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Domains = append(m.Domains, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Version", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTransaction
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTransaction
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTransaction
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Version = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTransaction(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTransaction
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Transaction) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTransaction
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Transaction: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Transaction: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Payload", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTransaction
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthTransaction
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthTransaction
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Payload = append(m.Payload[:0], dAtA[iNdEx:postIndex]...)
			if m.Payload == nil {
				m.Payload = []byte{}
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Approvals", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTransaction
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTransaction
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTransaction
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Approvals = append(m.Approvals, &Approval{})
			if err := m.Approvals[len(m.Approvals)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Extensions", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTransaction
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTransaction
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTransaction
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Extensions == nil {
				m.Extensions = make(map[string][]byte)
			}
			var mapkey string
			mapvalue := []byte{}
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowTransaction
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					var stringLenmapkey uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowTransaction
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapkey |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapkey := int(stringLenmapkey)
					if intStringLenmapkey < 0 {
						return ErrInvalidLengthTransaction
					}
					postStringIndexmapkey := iNdEx + intStringLenmapkey
					if postStringIndexmapkey < 0 {
						return ErrInvalidLengthTransaction
					}
					if postStringIndexmapkey > l {
						return io.ErrUnexpectedEOF
					}
					mapkey = string(dAtA[iNdEx:postStringIndexmapkey])
					iNdEx = postStringIndexmapkey
				} else if fieldNum == 2 {
					var mapbyteLen uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowTransaction
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapbyteLen |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intMapbyteLen := int(mapbyteLen)
					if intMapbyteLen < 0 {
						return ErrInvalidLengthTransaction
					}
					postbytesIndex := iNdEx + intMapbyteLen
					if postbytesIndex < 0 {
						return ErrInvalidLengthTransaction
					}
					if postbytesIndex > l {
						return io.ErrUnexpectedEOF
					}
					mapvalue = make([]byte, mapbyteLen)
					copy(mapvalue, dAtA[iNdEx:postbytesIndex])
					iNdEx = postbytesIndex
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipTransaction(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if (skippy < 0) || (iNdEx+skippy) < 0 {
						return ErrInvalidLengthTransaction
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.Extensions[mapkey] = mapvalue
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTransaction(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTransaction
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *TxPayload) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTransaction
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: TxPayload: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: TxPayload: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Header", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTransaction
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTransaction
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTransaction
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Header == nil {
				m.Header = &TxHeader{}
			}
			if err := m.Header.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Data", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTransaction
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthTransaction
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthTransaction
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Data = append(m.Data[:0], dAtA[iNdEx:postIndex]...)
			if m.Data == nil {
				m.Data = []byte{}
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTransaction(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTransaction
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *VoteTxData) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTransaction
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: VoteTxData: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: VoteTxData: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Handler", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTransaction
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTransaction
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTransaction
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Handler = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Subject", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTransaction
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTransaction
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTransaction
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Subject = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Payload", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTransaction
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthTransaction
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthTransaction
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Payload = append(m.Payload[:0], dAtA[iNdEx:postIndex]...)
			if m.Payload == nil {
				m.Payload = []byte{}
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTransaction(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTransaction
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CertWithStatus) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTransaction
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CertWithStatus: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CertWithStatus: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Cert", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTransaction
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthTransaction
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthTransaction
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Cert = append(m.Cert[:0], dAtA[iNdEx:postIndex]...)
			if m.Cert == nil {
				m.Cert = []byte{}
			}
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Status", wireType)
			}
			m.Status = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTransaction
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Status |= CertStatus(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipTransaction(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTransaction
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CommonTxData) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTransaction
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CommonTxData: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CommonTxData: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ContractInvocation", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTransaction
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthTransaction
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthTransaction
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ContractInvocation = append(m.ContractInvocation[:0], dAtA[iNdEx:postIndex]...)
			if m.ContractInvocation == nil {
				m.ContractInvocation = []byte{}
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Response", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTransaction
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTransaction
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTransaction
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Response == nil {
				m.Response = &InvocationResponse{}
			}
			if err := m.Response.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field StateUpdates", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTransaction
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTransaction
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTransaction
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.StateUpdates = append(m.StateUpdates, &StateUpdates{})
			if err := m.StateUpdates[len(m.StateUpdates)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTransaction(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTransaction
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ContractInvocation) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTransaction
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ContractInvocation: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ContractInvocation: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ContractName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTransaction
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTransaction
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTransaction
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ContractName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field FuncName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTransaction
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTransaction
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTransaction
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.FuncName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Args", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTransaction
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthTransaction
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthTransaction
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Args = append(m.Args, make([]byte, postIndex-iNdEx))
			copy(m.Args[len(m.Args)-1], dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field EncryptedKey", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTransaction
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthTransaction
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthTransaction
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.EncryptedKey = append(m.EncryptedKey[:0], dAtA[iNdEx:postIndex]...)
			if m.EncryptedKey == nil {
				m.EncryptedKey = []byte{}
			}
			iNdEx = postIndex
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IsCompressed", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTransaction
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.IsCompressed = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipTransaction(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTransaction
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *InvocationResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTransaction
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: InvocationResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: InvocationResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Status", wireType)
			}
			m.Status = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTransaction
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Status |= Status(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field StatusInfo", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTransaction
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTransaction
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTransaction
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.StatusInfo = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Payload", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTransaction
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthTransaction
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthTransaction
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Payload = append(m.Payload[:0], dAtA[iNdEx:postIndex]...)
			if m.Payload == nil {
				m.Payload = []byte{}
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTransaction(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTransaction
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Approval) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTransaction
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Approval: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Approval: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Identity", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTransaction
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthTransaction
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthTransaction
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Identity = append(m.Identity[:0], dAtA[iNdEx:postIndex]...)
			if m.Identity == nil {
				m.Identity = []byte{}
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Sign", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTransaction
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthTransaction
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthTransaction
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Sign = append(m.Sign[:0], dAtA[iNdEx:postIndex]...)
			if m.Sign == nil {
				m.Sign = []byte{}
			}
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Type", wireType)
			}
			m.Type = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTransaction
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Type |= ContractRunEnv(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field OrgName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTransaction
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTransaction
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTransaction
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.OrgName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field NodeName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTransaction
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTransaction
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTransaction
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.NodeName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTransaction(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTransaction
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *TxResult) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTransaction
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: TxResult: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: TxResult: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TxHash", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTransaction
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthTransaction
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthTransaction
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.TxHash = append(m.TxHash[:0], dAtA[iNdEx:postIndex]...)
			if m.TxHash == nil {
				m.TxHash = []byte{}
			}
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Status", wireType)
			}
			m.Status = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTransaction
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Status |= TxStatus(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipTransaction(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTransaction
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *BlockResult) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTransaction
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: BlockResult: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: BlockResult: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field BlockNum", wireType)
			}
			m.BlockNum = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTransaction
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.BlockNum |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TxResults", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTransaction
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTransaction
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTransaction
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.TxResults = append(m.TxResults, &TxResult{})
			if err := m.TxResults[len(m.TxResults)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTransaction(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTransaction
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *KeyModification) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTransaction
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: KeyModification: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: KeyModification: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Value", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTransaction
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthTransaction
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthTransaction
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Value = append(m.Value[:0], dAtA[iNdEx:postIndex]...)
			if m.Value == nil {
				m.Value = []byte{}
			}
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field BlockNum", wireType)
			}
			m.BlockNum = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTransaction
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.BlockNum |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TxNum", wireType)
			}
			m.TxNum = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTransaction
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TxNum |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TxHash", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTransaction
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthTransaction
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthTransaction
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.TxHash = append(m.TxHash[:0], dAtA[iNdEx:postIndex]...)
			if m.TxHash == nil {
				m.TxHash = []byte{}
			}
			iNdEx = postIndex
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IsDeleted", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTransaction
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.IsDeleted = bool(v != 0)
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Timestamp", wireType)
			}
			m.Timestamp = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTransaction
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Timestamp |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipTransaction(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTransaction
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CompactTx) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTransaction
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CompactTx: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CompactTx: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Height", wireType)
			}
			m.Height = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTransaction
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Height |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Begin", wireType)
			}
			m.Begin = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTransaction
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Begin |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field End", wireType)
			}
			m.End = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTransaction
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.End |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipTransaction(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTransaction
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Tx) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTransaction
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Tx: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Tx: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Hash", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTransaction
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthTransaction
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthTransaction
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Hash = append(m.Hash[:0], dAtA[iNdEx:postIndex]...)
			if m.Hash == nil {
				m.Hash = []byte{}
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Full", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTransaction
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTransaction
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTransaction
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &Transaction{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Data = &Tx_Full{v}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Compact", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTransaction
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTransaction
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTransaction
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &CompactTx{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Data = &Tx_Compact{v}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTransaction(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTransaction
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipTransaction(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	depth := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowTransaction
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowTransaction
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
		case 1:
			iNdEx += 8
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowTransaction
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if length < 0 {
				return 0, ErrInvalidLengthTransaction
			}
			iNdEx += length
		case 3:
			depth++
		case 4:
			if depth == 0 {
				return 0, ErrUnexpectedEndOfGroupTransaction
			}
			depth--
		case 5:
			iNdEx += 4
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
		if iNdEx < 0 {
			return 0, ErrInvalidLengthTransaction
		}
		if depth == 0 {
			return iNdEx, nil
		}
	}
	return 0, io.ErrUnexpectedEOF
}

var (
	ErrInvalidLengthTransaction        = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowTransaction          = fmt.Errorf("proto: integer overflow")
	ErrUnexpectedEndOfGroupTransaction = fmt.Errorf("proto: unexpected end of group")
)
