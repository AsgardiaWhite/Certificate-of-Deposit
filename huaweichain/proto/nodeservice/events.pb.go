// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: nodeservice/events.proto

package nodeservice

import (
	context "context"
	fmt "fmt"
	common "git.huawei.com/huaweichain/proto/common"
	_ "github.com/gogo/protobuf/gogoproto"
	proto "github.com/gogo/protobuf/proto"
	grpc "google.golang.org/grpc"
	codes "google.golang.org/grpc/codes"
	status "google.golang.org/grpc/status"
	io "io"
	math "math"
	math_bits "math/bits"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.GoGoProtoPackageIsVersion3 // please upgrade the proto package

type StartPointType int32

const (
	LATEST   StartPointType = 0
	SPECIFIC StartPointType = 1
)

var StartPointType_name = map[int32]string{
	0: "LATEST",
	1: "SPECIFIC",
}

var StartPointType_value = map[string]int32{
	"LATEST":   0,
	"SPECIFIC": 1,
}

func (x StartPointType) String() string {
	return proto.EnumName(StartPointType_name, int32(x))
}

func (StartPointType) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_40a84cbc01fd046d, []int{0}
}

type TxEventType int32

const (
	REGISTER_CLIENT  TxEventType = 0
	REGISTER_TX_HASH TxEventType = 1
)

var TxEventType_name = map[int32]string{
	0: "REGISTER_CLIENT",
	1: "REGISTER_TX_HASH",
}

var TxEventType_value = map[string]int32{
	"REGISTER_CLIENT":  0,
	"REGISTER_TX_HASH": 1,
}

func (x TxEventType) String() string {
	return proto.EnumName(TxEventType_name, int32(x))
}

func (TxEventType) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_40a84cbc01fd046d, []int{1}
}

type TxEventStatus int32

const (
	SUCCESS   TxEventStatus = 0
	FAILED    TxEventStatus = 1
	COMPLETED TxEventStatus = 2
)

var TxEventStatus_name = map[int32]string{
	0: "SUCCESS",
	1: "FAILED",
	2: "COMPLETED",
}

var TxEventStatus_value = map[string]int32{
	"SUCCESS":   0,
	"FAILED":    1,
	"COMPLETED": 2,
}

func (x TxEventStatus) String() string {
	return proto.EnumName(TxEventStatus_name, int32(x))
}

func (TxEventStatus) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_40a84cbc01fd046d, []int{2}
}

type EventStartPoint struct {
	ChainId  string         `protobuf:"bytes,1,opt,name=chain_id,json=chainId,proto3" json:"chain_id,omitempty"`
	Type     StartPointType `protobuf:"varint,2,opt,name=type,proto3,enum=nodeservice.StartPointType" json:"type,omitempty"`
	BlockNum uint64         `protobuf:"varint,3,opt,name=blockNum,proto3" json:"blockNum,omitempty"`
}

func (m *EventStartPoint) Reset()         { *m = EventStartPoint{} }
func (m *EventStartPoint) String() string { return proto.CompactTextString(m) }
func (*EventStartPoint) ProtoMessage()    {}
func (*EventStartPoint) Descriptor() ([]byte, []int) {
	return fileDescriptor_40a84cbc01fd046d, []int{0}
}
func (m *EventStartPoint) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *EventStartPoint) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_EventStartPoint.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *EventStartPoint) XXX_Merge(src proto.Message) {
	xxx_messageInfo_EventStartPoint.Merge(m, src)
}
func (m *EventStartPoint) XXX_Size() int {
	return m.Size()
}
func (m *EventStartPoint) XXX_DiscardUnknown() {
	xxx_messageInfo_EventStartPoint.DiscardUnknown(m)
}

var xxx_messageInfo_EventStartPoint proto.InternalMessageInfo

type TxEvent struct {
	ChainId string      `protobuf:"bytes,1,opt,name=chain_id,json=chainId,proto3" json:"chain_id,omitempty"`
	TxHash  []byte      `protobuf:"bytes,2,opt,name=tx_hash,json=txHash,proto3" json:"tx_hash,omitempty"`
	Type    TxEventType `protobuf:"varint,3,opt,name=type,proto3,enum=nodeservice.TxEventType" json:"type,omitempty"`
}

func (m *TxEvent) Reset()         { *m = TxEvent{} }
func (m *TxEvent) String() string { return proto.CompactTextString(m) }
func (*TxEvent) ProtoMessage()    {}
func (*TxEvent) Descriptor() ([]byte, []int) {
	return fileDescriptor_40a84cbc01fd046d, []int{1}
}
func (m *TxEvent) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *TxEvent) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_TxEvent.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *TxEvent) XXX_Merge(src proto.Message) {
	xxx_messageInfo_TxEvent.Merge(m, src)
}
func (m *TxEvent) XXX_Size() int {
	return m.Size()
}
func (m *TxEvent) XXX_DiscardUnknown() {
	xxx_messageInfo_TxEvent.DiscardUnknown(m)
}

var xxx_messageInfo_TxEvent proto.InternalMessageInfo

type TxEventRes struct {
	Status  TxEventStatus `protobuf:"varint,1,opt,name=status,proto3,enum=nodeservice.TxEventStatus" json:"status,omitempty"`
	Type    TxEventType   `protobuf:"varint,2,opt,name=type,proto3,enum=nodeservice.TxEventType" json:"type,omitempty"`
	Info    string        `protobuf:"bytes,3,opt,name=info,proto3" json:"info,omitempty"`
	Payload []byte        `protobuf:"bytes,4,opt,name=payload,proto3" json:"payload,omitempty"`
}

func (m *TxEventRes) Reset()         { *m = TxEventRes{} }
func (m *TxEventRes) String() string { return proto.CompactTextString(m) }
func (*TxEventRes) ProtoMessage()    {}
func (*TxEventRes) Descriptor() ([]byte, []int) {
	return fileDescriptor_40a84cbc01fd046d, []int{2}
}
func (m *TxEventRes) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *TxEventRes) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_TxEventRes.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *TxEventRes) XXX_Merge(src proto.Message) {
	xxx_messageInfo_TxEventRes.Merge(m, src)
}
func (m *TxEventRes) XXX_Size() int {
	return m.Size()
}
func (m *TxEventRes) XXX_DiscardUnknown() {
	xxx_messageInfo_TxEventRes.DiscardUnknown(m)
}

var xxx_messageInfo_TxEventRes proto.InternalMessageInfo

func init() {
	proto.RegisterEnum("nodeservice.StartPointType", StartPointType_name, StartPointType_value)
	proto.RegisterEnum("nodeservice.TxEventType", TxEventType_name, TxEventType_value)
	proto.RegisterEnum("nodeservice.TxEventStatus", TxEventStatus_name, TxEventStatus_value)
	proto.RegisterType((*EventStartPoint)(nil), "nodeservice.EventStartPoint")
	proto.RegisterType((*TxEvent)(nil), "nodeservice.TxEvent")
	proto.RegisterType((*TxEventRes)(nil), "nodeservice.TxEventRes")
}

func init() { proto.RegisterFile("nodeservice/events.proto", fileDescriptor_40a84cbc01fd046d) }

var fileDescriptor_40a84cbc01fd046d = []byte{
	// 572 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0x9c, 0x54, 0xcb, 0x6e, 0xda, 0x4c,
	0x14, 0xf6, 0x10, 0x04, 0xc9, 0xc9, 0xcd, 0x9a, 0xe4, 0xd7, 0xef, 0x12, 0xc9, 0x8a, 0x58, 0x21,
	0x54, 0xd9, 0x11, 0x5d, 0xb4, 0xea, 0xa6, 0x25, 0x8e, 0xd3, 0x58, 0x22, 0x69, 0x34, 0x76, 0xa5,
	0xaa, 0x1b, 0xe4, 0x98, 0x29, 0xb6, 0x12, 0x7b, 0x90, 0x67, 0x08, 0xf0, 0x02, 0x5d, 0xf7, 0x01,
	0xfa, 0x40, 0x59, 0xb2, 0xec, 0xb2, 0x81, 0x3e, 0x48, 0xc5, 0x18, 0x88, 0x91, 0xa2, 0x2a, 0xe9,
	0x6e, 0xce, 0xc7, 0xf9, 0x2e, 0x87, 0x39, 0x63, 0xd0, 0x12, 0xd6, 0xa1, 0x9c, 0xa6, 0xb7, 0x51,
	0x40, 0x4d, 0x7a, 0x4b, 0x13, 0xc1, 0x8d, 0x5e, 0xca, 0x04, 0xc3, 0x9b, 0xb9, 0x5f, 0x2a, 0xfb,
	0x5d, 0xd6, 0x65, 0x12, 0x37, 0x67, 0xa7, 0xac, 0xa5, 0xb2, 0x1f, 0xb0, 0x38, 0x66, 0x89, 0x19,
	0x53, 0xce, 0xfd, 0x2e, 0xcd, 0xd0, 0xea, 0x08, 0x76, 0xed, 0x99, 0x90, 0x2b, 0xfc, 0x54, 0x5c,
	0xb2, 0x28, 0x11, 0xf8, 0x05, 0xac, 0x07, 0xa1, 0x1f, 0x25, 0xed, 0xa8, 0xa3, 0xa1, 0x43, 0x54,
	0xdb, 0x20, 0x65, 0x59, 0x3b, 0x1d, 0x6c, 0x42, 0x51, 0x8c, 0x7a, 0x54, 0x2b, 0x1c, 0xa2, 0xda,
	0x4e, 0xe3, 0xc0, 0xc8, 0xb9, 0x1a, 0x0f, 0x0a, 0xde, 0xa8, 0x47, 0x89, 0x6c, 0xc4, 0x15, 0x58,
	0xbf, 0xba, 0x61, 0xc1, 0xf5, 0x45, 0x3f, 0xd6, 0xd6, 0x0e, 0x51, 0xad, 0x48, 0x96, 0x75, 0xf5,
	0x1a, 0xca, 0xde, 0x50, 0x9a, 0xff, 0xcd, 0xf2, 0x7f, 0x28, 0x8b, 0x61, 0x3b, 0xf4, 0x79, 0x28,
	0x5d, 0xb7, 0x48, 0x49, 0x0c, 0xcf, 0x7c, 0x1e, 0xe2, 0x97, 0xf3, 0x2c, 0x6b, 0x32, 0x8b, 0xb6,
	0x92, 0x65, 0xae, 0xfb, 0x10, 0xa4, 0xfa, 0x03, 0x01, 0xcc, 0x51, 0x42, 0x39, 0x6e, 0x40, 0x89,
	0x0b, 0x5f, 0xf4, 0xb9, 0xb4, 0xdb, 0x69, 0x54, 0x1e, 0xa3, 0xbb, 0xb2, 0x83, 0xcc, 0x3b, 0x97,
	0x86, 0x85, 0xa7, 0x18, 0x62, 0x0c, 0xc5, 0x28, 0xf9, 0xca, 0x64, 0xbc, 0x0d, 0x22, 0xcf, 0x58,
	0x83, 0x72, 0xcf, 0x1f, 0xdd, 0x30, 0xbf, 0xa3, 0x15, 0xe5, 0x2c, 0x8b, 0xb2, 0x5e, 0x87, 0x9d,
	0xd5, 0xff, 0x0f, 0x03, 0x94, 0x5a, 0x4d, 0xcf, 0x76, 0x3d, 0x55, 0xc1, 0x5b, 0xb0, 0xee, 0x5e,
	0xda, 0x96, 0x73, 0xea, 0x58, 0x2a, 0xaa, 0xbf, 0x81, 0xcd, 0x9c, 0x1d, 0xde, 0x83, 0x5d, 0x62,
	0x7f, 0x70, 0x5c, 0xcf, 0x26, 0x6d, 0xab, 0xe5, 0xd8, 0x17, 0x33, 0xc6, 0x3e, 0xa8, 0x4b, 0xd0,
	0xfb, 0xdc, 0x3e, 0x6b, 0xba, 0x67, 0x2a, 0xaa, 0xbf, 0x86, 0xed, 0x95, 0xd1, 0xf0, 0x26, 0x94,
	0xdd, 0x4f, 0x96, 0x65, 0xbb, 0xae, 0xaa, 0xcc, 0x1c, 0x4f, 0x9b, 0x4e, 0xcb, 0x3e, 0x51, 0x11,
	0xde, 0x86, 0x0d, 0xeb, 0xe3, 0xf9, 0x65, 0xcb, 0xf6, 0xec, 0x13, 0xb5, 0xd0, 0xf8, 0x5d, 0x80,
	0xad, 0x8c, 0x97, 0xcd, 0x8b, 0xdf, 0x03, 0x26, 0xb4, 0x1b, 0x71, 0x41, 0xd3, 0xe3, 0xd9, 0x7d,
	0x66, 0xd7, 0x88, 0x8d, 0x6c, 0xc7, 0x0c, 0xe2, 0x0f, 0xce, 0xb3, 0x35, 0xab, 0x3c, 0x82, 0x55,
	0x95, 0x23, 0x84, 0x9b, 0xb0, 0xb7, 0x50, 0x20, 0x94, 0xf7, 0x6f, 0xc4, 0xf3, 0x25, 0x1c, 0x38,
	0x58, 0x09, 0xd1, 0x4c, 0x3a, 0xff, 0x2a, 0x65, 0xc1, 0x7f, 0x2b, 0x52, 0x17, 0xfd, 0xf8, 0xf9,
	0x22, 0xef, 0x60, 0x77, 0x21, 0xb2, 0x58, 0xec, 0x27, 0xd3, 0x6b, 0xe8, 0x08, 0x1d, 0x7f, 0x43,
	0x77, 0xf7, 0xba, 0x32, 0xbe, 0xd7, 0x95, 0xbb, 0x89, 0x8e, 0xc6, 0x13, 0x1d, 0xfd, 0x9a, 0xe8,
	0xe8, 0xfb, 0x54, 0x57, 0xc6, 0x53, 0x5d, 0xf9, 0x39, 0xd5, 0x15, 0xa8, 0x05, 0x2c, 0x36, 0xc2,
	0xbe, 0x3f, 0xa0, 0x91, 0x31, 0x88, 0x68, 0x42, 0x53, 0xf9, 0x50, 0xb2, 0xd7, 0x9c, 0x5f, 0xc9,
	0x2f, 0x6f, 0xbb, 0x91, 0x58, 0x74, 0x06, 0x2c, 0x36, 0x7b, 0x2c, 0xe2, 0x9c, 0x25, 0x9c, 0xfa,
	0x69, 0x10, 0x9a, 0x39, 0xae, 0x99, 0x7d, 0x2a, 0x72, 0xdc, 0xab, 0x92, 0x84, 0x5e, 0xfd, 0x09,
	0x00, 0x00, 0xff, 0xff, 0xe9, 0xc2, 0x66, 0x9a, 0x71, 0x04, 0x00, 0x00,
}

// Reference imports to suppress errors if they are not otherwise used.
var _ context.Context
var _ grpc.ClientConn

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
const _ = grpc.SupportPackageIsVersion4

// EventServiceClient is the client API for EventService service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://godoc.org/google.golang.org/grpc#ClientConn.NewStream.
type EventServiceClient interface {
	// register a block event to retrieve blocks in an iterator way.
	// The payload of RawMessage in request is EventStartPoint. The payload
	// in return is Response in message.proto and the payload in Response
	// is block.
	RegisterBlockEvent(ctx context.Context, in *common.RawMessage, opts ...grpc.CallOption) (EventService_RegisterBlockEventClient, error)
	// register a block event to retrieve blocks in an iterator way.
	// The payload of RawMessage in request is EventStartPoint. The payload
	// in return is Response in message.proto and the payload in Response
	// is BlockResult.
	RegisterResultEvent(ctx context.Context, in *common.RawMessage, opts ...grpc.CallOption) (EventService_RegisterResultEventClient, error)
	// register a block and result event to retrieve both blocks and results in an iterator way.
	// The payload of RawMessage in request is EventStartPoint. The payload
	// in return is Response in message.proto and the payload in Response
	// is BlockAndResult.
	RegisterBlockAndResultEvent(ctx context.Context, in *common.RawMessage, opts ...grpc.CallOption) (EventService_RegisterBlockAndResultEventClient, error)
	RegisterBlockNumEvent(ctx context.Context, in *common.RawMessage, opts ...grpc.CallOption) (EventService_RegisterBlockNumEventClient, error)
	// register a tx event to register transaction id to wnode and retrieve transaction state.
	// The payload of RawMessage in request is transaction id. The payload
	// in return is Response in message.proto and the payload in Response
	// is TxResult.
	RegisterTxEvent(ctx context.Context, opts ...grpc.CallOption) (EventService_RegisterTxEventClient, error)
}

type eventServiceClient struct {
	cc *grpc.ClientConn
}

func NewEventServiceClient(cc *grpc.ClientConn) EventServiceClient {
	return &eventServiceClient{cc}
}

func (c *eventServiceClient) RegisterBlockEvent(ctx context.Context, in *common.RawMessage, opts ...grpc.CallOption) (EventService_RegisterBlockEventClient, error) {
	stream, err := c.cc.NewStream(ctx, &_EventService_serviceDesc.Streams[0], "/nodeservice.EventService/RegisterBlockEvent", opts...)
	if err != nil {
		return nil, err
	}
	x := &eventServiceRegisterBlockEventClient{stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

type EventService_RegisterBlockEventClient interface {
	Recv() (*common.RawMessage, error)
	grpc.ClientStream
}

type eventServiceRegisterBlockEventClient struct {
	grpc.ClientStream
}

func (x *eventServiceRegisterBlockEventClient) Recv() (*common.RawMessage, error) {
	m := new(common.RawMessage)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *eventServiceClient) RegisterResultEvent(ctx context.Context, in *common.RawMessage, opts ...grpc.CallOption) (EventService_RegisterResultEventClient, error) {
	stream, err := c.cc.NewStream(ctx, &_EventService_serviceDesc.Streams[1], "/nodeservice.EventService/RegisterResultEvent", opts...)
	if err != nil {
		return nil, err
	}
	x := &eventServiceRegisterResultEventClient{stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

type EventService_RegisterResultEventClient interface {
	Recv() (*common.RawMessage, error)
	grpc.ClientStream
}

type eventServiceRegisterResultEventClient struct {
	grpc.ClientStream
}

func (x *eventServiceRegisterResultEventClient) Recv() (*common.RawMessage, error) {
	m := new(common.RawMessage)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *eventServiceClient) RegisterBlockAndResultEvent(ctx context.Context, in *common.RawMessage, opts ...grpc.CallOption) (EventService_RegisterBlockAndResultEventClient, error) {
	stream, err := c.cc.NewStream(ctx, &_EventService_serviceDesc.Streams[2], "/nodeservice.EventService/RegisterBlockAndResultEvent", opts...)
	if err != nil {
		return nil, err
	}
	x := &eventServiceRegisterBlockAndResultEventClient{stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

type EventService_RegisterBlockAndResultEventClient interface {
	Recv() (*common.RawMessage, error)
	grpc.ClientStream
}

type eventServiceRegisterBlockAndResultEventClient struct {
	grpc.ClientStream
}

func (x *eventServiceRegisterBlockAndResultEventClient) Recv() (*common.RawMessage, error) {
	m := new(common.RawMessage)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *eventServiceClient) RegisterBlockNumEvent(ctx context.Context, in *common.RawMessage, opts ...grpc.CallOption) (EventService_RegisterBlockNumEventClient, error) {
	stream, err := c.cc.NewStream(ctx, &_EventService_serviceDesc.Streams[3], "/nodeservice.EventService/RegisterBlockNumEvent", opts...)
	if err != nil {
		return nil, err
	}
	x := &eventServiceRegisterBlockNumEventClient{stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

type EventService_RegisterBlockNumEventClient interface {
	Recv() (*common.RawMessage, error)
	grpc.ClientStream
}

type eventServiceRegisterBlockNumEventClient struct {
	grpc.ClientStream
}

func (x *eventServiceRegisterBlockNumEventClient) Recv() (*common.RawMessage, error) {
	m := new(common.RawMessage)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *eventServiceClient) RegisterTxEvent(ctx context.Context, opts ...grpc.CallOption) (EventService_RegisterTxEventClient, error) {
	stream, err := c.cc.NewStream(ctx, &_EventService_serviceDesc.Streams[4], "/nodeservice.EventService/RegisterTxEvent", opts...)
	if err != nil {
		return nil, err
	}
	x := &eventServiceRegisterTxEventClient{stream}
	return x, nil
}

type EventService_RegisterTxEventClient interface {
	Send(*common.RawMessage) error
	Recv() (*common.RawMessage, error)
	grpc.ClientStream
}

type eventServiceRegisterTxEventClient struct {
	grpc.ClientStream
}

func (x *eventServiceRegisterTxEventClient) Send(m *common.RawMessage) error {
	return x.ClientStream.SendMsg(m)
}

func (x *eventServiceRegisterTxEventClient) Recv() (*common.RawMessage, error) {
	m := new(common.RawMessage)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

// EventServiceServer is the server API for EventService service.
type EventServiceServer interface {
	// register a block event to retrieve blocks in an iterator way.
	// The payload of RawMessage in request is EventStartPoint. The payload
	// in return is Response in message.proto and the payload in Response
	// is block.
	RegisterBlockEvent(*common.RawMessage, EventService_RegisterBlockEventServer) error
	// register a block event to retrieve blocks in an iterator way.
	// The payload of RawMessage in request is EventStartPoint. The payload
	// in return is Response in message.proto and the payload in Response
	// is BlockResult.
	RegisterResultEvent(*common.RawMessage, EventService_RegisterResultEventServer) error
	// register a block and result event to retrieve both blocks and results in an iterator way.
	// The payload of RawMessage in request is EventStartPoint. The payload
	// in return is Response in message.proto and the payload in Response
	// is BlockAndResult.
	RegisterBlockAndResultEvent(*common.RawMessage, EventService_RegisterBlockAndResultEventServer) error
	RegisterBlockNumEvent(*common.RawMessage, EventService_RegisterBlockNumEventServer) error
	// register a tx event to register transaction id to wnode and retrieve transaction state.
	// The payload of RawMessage in request is transaction id. The payload
	// in return is Response in message.proto and the payload in Response
	// is TxResult.
	RegisterTxEvent(EventService_RegisterTxEventServer) error
}

// UnimplementedEventServiceServer can be embedded to have forward compatible implementations.
type UnimplementedEventServiceServer struct {
}

func (*UnimplementedEventServiceServer) RegisterBlockEvent(req *common.RawMessage, srv EventService_RegisterBlockEventServer) error {
	return status.Errorf(codes.Unimplemented, "method RegisterBlockEvent not implemented")
}
func (*UnimplementedEventServiceServer) RegisterResultEvent(req *common.RawMessage, srv EventService_RegisterResultEventServer) error {
	return status.Errorf(codes.Unimplemented, "method RegisterResultEvent not implemented")
}
func (*UnimplementedEventServiceServer) RegisterBlockAndResultEvent(req *common.RawMessage, srv EventService_RegisterBlockAndResultEventServer) error {
	return status.Errorf(codes.Unimplemented, "method RegisterBlockAndResultEvent not implemented")
}
func (*UnimplementedEventServiceServer) RegisterBlockNumEvent(req *common.RawMessage, srv EventService_RegisterBlockNumEventServer) error {
	return status.Errorf(codes.Unimplemented, "method RegisterBlockNumEvent not implemented")
}
func (*UnimplementedEventServiceServer) RegisterTxEvent(srv EventService_RegisterTxEventServer) error {
	return status.Errorf(codes.Unimplemented, "method RegisterTxEvent not implemented")
}

func RegisterEventServiceServer(s *grpc.Server, srv EventServiceServer) {
	s.RegisterService(&_EventService_serviceDesc, srv)
}

func _EventService_RegisterBlockEvent_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(common.RawMessage)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(EventServiceServer).RegisterBlockEvent(m, &eventServiceRegisterBlockEventServer{stream})
}

type EventService_RegisterBlockEventServer interface {
	Send(*common.RawMessage) error
	grpc.ServerStream
}

type eventServiceRegisterBlockEventServer struct {
	grpc.ServerStream
}

func (x *eventServiceRegisterBlockEventServer) Send(m *common.RawMessage) error {
	return x.ServerStream.SendMsg(m)
}

func _EventService_RegisterResultEvent_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(common.RawMessage)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(EventServiceServer).RegisterResultEvent(m, &eventServiceRegisterResultEventServer{stream})
}

type EventService_RegisterResultEventServer interface {
	Send(*common.RawMessage) error
	grpc.ServerStream
}

type eventServiceRegisterResultEventServer struct {
	grpc.ServerStream
}

func (x *eventServiceRegisterResultEventServer) Send(m *common.RawMessage) error {
	return x.ServerStream.SendMsg(m)
}

func _EventService_RegisterBlockAndResultEvent_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(common.RawMessage)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(EventServiceServer).RegisterBlockAndResultEvent(m, &eventServiceRegisterBlockAndResultEventServer{stream})
}

type EventService_RegisterBlockAndResultEventServer interface {
	Send(*common.RawMessage) error
	grpc.ServerStream
}

type eventServiceRegisterBlockAndResultEventServer struct {
	grpc.ServerStream
}

func (x *eventServiceRegisterBlockAndResultEventServer) Send(m *common.RawMessage) error {
	return x.ServerStream.SendMsg(m)
}

func _EventService_RegisterBlockNumEvent_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(common.RawMessage)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(EventServiceServer).RegisterBlockNumEvent(m, &eventServiceRegisterBlockNumEventServer{stream})
}

type EventService_RegisterBlockNumEventServer interface {
	Send(*common.RawMessage) error
	grpc.ServerStream
}

type eventServiceRegisterBlockNumEventServer struct {
	grpc.ServerStream
}

func (x *eventServiceRegisterBlockNumEventServer) Send(m *common.RawMessage) error {
	return x.ServerStream.SendMsg(m)
}

func _EventService_RegisterTxEvent_Handler(srv interface{}, stream grpc.ServerStream) error {
	return srv.(EventServiceServer).RegisterTxEvent(&eventServiceRegisterTxEventServer{stream})
}

type EventService_RegisterTxEventServer interface {
	Send(*common.RawMessage) error
	Recv() (*common.RawMessage, error)
	grpc.ServerStream
}

type eventServiceRegisterTxEventServer struct {
	grpc.ServerStream
}

func (x *eventServiceRegisterTxEventServer) Send(m *common.RawMessage) error {
	return x.ServerStream.SendMsg(m)
}

func (x *eventServiceRegisterTxEventServer) Recv() (*common.RawMessage, error) {
	m := new(common.RawMessage)
	if err := x.ServerStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

var _EventService_serviceDesc = grpc.ServiceDesc{
	ServiceName: "nodeservice.EventService",
	HandlerType: (*EventServiceServer)(nil),
	Methods:     []grpc.MethodDesc{},
	Streams: []grpc.StreamDesc{
		{
			StreamName:    "RegisterBlockEvent",
			Handler:       _EventService_RegisterBlockEvent_Handler,
			ServerStreams: true,
		},
		{
			StreamName:    "RegisterResultEvent",
			Handler:       _EventService_RegisterResultEvent_Handler,
			ServerStreams: true,
		},
		{
			StreamName:    "RegisterBlockAndResultEvent",
			Handler:       _EventService_RegisterBlockAndResultEvent_Handler,
			ServerStreams: true,
		},
		{
			StreamName:    "RegisterBlockNumEvent",
			Handler:       _EventService_RegisterBlockNumEvent_Handler,
			ServerStreams: true,
		},
		{
			StreamName:    "RegisterTxEvent",
			Handler:       _EventService_RegisterTxEvent_Handler,
			ServerStreams: true,
			ClientStreams: true,
		},
	},
	Metadata: "nodeservice/events.proto",
}

func (m *EventStartPoint) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *EventStartPoint) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *EventStartPoint) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.BlockNum != 0 {
		i = encodeVarintEvents(dAtA, i, uint64(m.BlockNum))
		i--
		dAtA[i] = 0x18
	}
	if m.Type != 0 {
		i = encodeVarintEvents(dAtA, i, uint64(m.Type))
		i--
		dAtA[i] = 0x10
	}
	if len(m.ChainId) > 0 {
		i -= len(m.ChainId)
		copy(dAtA[i:], m.ChainId)
		i = encodeVarintEvents(dAtA, i, uint64(len(m.ChainId)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *TxEvent) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *TxEvent) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *TxEvent) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Type != 0 {
		i = encodeVarintEvents(dAtA, i, uint64(m.Type))
		i--
		dAtA[i] = 0x18
	}
	if len(m.TxHash) > 0 {
		i -= len(m.TxHash)
		copy(dAtA[i:], m.TxHash)
		i = encodeVarintEvents(dAtA, i, uint64(len(m.TxHash)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.ChainId) > 0 {
		i -= len(m.ChainId)
		copy(dAtA[i:], m.ChainId)
		i = encodeVarintEvents(dAtA, i, uint64(len(m.ChainId)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *TxEventRes) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *TxEventRes) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *TxEventRes) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Payload) > 0 {
		i -= len(m.Payload)
		copy(dAtA[i:], m.Payload)
		i = encodeVarintEvents(dAtA, i, uint64(len(m.Payload)))
		i--
		dAtA[i] = 0x22
	}
	if len(m.Info) > 0 {
		i -= len(m.Info)
		copy(dAtA[i:], m.Info)
		i = encodeVarintEvents(dAtA, i, uint64(len(m.Info)))
		i--
		dAtA[i] = 0x1a
	}
	if m.Type != 0 {
		i = encodeVarintEvents(dAtA, i, uint64(m.Type))
		i--
		dAtA[i] = 0x10
	}
	if m.Status != 0 {
		i = encodeVarintEvents(dAtA, i, uint64(m.Status))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func encodeVarintEvents(dAtA []byte, offset int, v uint64) int {
	offset -= sovEvents(v)
	base := offset
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return base
}
func (m *EventStartPoint) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.ChainId)
	if l > 0 {
		n += 1 + l + sovEvents(uint64(l))
	}
	if m.Type != 0 {
		n += 1 + sovEvents(uint64(m.Type))
	}
	if m.BlockNum != 0 {
		n += 1 + sovEvents(uint64(m.BlockNum))
	}
	return n
}

func (m *TxEvent) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.ChainId)
	if l > 0 {
		n += 1 + l + sovEvents(uint64(l))
	}
	l = len(m.TxHash)
	if l > 0 {
		n += 1 + l + sovEvents(uint64(l))
	}
	if m.Type != 0 {
		n += 1 + sovEvents(uint64(m.Type))
	}
	return n
}

func (m *TxEventRes) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Status != 0 {
		n += 1 + sovEvents(uint64(m.Status))
	}
	if m.Type != 0 {
		n += 1 + sovEvents(uint64(m.Type))
	}
	l = len(m.Info)
	if l > 0 {
		n += 1 + l + sovEvents(uint64(l))
	}
	l = len(m.Payload)
	if l > 0 {
		n += 1 + l + sovEvents(uint64(l))
	}
	return n
}

func sovEvents(x uint64) (n int) {
	return (math_bits.Len64(x|1) + 6) / 7
}
func sozEvents(x uint64) (n int) {
	return sovEvents(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (m *EventStartPoint) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowEvents
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: EventStartPoint: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: EventStartPoint: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ChainId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthEvents
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthEvents
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ChainId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Type", wireType)
			}
			m.Type = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Type |= StartPointType(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field BlockNum", wireType)
			}
			m.BlockNum = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.BlockNum |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipEvents(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthEvents
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *TxEvent) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowEvents
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: TxEvent: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: TxEvent: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ChainId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthEvents
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthEvents
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ChainId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TxHash", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthEvents
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthEvents
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.TxHash = append(m.TxHash[:0], dAtA[iNdEx:postIndex]...)
			if m.TxHash == nil {
				m.TxHash = []byte{}
			}
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Type", wireType)
			}
			m.Type = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Type |= TxEventType(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipEvents(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthEvents
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *TxEventRes) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowEvents
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: TxEventRes: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: TxEventRes: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Status", wireType)
			}
			m.Status = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Status |= TxEventStatus(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Type", wireType)
			}
			m.Type = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Type |= TxEventType(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Info", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthEvents
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthEvents
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Info = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Payload", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowEvents
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthEvents
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthEvents
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Payload = append(m.Payload[:0], dAtA[iNdEx:postIndex]...)
			if m.Payload == nil {
				m.Payload = []byte{}
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipEvents(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthEvents
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipEvents(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	depth := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowEvents
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowEvents
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
		case 1:
			iNdEx += 8
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowEvents
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if length < 0 {
				return 0, ErrInvalidLengthEvents
			}
			iNdEx += length
		case 3:
			depth++
		case 4:
			if depth == 0 {
				return 0, ErrUnexpectedEndOfGroupEvents
			}
			depth--
		case 5:
			iNdEx += 4
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
		if iNdEx < 0 {
			return 0, ErrInvalidLengthEvents
		}
		if depth == 0 {
			return iNdEx, nil
		}
	}
	return 0, io.ErrUnexpectedEOF
}

var (
	ErrInvalidLengthEvents        = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowEvents          = fmt.Errorf("proto: integer overflow")
	ErrUnexpectedEndOfGroupEvents = fmt.Errorf("proto: unexpected end of group")
)
