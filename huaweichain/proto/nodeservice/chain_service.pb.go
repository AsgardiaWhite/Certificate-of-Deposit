// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: nodeservice/chain_service.proto

package nodeservice

import (
	context "context"
	fmt "fmt"
	common "git.huawei.com/huaweichain/proto/common"
	_ "github.com/gogo/protobuf/gogoproto"
	proto "github.com/gogo/protobuf/proto"
	grpc "google.golang.org/grpc"
	codes "google.golang.org/grpc/codes"
	status "google.golang.org/grpc/status"
	io "io"
	math "math"
	math_bits "math/bits"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.GoGoProtoPackageIsVersion3 // please upgrade the proto package

type ChainServiceRequest struct {
	ChainId string `protobuf:"bytes,1,opt,name=chain_id,json=chainId,proto3" json:"chain_id,omitempty"`
	// Types that are valid to be assigned to Type:
	//	*ChainServiceRequest_BlockNum
	//	*ChainServiceRequest_TxHash
	//	*ChainServiceRequest_Contract
	Type isChainServiceRequest_Type `protobuf_oneof:"type"`
}

func (m *ChainServiceRequest) Reset()         { *m = ChainServiceRequest{} }
func (m *ChainServiceRequest) String() string { return proto.CompactTextString(m) }
func (*ChainServiceRequest) ProtoMessage()    {}
func (*ChainServiceRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_62562bb2c298c53c, []int{0}
}
func (m *ChainServiceRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ChainServiceRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ChainServiceRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ChainServiceRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ChainServiceRequest.Merge(m, src)
}
func (m *ChainServiceRequest) XXX_Size() int {
	return m.Size()
}
func (m *ChainServiceRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_ChainServiceRequest.DiscardUnknown(m)
}

var xxx_messageInfo_ChainServiceRequest proto.InternalMessageInfo

type isChainServiceRequest_Type interface {
	isChainServiceRequest_Type()
	MarshalTo([]byte) (int, error)
	Size() int
}

type ChainServiceRequest_BlockNum struct {
	BlockNum uint64 `protobuf:"varint,2,opt,name=block_num,json=blockNum,proto3,oneof" json:"block_num,omitempty"`
}
type ChainServiceRequest_TxHash struct {
	TxHash []byte `protobuf:"bytes,3,opt,name=tx_hash,json=txHash,proto3,oneof" json:"tx_hash,omitempty"`
}
type ChainServiceRequest_Contract struct {
	Contract string `protobuf:"bytes,4,opt,name=contract,proto3,oneof" json:"contract,omitempty"`
}

func (*ChainServiceRequest_BlockNum) isChainServiceRequest_Type() {}
func (*ChainServiceRequest_TxHash) isChainServiceRequest_Type()   {}
func (*ChainServiceRequest_Contract) isChainServiceRequest_Type() {}

func (m *ChainServiceRequest) GetType() isChainServiceRequest_Type {
	if m != nil {
		return m.Type
	}
	return nil
}

func (m *ChainServiceRequest) GetBlockNum() uint64 {
	if x, ok := m.GetType().(*ChainServiceRequest_BlockNum); ok {
		return x.BlockNum
	}
	return 0
}

func (m *ChainServiceRequest) GetTxHash() []byte {
	if x, ok := m.GetType().(*ChainServiceRequest_TxHash); ok {
		return x.TxHash
	}
	return nil
}

func (m *ChainServiceRequest) GetContract() string {
	if x, ok := m.GetType().(*ChainServiceRequest_Contract); ok {
		return x.Contract
	}
	return ""
}

// XXX_OneofWrappers is for the internal use of the proto package.
func (*ChainServiceRequest) XXX_OneofWrappers() []interface{} {
	return []interface{}{
		(*ChainServiceRequest_BlockNum)(nil),
		(*ChainServiceRequest_TxHash)(nil),
		(*ChainServiceRequest_Contract)(nil),
	}
}

type LatestChainState struct {
	Height uint64 `protobuf:"varint,1,opt,name=height,proto3" json:"height,omitempty"`
}

func (m *LatestChainState) Reset()         { *m = LatestChainState{} }
func (m *LatestChainState) String() string { return proto.CompactTextString(m) }
func (*LatestChainState) ProtoMessage()    {}
func (*LatestChainState) Descriptor() ([]byte, []int) {
	return fileDescriptor_62562bb2c298c53c, []int{1}
}
func (m *LatestChainState) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *LatestChainState) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_LatestChainState.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *LatestChainState) XXX_Merge(src proto.Message) {
	xxx_messageInfo_LatestChainState.Merge(m, src)
}
func (m *LatestChainState) XXX_Size() int {
	return m.Size()
}
func (m *LatestChainState) XXX_DiscardUnknown() {
	xxx_messageInfo_LatestChainState.DiscardUnknown(m)
}

var xxx_messageInfo_LatestChainState proto.InternalMessageInfo

func init() {
	proto.RegisterType((*ChainServiceRequest)(nil), "nodeservice.ChainServiceRequest")
	proto.RegisterType((*LatestChainState)(nil), "nodeservice.LatestChainState")
}

func init() { proto.RegisterFile("nodeservice/chain_service.proto", fileDescriptor_62562bb2c298c53c) }

var fileDescriptor_62562bb2c298c53c = []byte{
	// 502 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0x9c, 0x94, 0xcf, 0x6e, 0xd3, 0x40,
	0x10, 0xc6, 0x6d, 0x88, 0xd2, 0x74, 0x5b, 0x44, 0xe5, 0x86, 0x92, 0x46, 0x60, 0xa2, 0x9c, 0x22,
	0x0e, 0xb6, 0x04, 0x07, 0xc4, 0x1f, 0x09, 0xe2, 0x20, 0x25, 0x95, 0x28, 0x42, 0x6e, 0x4e, 0x5c,
	0xa2, 0xed, 0x7a, 0xea, 0x5d, 0xb5, 0xde, 0x0d, 0xde, 0x71, 0xe3, 0xbc, 0x00, 0xe7, 0x4a, 0xbc,
	0x54, 0x8f, 0x39, 0x72, 0xa4, 0xc9, 0x8b, 0x20, 0xdb, 0x89, 0x6a, 0x04, 0x87, 0x9a, 0x5b, 0x66,
	0x34, 0xbf, 0x6f, 0xbf, 0x6f, 0x37, 0x1e, 0xf2, 0x4c, 0xaa, 0x00, 0x34, 0xc4, 0x97, 0x82, 0x81,
	0xcb, 0x38, 0x15, 0x72, 0xb2, 0xae, 0x9c, 0x69, 0xac, 0x50, 0x59, 0x3b, 0xa5, 0x81, 0x76, 0x33,
	0x54, 0xa1, 0xca, 0xfb, 0x6e, 0xf6, 0xab, 0x18, 0x69, 0x37, 0x99, 0x8a, 0x22, 0x25, 0xdd, 0x08,
	0xb4, 0xa6, 0xe1, 0x1a, 0xec, 0x5e, 0x99, 0x64, 0x7f, 0x90, 0x09, 0x9e, 0x14, 0xb0, 0x0f, 0xdf,
	0x12, 0xd0, 0x68, 0x1d, 0x92, 0x46, 0x71, 0x8e, 0x08, 0x5a, 0x66, 0xc7, 0xec, 0x6d, 0xfb, 0x5b,
	0x79, 0x7d, 0x14, 0x58, 0x4f, 0xc9, 0xf6, 0xe9, 0x85, 0x62, 0xe7, 0x13, 0x99, 0x44, 0xad, 0x7b,
	0x1d, 0xb3, 0x57, 0x1b, 0x19, 0x7e, 0x23, 0x6f, 0x7d, 0x4e, 0x22, 0xeb, 0x90, 0x6c, 0x61, 0x3a,
	0xe1, 0x54, 0xf3, 0xd6, 0xfd, 0x8e, 0xd9, 0xdb, 0x1d, 0x19, 0x7e, 0x1d, 0xd3, 0x11, 0xd5, 0xdc,
	0x7a, 0x42, 0x1a, 0x4c, 0x49, 0x8c, 0x29, 0xc3, 0x56, 0x2d, 0x13, 0xcd, 0xc0, 0x4d, 0xc7, 0xab,
	0x93, 0x1a, 0xce, 0xa7, 0xd0, 0x7d, 0x4e, 0xf6, 0x3e, 0x51, 0x04, 0x8d, 0x85, 0x2f, 0xa4, 0x08,
	0xd6, 0x01, 0xa9, 0x73, 0x10, 0x21, 0xc7, 0xdc, 0x4c, 0xcd, 0x5f, 0x57, 0x2f, 0x7e, 0xd4, 0xc9,
	0x6e, 0xd9, 0xbe, 0xf5, 0x9e, 0xec, 0x0f, 0x01, 0xff, 0xe2, 0x2d, 0xa7, 0x48, 0xef, 0xf8, 0x74,
	0x76, 0x5c, 0x5c, 0x40, 0xfb, 0x1f, 0xbd, 0xae, 0x61, 0xbd, 0x26, 0x0f, 0x86, 0x80, 0x5e, 0x96,
	0xc6, 0x9b, 0x67, 0x79, 0xee, 0x8e, 0x7a, 0xe4, 0x60, 0x83, 0xf6, 0x65, 0xe0, 0x83, 0x4e, 0x2e,
	0xb0, 0xaa, 0xc6, 0x2b, 0xb2, 0x33, 0x04, 0x1c, 0xa7, 0xde, 0x3c, 0xbf, 0xb1, 0xbb, 0x83, 0x45,
	0xf0, 0x71, 0xba, 0x39, 0x76, 0x9c, 0x56, 0x14, 0x78, 0x47, 0xf6, 0x6e, 0x83, 0x57, 0xa6, 0xdf,
	0x92, 0x87, 0x43, 0xc0, 0xc1, 0xfa, 0x2d, 0x8f, 0xe4, 0x99, 0xaa, 0x00, 0xf7, 0xc9, 0xa3, 0x21,
	0x60, 0x3f, 0x66, 0x5c, 0x5c, 0xc2, 0x80, 0x03, 0x3b, 0xff, 0xa2, 0x84, 0x44, 0x5d, 0x39, 0xfe,
	0x89, 0xa4, 0x53, 0xcd, 0x15, 0x1e, 0x03, 0xd2, 0x80, 0x22, 0xad, 0x20, 0xf0, 0x81, 0x34, 0x4b,
	0x1e, 0x94, 0x3c, 0x13, 0xe1, 0xc7, 0x6a, 0x0a, 0x03, 0xf2, 0xf8, 0x56, 0x21, 0xff, 0xdb, 0xfd,
	0x87, 0x8d, 0x3f, 0x44, 0xf2, 0xc7, 0xa8, 0x2e, 0xe2, 0x7d, 0x37, 0xaf, 0x6f, 0x6c, 0x63, 0x71,
	0x63, 0x1b, 0xd7, 0x4b, 0xdb, 0x5c, 0x2c, 0x6d, 0xf3, 0xd7, 0xd2, 0x36, 0xaf, 0x56, 0xb6, 0xb1,
	0x58, 0xd9, 0xc6, 0xcf, 0x95, 0x6d, 0x90, 0x1e, 0x53, 0x91, 0xc3, 0x13, 0x3a, 0x03, 0xe1, 0xcc,
	0x04, 0x48, 0x88, 0xf3, 0xcf, 0xbb, 0xd8, 0x0a, 0x4e, 0x69, 0x9b, 0x7c, 0x7d, 0x13, 0x0a, 0xdc,
	0x4c, 0x32, 0x15, 0xb9, 0x53, 0x25, 0xb4, 0x56, 0x52, 0x03, 0x8d, 0x19, 0x77, 0x4b, 0xac, 0x5b,
	0xac, 0x9c, 0x12, 0x7b, 0x5a, 0xcf, 0x5b, 0x2f, 0x7f, 0x07, 0x00, 0x00, 0xff, 0xff, 0xf7, 0x26,
	0x3a, 0xbc, 0xc0, 0x04, 0x00, 0x00,
}

// Reference imports to suppress errors if they are not otherwise used.
var _ context.Context
var _ grpc.ClientConn

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
const _ = grpc.SupportPackageIsVersion4

// ChainServiceClient is the client API for ChainService service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://godoc.org/google.golang.org/grpc#ClientConn.NewStream.
type ChainServiceClient interface {
	GetLatestChainState(ctx context.Context, in *common.RawMessage, opts ...grpc.CallOption) (*common.RawMessage, error)
	GetBlockByNum(ctx context.Context, in *common.RawMessage, opts ...grpc.CallOption) (*common.RawMessage, error)
	GetBlockAndResultByNum(ctx context.Context, in *common.RawMessage, opts ...grpc.CallOption) (*common.RawMessage, error)
	GetTxByHash(ctx context.Context, in *common.RawMessage, opts ...grpc.CallOption) (*common.RawMessage, error)
	GetTxResultByTxHash(ctx context.Context, in *common.RawMessage, opts ...grpc.CallOption) (*common.RawMessage, error)
	GetBlockByTxHash(ctx context.Context, in *common.RawMessage, opts ...grpc.CallOption) (*common.RawMessage, error)
	GetContractInfo(ctx context.Context, in *common.RawMessage, opts ...grpc.CallOption) (*common.RawMessage, error)
	GetArchiveCheckPoints(ctx context.Context, in *common.RawMessage, opts ...grpc.CallOption) (*common.RawMessage, error)
	GetSnapshotMetadata(ctx context.Context, in *common.RawMessage, opts ...grpc.CallOption) (*common.RawMessage, error)
	GetArchiveConfigData(ctx context.Context, in *common.RawMessage, opts ...grpc.CallOption) (*common.RawMessage, error)
	GetArchiveStateMetadata(ctx context.Context, in *common.RawMessage, opts ...grpc.CallOption) (*common.RawMessage, error)
	GetArchiveBlockMetadata(ctx context.Context, in *common.RawMessage, opts ...grpc.CallOption) (*common.RawMessage, error)
}

type chainServiceClient struct {
	cc *grpc.ClientConn
}

func NewChainServiceClient(cc *grpc.ClientConn) ChainServiceClient {
	return &chainServiceClient{cc}
}

func (c *chainServiceClient) GetLatestChainState(ctx context.Context, in *common.RawMessage, opts ...grpc.CallOption) (*common.RawMessage, error) {
	out := new(common.RawMessage)
	err := c.cc.Invoke(ctx, "/nodeservice.ChainService/GetLatestChainState", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *chainServiceClient) GetBlockByNum(ctx context.Context, in *common.RawMessage, opts ...grpc.CallOption) (*common.RawMessage, error) {
	out := new(common.RawMessage)
	err := c.cc.Invoke(ctx, "/nodeservice.ChainService/GetBlockByNum", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *chainServiceClient) GetBlockAndResultByNum(ctx context.Context, in *common.RawMessage, opts ...grpc.CallOption) (*common.RawMessage, error) {
	out := new(common.RawMessage)
	err := c.cc.Invoke(ctx, "/nodeservice.ChainService/GetBlockAndResultByNum", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *chainServiceClient) GetTxByHash(ctx context.Context, in *common.RawMessage, opts ...grpc.CallOption) (*common.RawMessage, error) {
	out := new(common.RawMessage)
	err := c.cc.Invoke(ctx, "/nodeservice.ChainService/GetTxByHash", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *chainServiceClient) GetTxResultByTxHash(ctx context.Context, in *common.RawMessage, opts ...grpc.CallOption) (*common.RawMessage, error) {
	out := new(common.RawMessage)
	err := c.cc.Invoke(ctx, "/nodeservice.ChainService/GetTxResultByTxHash", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *chainServiceClient) GetBlockByTxHash(ctx context.Context, in *common.RawMessage, opts ...grpc.CallOption) (*common.RawMessage, error) {
	out := new(common.RawMessage)
	err := c.cc.Invoke(ctx, "/nodeservice.ChainService/GetBlockByTxHash", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *chainServiceClient) GetContractInfo(ctx context.Context, in *common.RawMessage, opts ...grpc.CallOption) (*common.RawMessage, error) {
	out := new(common.RawMessage)
	err := c.cc.Invoke(ctx, "/nodeservice.ChainService/GetContractInfo", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *chainServiceClient) GetArchiveCheckPoints(ctx context.Context, in *common.RawMessage, opts ...grpc.CallOption) (*common.RawMessage, error) {
	out := new(common.RawMessage)
	err := c.cc.Invoke(ctx, "/nodeservice.ChainService/GetArchiveCheckPoints", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *chainServiceClient) GetSnapshotMetadata(ctx context.Context, in *common.RawMessage, opts ...grpc.CallOption) (*common.RawMessage, error) {
	out := new(common.RawMessage)
	err := c.cc.Invoke(ctx, "/nodeservice.ChainService/GetSnapshotMetadata", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *chainServiceClient) GetArchiveConfigData(ctx context.Context, in *common.RawMessage, opts ...grpc.CallOption) (*common.RawMessage, error) {
	out := new(common.RawMessage)
	err := c.cc.Invoke(ctx, "/nodeservice.ChainService/GetArchiveConfigData", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *chainServiceClient) GetArchiveStateMetadata(ctx context.Context, in *common.RawMessage, opts ...grpc.CallOption) (*common.RawMessage, error) {
	out := new(common.RawMessage)
	err := c.cc.Invoke(ctx, "/nodeservice.ChainService/GetArchiveStateMetadata", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *chainServiceClient) GetArchiveBlockMetadata(ctx context.Context, in *common.RawMessage, opts ...grpc.CallOption) (*common.RawMessage, error) {
	out := new(common.RawMessage)
	err := c.cc.Invoke(ctx, "/nodeservice.ChainService/GetArchiveBlockMetadata", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// ChainServiceServer is the server API for ChainService service.
type ChainServiceServer interface {
	GetLatestChainState(context.Context, *common.RawMessage) (*common.RawMessage, error)
	GetBlockByNum(context.Context, *common.RawMessage) (*common.RawMessage, error)
	GetBlockAndResultByNum(context.Context, *common.RawMessage) (*common.RawMessage, error)
	GetTxByHash(context.Context, *common.RawMessage) (*common.RawMessage, error)
	GetTxResultByTxHash(context.Context, *common.RawMessage) (*common.RawMessage, error)
	GetBlockByTxHash(context.Context, *common.RawMessage) (*common.RawMessage, error)
	GetContractInfo(context.Context, *common.RawMessage) (*common.RawMessage, error)
	GetArchiveCheckPoints(context.Context, *common.RawMessage) (*common.RawMessage, error)
	GetSnapshotMetadata(context.Context, *common.RawMessage) (*common.RawMessage, error)
	GetArchiveConfigData(context.Context, *common.RawMessage) (*common.RawMessage, error)
	GetArchiveStateMetadata(context.Context, *common.RawMessage) (*common.RawMessage, error)
	GetArchiveBlockMetadata(context.Context, *common.RawMessage) (*common.RawMessage, error)
}

// UnimplementedChainServiceServer can be embedded to have forward compatible implementations.
type UnimplementedChainServiceServer struct {
}

func (*UnimplementedChainServiceServer) GetLatestChainState(ctx context.Context, req *common.RawMessage) (*common.RawMessage, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetLatestChainState not implemented")
}
func (*UnimplementedChainServiceServer) GetBlockByNum(ctx context.Context, req *common.RawMessage) (*common.RawMessage, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetBlockByNum not implemented")
}
func (*UnimplementedChainServiceServer) GetBlockAndResultByNum(ctx context.Context, req *common.RawMessage) (*common.RawMessage, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetBlockAndResultByNum not implemented")
}
func (*UnimplementedChainServiceServer) GetTxByHash(ctx context.Context, req *common.RawMessage) (*common.RawMessage, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetTxByHash not implemented")
}
func (*UnimplementedChainServiceServer) GetTxResultByTxHash(ctx context.Context, req *common.RawMessage) (*common.RawMessage, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetTxResultByTxHash not implemented")
}
func (*UnimplementedChainServiceServer) GetBlockByTxHash(ctx context.Context, req *common.RawMessage) (*common.RawMessage, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetBlockByTxHash not implemented")
}
func (*UnimplementedChainServiceServer) GetContractInfo(ctx context.Context, req *common.RawMessage) (*common.RawMessage, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetContractInfo not implemented")
}
func (*UnimplementedChainServiceServer) GetArchiveCheckPoints(ctx context.Context, req *common.RawMessage) (*common.RawMessage, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetArchiveCheckPoints not implemented")
}
func (*UnimplementedChainServiceServer) GetSnapshotMetadata(ctx context.Context, req *common.RawMessage) (*common.RawMessage, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetSnapshotMetadata not implemented")
}
func (*UnimplementedChainServiceServer) GetArchiveConfigData(ctx context.Context, req *common.RawMessage) (*common.RawMessage, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetArchiveConfigData not implemented")
}
func (*UnimplementedChainServiceServer) GetArchiveStateMetadata(ctx context.Context, req *common.RawMessage) (*common.RawMessage, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetArchiveStateMetadata not implemented")
}
func (*UnimplementedChainServiceServer) GetArchiveBlockMetadata(ctx context.Context, req *common.RawMessage) (*common.RawMessage, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetArchiveBlockMetadata not implemented")
}

func RegisterChainServiceServer(s *grpc.Server, srv ChainServiceServer) {
	s.RegisterService(&_ChainService_serviceDesc, srv)
}

func _ChainService_GetLatestChainState_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(common.RawMessage)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ChainServiceServer).GetLatestChainState(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/nodeservice.ChainService/GetLatestChainState",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ChainServiceServer).GetLatestChainState(ctx, req.(*common.RawMessage))
	}
	return interceptor(ctx, in, info, handler)
}

func _ChainService_GetBlockByNum_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(common.RawMessage)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ChainServiceServer).GetBlockByNum(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/nodeservice.ChainService/GetBlockByNum",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ChainServiceServer).GetBlockByNum(ctx, req.(*common.RawMessage))
	}
	return interceptor(ctx, in, info, handler)
}

func _ChainService_GetBlockAndResultByNum_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(common.RawMessage)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ChainServiceServer).GetBlockAndResultByNum(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/nodeservice.ChainService/GetBlockAndResultByNum",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ChainServiceServer).GetBlockAndResultByNum(ctx, req.(*common.RawMessage))
	}
	return interceptor(ctx, in, info, handler)
}

func _ChainService_GetTxByHash_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(common.RawMessage)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ChainServiceServer).GetTxByHash(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/nodeservice.ChainService/GetTxByHash",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ChainServiceServer).GetTxByHash(ctx, req.(*common.RawMessage))
	}
	return interceptor(ctx, in, info, handler)
}

func _ChainService_GetTxResultByTxHash_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(common.RawMessage)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ChainServiceServer).GetTxResultByTxHash(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/nodeservice.ChainService/GetTxResultByTxHash",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ChainServiceServer).GetTxResultByTxHash(ctx, req.(*common.RawMessage))
	}
	return interceptor(ctx, in, info, handler)
}

func _ChainService_GetBlockByTxHash_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(common.RawMessage)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ChainServiceServer).GetBlockByTxHash(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/nodeservice.ChainService/GetBlockByTxHash",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ChainServiceServer).GetBlockByTxHash(ctx, req.(*common.RawMessage))
	}
	return interceptor(ctx, in, info, handler)
}

func _ChainService_GetContractInfo_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(common.RawMessage)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ChainServiceServer).GetContractInfo(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/nodeservice.ChainService/GetContractInfo",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ChainServiceServer).GetContractInfo(ctx, req.(*common.RawMessage))
	}
	return interceptor(ctx, in, info, handler)
}

func _ChainService_GetArchiveCheckPoints_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(common.RawMessage)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ChainServiceServer).GetArchiveCheckPoints(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/nodeservice.ChainService/GetArchiveCheckPoints",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ChainServiceServer).GetArchiveCheckPoints(ctx, req.(*common.RawMessage))
	}
	return interceptor(ctx, in, info, handler)
}

func _ChainService_GetSnapshotMetadata_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(common.RawMessage)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ChainServiceServer).GetSnapshotMetadata(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/nodeservice.ChainService/GetSnapshotMetadata",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ChainServiceServer).GetSnapshotMetadata(ctx, req.(*common.RawMessage))
	}
	return interceptor(ctx, in, info, handler)
}

func _ChainService_GetArchiveConfigData_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(common.RawMessage)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ChainServiceServer).GetArchiveConfigData(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/nodeservice.ChainService/GetArchiveConfigData",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ChainServiceServer).GetArchiveConfigData(ctx, req.(*common.RawMessage))
	}
	return interceptor(ctx, in, info, handler)
}

func _ChainService_GetArchiveStateMetadata_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(common.RawMessage)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ChainServiceServer).GetArchiveStateMetadata(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/nodeservice.ChainService/GetArchiveStateMetadata",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ChainServiceServer).GetArchiveStateMetadata(ctx, req.(*common.RawMessage))
	}
	return interceptor(ctx, in, info, handler)
}

func _ChainService_GetArchiveBlockMetadata_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(common.RawMessage)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ChainServiceServer).GetArchiveBlockMetadata(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/nodeservice.ChainService/GetArchiveBlockMetadata",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ChainServiceServer).GetArchiveBlockMetadata(ctx, req.(*common.RawMessage))
	}
	return interceptor(ctx, in, info, handler)
}

var _ChainService_serviceDesc = grpc.ServiceDesc{
	ServiceName: "nodeservice.ChainService",
	HandlerType: (*ChainServiceServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "GetLatestChainState",
			Handler:    _ChainService_GetLatestChainState_Handler,
		},
		{
			MethodName: "GetBlockByNum",
			Handler:    _ChainService_GetBlockByNum_Handler,
		},
		{
			MethodName: "GetBlockAndResultByNum",
			Handler:    _ChainService_GetBlockAndResultByNum_Handler,
		},
		{
			MethodName: "GetTxByHash",
			Handler:    _ChainService_GetTxByHash_Handler,
		},
		{
			MethodName: "GetTxResultByTxHash",
			Handler:    _ChainService_GetTxResultByTxHash_Handler,
		},
		{
			MethodName: "GetBlockByTxHash",
			Handler:    _ChainService_GetBlockByTxHash_Handler,
		},
		{
			MethodName: "GetContractInfo",
			Handler:    _ChainService_GetContractInfo_Handler,
		},
		{
			MethodName: "GetArchiveCheckPoints",
			Handler:    _ChainService_GetArchiveCheckPoints_Handler,
		},
		{
			MethodName: "GetSnapshotMetadata",
			Handler:    _ChainService_GetSnapshotMetadata_Handler,
		},
		{
			MethodName: "GetArchiveConfigData",
			Handler:    _ChainService_GetArchiveConfigData_Handler,
		},
		{
			MethodName: "GetArchiveStateMetadata",
			Handler:    _ChainService_GetArchiveStateMetadata_Handler,
		},
		{
			MethodName: "GetArchiveBlockMetadata",
			Handler:    _ChainService_GetArchiveBlockMetadata_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "nodeservice/chain_service.proto",
}

func (m *ChainServiceRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ChainServiceRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ChainServiceRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Type != nil {
		{
			size := m.Type.Size()
			i -= size
			if _, err := m.Type.MarshalTo(dAtA[i:]); err != nil {
				return 0, err
			}
		}
	}
	if len(m.ChainId) > 0 {
		i -= len(m.ChainId)
		copy(dAtA[i:], m.ChainId)
		i = encodeVarintChainService(dAtA, i, uint64(len(m.ChainId)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *ChainServiceRequest_BlockNum) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ChainServiceRequest_BlockNum) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	i = encodeVarintChainService(dAtA, i, uint64(m.BlockNum))
	i--
	dAtA[i] = 0x10
	return len(dAtA) - i, nil
}
func (m *ChainServiceRequest_TxHash) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ChainServiceRequest_TxHash) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.TxHash != nil {
		i -= len(m.TxHash)
		copy(dAtA[i:], m.TxHash)
		i = encodeVarintChainService(dAtA, i, uint64(len(m.TxHash)))
		i--
		dAtA[i] = 0x1a
	}
	return len(dAtA) - i, nil
}
func (m *ChainServiceRequest_Contract) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ChainServiceRequest_Contract) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	i -= len(m.Contract)
	copy(dAtA[i:], m.Contract)
	i = encodeVarintChainService(dAtA, i, uint64(len(m.Contract)))
	i--
	dAtA[i] = 0x22
	return len(dAtA) - i, nil
}
func (m *LatestChainState) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *LatestChainState) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *LatestChainState) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Height != 0 {
		i = encodeVarintChainService(dAtA, i, uint64(m.Height))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func encodeVarintChainService(dAtA []byte, offset int, v uint64) int {
	offset -= sovChainService(v)
	base := offset
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return base
}
func (m *ChainServiceRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.ChainId)
	if l > 0 {
		n += 1 + l + sovChainService(uint64(l))
	}
	if m.Type != nil {
		n += m.Type.Size()
	}
	return n
}

func (m *ChainServiceRequest_BlockNum) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	n += 1 + sovChainService(uint64(m.BlockNum))
	return n
}
func (m *ChainServiceRequest_TxHash) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.TxHash != nil {
		l = len(m.TxHash)
		n += 1 + l + sovChainService(uint64(l))
	}
	return n
}
func (m *ChainServiceRequest_Contract) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Contract)
	n += 1 + l + sovChainService(uint64(l))
	return n
}
func (m *LatestChainState) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Height != 0 {
		n += 1 + sovChainService(uint64(m.Height))
	}
	return n
}

func sovChainService(x uint64) (n int) {
	return (math_bits.Len64(x|1) + 6) / 7
}
func sozChainService(x uint64) (n int) {
	return sovChainService(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (m *ChainServiceRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowChainService
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ChainServiceRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ChainServiceRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ChainId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowChainService
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthChainService
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthChainService
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ChainId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field BlockNum", wireType)
			}
			var v uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowChainService
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Type = &ChainServiceRequest_BlockNum{v}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TxHash", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowChainService
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthChainService
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthChainService
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := make([]byte, postIndex-iNdEx)
			copy(v, dAtA[iNdEx:postIndex])
			m.Type = &ChainServiceRequest_TxHash{v}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Contract", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowChainService
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthChainService
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthChainService
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Type = &ChainServiceRequest_Contract{string(dAtA[iNdEx:postIndex])}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipChainService(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthChainService
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *LatestChainState) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowChainService
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: LatestChainState: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: LatestChainState: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Height", wireType)
			}
			m.Height = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowChainService
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Height |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipChainService(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthChainService
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipChainService(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	depth := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowChainService
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowChainService
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
		case 1:
			iNdEx += 8
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowChainService
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if length < 0 {
				return 0, ErrInvalidLengthChainService
			}
			iNdEx += length
		case 3:
			depth++
		case 4:
			if depth == 0 {
				return 0, ErrUnexpectedEndOfGroupChainService
			}
			depth--
		case 5:
			iNdEx += 4
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
		if iNdEx < 0 {
			return 0, ErrInvalidLengthChainService
		}
		if depth == 0 {
			return iNdEx, nil
		}
	}
	return 0, io.ErrUnexpectedEOF
}

var (
	ErrInvalidLengthChainService        = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowChainService          = fmt.Errorf("proto: integer overflow")
	ErrUnexpectedEndOfGroupChainService = fmt.Errorf("proto: unexpected end of group")
)
