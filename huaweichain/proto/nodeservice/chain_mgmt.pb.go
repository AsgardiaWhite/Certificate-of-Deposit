// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: nodeservice/chain_mgmt.proto

package nodeservice

import (
	context "context"
	fmt "fmt"
	common "git.huawei.com/huaweichain/proto/common"
	_ "github.com/gogo/protobuf/gogoproto"
	proto "github.com/gogo/protobuf/proto"
	grpc "google.golang.org/grpc"
	codes "google.golang.org/grpc/codes"
	status "google.golang.org/grpc/status"
	io "io"
	math "math"
	math_bits "math/bits"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.GoGoProtoPackageIsVersion3 // please upgrade the proto package

// Chain info
type ChainInfo struct {
	Config *common.ConfigInfo `protobuf:"bytes,1,opt,name=config,proto3" json:"config,omitempty"`
}

func (m *ChainInfo) Reset()         { *m = ChainInfo{} }
func (m *ChainInfo) String() string { return proto.CompactTextString(m) }
func (*ChainInfo) ProtoMessage()    {}
func (*ChainInfo) Descriptor() ([]byte, []int) {
	return fileDescriptor_9bb0ecbb5066fb86, []int{0}
}
func (m *ChainInfo) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ChainInfo) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ChainInfo.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ChainInfo) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ChainInfo.Merge(m, src)
}
func (m *ChainInfo) XXX_Size() int {
	return m.Size()
}
func (m *ChainInfo) XXX_DiscardUnknown() {
	xxx_messageInfo_ChainInfo.DiscardUnknown(m)
}

var xxx_messageInfo_ChainInfo proto.InternalMessageInfo

type CreateInfo struct {
	GenesisBlock []byte             `protobuf:"bytes,1,opt,name=genesis_block,json=genesisBlock,proto3" json:"genesis_block,omitempty"`
	Config       *common.ConfigInfo `protobuf:"bytes,2,opt,name=config,proto3" json:"config,omitempty"`
	// serialized common.Entrypoint that is cluster information for join chain, including seed nodes, zone id, node role, etc
	Entrypoint []byte `protobuf:"bytes,3,opt,name=entrypoint,proto3" json:"entrypoint,omitempty"`
}

func (m *CreateInfo) Reset()         { *m = CreateInfo{} }
func (m *CreateInfo) String() string { return proto.CompactTextString(m) }
func (*CreateInfo) ProtoMessage()    {}
func (*CreateInfo) Descriptor() ([]byte, []int) {
	return fileDescriptor_9bb0ecbb5066fb86, []int{1}
}
func (m *CreateInfo) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *CreateInfo) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_CreateInfo.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *CreateInfo) XXX_Merge(src proto.Message) {
	xxx_messageInfo_CreateInfo.Merge(m, src)
}
func (m *CreateInfo) XXX_Size() int {
	return m.Size()
}
func (m *CreateInfo) XXX_DiscardUnknown() {
	xxx_messageInfo_CreateInfo.DiscardUnknown(m)
}

var xxx_messageInfo_CreateInfo proto.InternalMessageInfo

type DeleteInfo struct {
	ChainId string `protobuf:"bytes,1,opt,name=chain_id,json=chainId,proto3" json:"chain_id,omitempty"`
}

func (m *DeleteInfo) Reset()         { *m = DeleteInfo{} }
func (m *DeleteInfo) String() string { return proto.CompactTextString(m) }
func (*DeleteInfo) ProtoMessage()    {}
func (*DeleteInfo) Descriptor() ([]byte, []int) {
	return fileDescriptor_9bb0ecbb5066fb86, []int{2}
}
func (m *DeleteInfo) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *DeleteInfo) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_DeleteInfo.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *DeleteInfo) XXX_Merge(src proto.Message) {
	xxx_messageInfo_DeleteInfo.Merge(m, src)
}
func (m *DeleteInfo) XXX_Size() int {
	return m.Size()
}
func (m *DeleteInfo) XXX_DiscardUnknown() {
	xxx_messageInfo_DeleteInfo.DiscardUnknown(m)
}

var xxx_messageInfo_DeleteInfo proto.InternalMessageInfo

type QueryInfo struct {
	ChainId string `protobuf:"bytes,1,opt,name=chain_id,json=chainId,proto3" json:"chain_id,omitempty"`
}

func (m *QueryInfo) Reset()         { *m = QueryInfo{} }
func (m *QueryInfo) String() string { return proto.CompactTextString(m) }
func (*QueryInfo) ProtoMessage()    {}
func (*QueryInfo) Descriptor() ([]byte, []int) {
	return fileDescriptor_9bb0ecbb5066fb86, []int{3}
}
func (m *QueryInfo) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *QueryInfo) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_QueryInfo.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *QueryInfo) XXX_Merge(src proto.Message) {
	xxx_messageInfo_QueryInfo.Merge(m, src)
}
func (m *QueryInfo) XXX_Size() int {
	return m.Size()
}
func (m *QueryInfo) XXX_DiscardUnknown() {
	xxx_messageInfo_QueryInfo.DiscardUnknown(m)
}

var xxx_messageInfo_QueryInfo proto.InternalMessageInfo

type QueryInfoResponse struct {
	ChainInfo *ChainInfo `protobuf:"bytes,1,opt,name=chain_info,json=chainInfo,proto3" json:"chain_info,omitempty"`
}

func (m *QueryInfoResponse) Reset()         { *m = QueryInfoResponse{} }
func (m *QueryInfoResponse) String() string { return proto.CompactTextString(m) }
func (*QueryInfoResponse) ProtoMessage()    {}
func (*QueryInfoResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_9bb0ecbb5066fb86, []int{4}
}
func (m *QueryInfoResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *QueryInfoResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_QueryInfoResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *QueryInfoResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_QueryInfoResponse.Merge(m, src)
}
func (m *QueryInfoResponse) XXX_Size() int {
	return m.Size()
}
func (m *QueryInfoResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_QueryInfoResponse.DiscardUnknown(m)
}

var xxx_messageInfo_QueryInfoResponse proto.InternalMessageInfo

type QueryAllInfoResponse struct {
	ChainInfos []*ChainInfo `protobuf:"bytes,1,rep,name=chain_infos,json=chainInfos,proto3" json:"chain_infos,omitempty"`
}

func (m *QueryAllInfoResponse) Reset()         { *m = QueryAllInfoResponse{} }
func (m *QueryAllInfoResponse) String() string { return proto.CompactTextString(m) }
func (*QueryAllInfoResponse) ProtoMessage()    {}
func (*QueryAllInfoResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_9bb0ecbb5066fb86, []int{5}
}
func (m *QueryAllInfoResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *QueryAllInfoResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_QueryAllInfoResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *QueryAllInfoResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_QueryAllInfoResponse.Merge(m, src)
}
func (m *QueryAllInfoResponse) XXX_Size() int {
	return m.Size()
}
func (m *QueryAllInfoResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_QueryAllInfoResponse.DiscardUnknown(m)
}

var xxx_messageInfo_QueryAllInfoResponse proto.InternalMessageInfo

func init() {
	proto.RegisterType((*ChainInfo)(nil), "nodeservice.ChainInfo")
	proto.RegisterType((*CreateInfo)(nil), "nodeservice.CreateInfo")
	proto.RegisterType((*DeleteInfo)(nil), "nodeservice.DeleteInfo")
	proto.RegisterType((*QueryInfo)(nil), "nodeservice.QueryInfo")
	proto.RegisterType((*QueryInfoResponse)(nil), "nodeservice.QueryInfoResponse")
	proto.RegisterType((*QueryAllInfoResponse)(nil), "nodeservice.QueryAllInfoResponse")
}

func init() { proto.RegisterFile("nodeservice/chain_mgmt.proto", fileDescriptor_9bb0ecbb5066fb86) }

var fileDescriptor_9bb0ecbb5066fb86 = []byte{
	// 443 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0x94, 0x93, 0xc1, 0x6b, 0x13, 0x41,
	0x14, 0xc6, 0x77, 0x2c, 0x54, 0xf3, 0x12, 0x05, 0x97, 0x20, 0x69, 0x90, 0xa1, 0xac, 0xa0, 0xc5,
	0xc3, 0x2e, 0x54, 0xa4, 0xd0, 0x83, 0x60, 0xe3, 0xa5, 0x42, 0x11, 0xf7, 0xe8, 0xa5, 0x4c, 0x27,
	0x2f, 0x93, 0xc1, 0xec, 0xbc, 0x30, 0xb3, 0x35, 0xf4, 0xe0, 0xd5, 0xb3, 0x7f, 0x56, 0x8f, 0x39,
	0x7a, 0xb4, 0xc9, 0xbf, 0xe1, 0x41, 0x76, 0x66, 0xb3, 0x5d, 0x41, 0x6c, 0xbc, 0xcd, 0x7e, 0xef,
	0xfb, 0x7e, 0xc3, 0x7c, 0x33, 0x0b, 0x4f, 0x0d, 0x8d, 0xd1, 0xa1, 0xfd, 0xa2, 0x25, 0x66, 0x72,
	0x2a, 0xb4, 0x39, 0x2f, 0x54, 0x51, 0xa6, 0x73, 0x4b, 0x25, 0xc5, 0xdd, 0xd6, 0x74, 0xd8, 0x57,
	0xa4, 0xc8, 0xeb, 0x59, 0xb5, 0x0a, 0x96, 0x61, 0x5f, 0x52, 0x51, 0x90, 0xc9, 0x0a, 0x74, 0x4e,
	0x28, 0xac, 0xd5, 0xbd, 0x5a, 0x0d, 0x44, 0x49, 0x66, 0xa2, 0x55, 0x18, 0x25, 0x47, 0xd0, 0x19,
	0x55, 0xea, 0xa9, 0x99, 0x50, 0xfc, 0x12, 0x76, 0xc3, 0x70, 0xc0, 0xf6, 0xd9, 0x41, 0xf7, 0x30,
	0x4e, 0x43, 0x30, 0x1d, 0x79, 0xb5, 0xf2, 0xe4, 0xb5, 0x23, 0xf9, 0x0a, 0x30, 0xb2, 0x28, 0x4a,
	0xf4, 0xc9, 0x67, 0xf0, 0x50, 0xa1, 0x41, 0xa7, 0xdd, 0xf9, 0xc5, 0x8c, 0xe4, 0x67, 0x0f, 0xe8,
	0xe5, 0xbd, 0x5a, 0x3c, 0xa9, 0xb4, 0x16, 0xfe, 0xde, 0x5d, 0xf8, 0x98, 0x03, 0xa0, 0x29, 0xed,
	0xd5, 0x9c, 0xb4, 0x29, 0x07, 0x3b, 0x9e, 0xd6, 0x52, 0x92, 0x17, 0x00, 0xef, 0x70, 0x86, 0xf5,
	0xf6, 0x7b, 0xf0, 0x20, 0x9c, 0x4d, 0x8f, 0xfd, 0xce, 0x9d, 0xfc, 0xbe, 0xff, 0x3e, 0x1d, 0x27,
	0xcf, 0xa1, 0xf3, 0xf1, 0x12, 0xed, 0xd5, 0x5d, 0xbe, 0xf7, 0xf0, 0xb8, 0xf1, 0xe5, 0xe8, 0xe6,
	0x64, 0x1c, 0xc6, 0xaf, 0x01, 0x6a, 0xbf, 0x99, 0x50, 0x5d, 0xca, 0x93, 0xb4, 0x75, 0x0d, 0x69,
	0x53, 0x5e, 0xde, 0x91, 0x9b, 0x65, 0xf2, 0x01, 0xfa, 0x9e, 0xf5, 0x76, 0x36, 0xfb, 0x03, 0x77,
	0x04, 0xdd, 0x5b, 0x9c, 0x1b, 0xb0, 0xfd, 0x9d, 0x7f, 0xf0, 0xa0, 0xe1, 0xb9, 0xc3, 0x5f, 0x0c,
	0x7a, 0x7e, 0x72, 0x26, 0x8c, 0x50, 0x68, 0x2b, 0x52, 0x68, 0xdf, 0xab, 0x71, 0xd3, 0x64, 0x2e,
	0x16, 0x67, 0xe1, 0xea, 0x87, 0x7f, 0xd1, 0x92, 0xa8, 0x0a, 0x86, 0xde, 0xfe, 0x37, 0x78, 0x0c,
	0x8f, 0xfc, 0x99, 0x6e, 0x5f, 0xcb, 0xf6, 0xd9, 0x37, 0x10, 0x6f, 0xfa, 0x68, 0xe2, 0x6e, 0xfb,
	0xfc, 0xc9, 0x37, 0x76, 0x7d, 0xc3, 0xa3, 0xe5, 0x0d, 0x8f, 0xae, 0x57, 0x9c, 0x2d, 0x57, 0x9c,
	0xfd, 0x5c, 0x71, 0xf6, 0x7d, 0xcd, 0xa3, 0xe5, 0x9a, 0x47, 0x3f, 0xd6, 0x3c, 0x82, 0x03, 0x49,
	0x45, 0x3a, 0xbd, 0x14, 0x0b, 0xd4, 0xe9, 0x42, 0xa3, 0x41, 0xeb, 0xeb, 0x0b, 0xaf, 0xbc, 0xdd,
	0xf0, 0xa7, 0x63, 0xa5, 0xcb, 0x8d, 0x53, 0x52, 0x91, 0xcd, 0x49, 0x3b, 0x57, 0x5d, 0x8f, 0xb0,
	0x72, 0x9a, 0xb5, 0xb2, 0x59, 0xf8, 0xbb, 0x5a, 0xd9, 0x8b, 0x5d, 0x2f, 0xbd, 0xfa, 0x1d, 0x00,
	0x00, 0xff, 0xff, 0x36, 0x0d, 0xb9, 0xe7, 0xa8, 0x03, 0x00, 0x00,
}

// Reference imports to suppress errors if they are not otherwise used.
var _ context.Context
var _ grpc.ClientConn

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
const _ = grpc.SupportPackageIsVersion4

// ChainManagerClient is the client API for ChainManager service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://godoc.org/google.golang.org/grpc#ClientConn.NewStream.
type ChainManagerClient interface {
	// the payload in request RawMessage is CreateInfo and the payload
	// in return RawMessage is Response in message.proto
	CreateChain(ctx context.Context, in *common.RawMessage, opts ...grpc.CallOption) (*common.RawMessage, error)
	// the payload in request RawMessage is DeleteInfo and the payload
	// in return RawMessage is Response in message.proto
	DeleteChain(ctx context.Context, in *common.RawMessage, opts ...grpc.CallOption) (*common.RawMessage, error)
	// the payload in request RawMessage is QueryInfo and the payload
	// in return RawMessage is Response in message.proto.  The payload
	// in Response is QueryResponse.
	QueryChainInfo(ctx context.Context, in *common.RawMessage, opts ...grpc.CallOption) (*common.RawMessage, error)
	// the payload in request RawMessage is QueryInfo and the payload
	// in return RawMessage is Response in message.proto.  The payload
	// in Response is QueryResponses.
	QueryAllChainInfos(ctx context.Context, in *common.RawMessage, opts ...grpc.CallOption) (*common.RawMessage, error)
}

type chainManagerClient struct {
	cc *grpc.ClientConn
}

func NewChainManagerClient(cc *grpc.ClientConn) ChainManagerClient {
	return &chainManagerClient{cc}
}

func (c *chainManagerClient) CreateChain(ctx context.Context, in *common.RawMessage, opts ...grpc.CallOption) (*common.RawMessage, error) {
	out := new(common.RawMessage)
	err := c.cc.Invoke(ctx, "/nodeservice.ChainManager/CreateChain", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *chainManagerClient) DeleteChain(ctx context.Context, in *common.RawMessage, opts ...grpc.CallOption) (*common.RawMessage, error) {
	out := new(common.RawMessage)
	err := c.cc.Invoke(ctx, "/nodeservice.ChainManager/DeleteChain", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *chainManagerClient) QueryChainInfo(ctx context.Context, in *common.RawMessage, opts ...grpc.CallOption) (*common.RawMessage, error) {
	out := new(common.RawMessage)
	err := c.cc.Invoke(ctx, "/nodeservice.ChainManager/QueryChainInfo", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *chainManagerClient) QueryAllChainInfos(ctx context.Context, in *common.RawMessage, opts ...grpc.CallOption) (*common.RawMessage, error) {
	out := new(common.RawMessage)
	err := c.cc.Invoke(ctx, "/nodeservice.ChainManager/QueryAllChainInfos", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// ChainManagerServer is the server API for ChainManager service.
type ChainManagerServer interface {
	// the payload in request RawMessage is CreateInfo and the payload
	// in return RawMessage is Response in message.proto
	CreateChain(context.Context, *common.RawMessage) (*common.RawMessage, error)
	// the payload in request RawMessage is DeleteInfo and the payload
	// in return RawMessage is Response in message.proto
	DeleteChain(context.Context, *common.RawMessage) (*common.RawMessage, error)
	// the payload in request RawMessage is QueryInfo and the payload
	// in return RawMessage is Response in message.proto.  The payload
	// in Response is QueryResponse.
	QueryChainInfo(context.Context, *common.RawMessage) (*common.RawMessage, error)
	// the payload in request RawMessage is QueryInfo and the payload
	// in return RawMessage is Response in message.proto.  The payload
	// in Response is QueryResponses.
	QueryAllChainInfos(context.Context, *common.RawMessage) (*common.RawMessage, error)
}

// UnimplementedChainManagerServer can be embedded to have forward compatible implementations.
type UnimplementedChainManagerServer struct {
}

func (*UnimplementedChainManagerServer) CreateChain(ctx context.Context, req *common.RawMessage) (*common.RawMessage, error) {
	return nil, status.Errorf(codes.Unimplemented, "method CreateChain not implemented")
}
func (*UnimplementedChainManagerServer) DeleteChain(ctx context.Context, req *common.RawMessage) (*common.RawMessage, error) {
	return nil, status.Errorf(codes.Unimplemented, "method DeleteChain not implemented")
}
func (*UnimplementedChainManagerServer) QueryChainInfo(ctx context.Context, req *common.RawMessage) (*common.RawMessage, error) {
	return nil, status.Errorf(codes.Unimplemented, "method QueryChainInfo not implemented")
}
func (*UnimplementedChainManagerServer) QueryAllChainInfos(ctx context.Context, req *common.RawMessage) (*common.RawMessage, error) {
	return nil, status.Errorf(codes.Unimplemented, "method QueryAllChainInfos not implemented")
}

func RegisterChainManagerServer(s *grpc.Server, srv ChainManagerServer) {
	s.RegisterService(&_ChainManager_serviceDesc, srv)
}

func _ChainManager_CreateChain_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(common.RawMessage)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ChainManagerServer).CreateChain(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/nodeservice.ChainManager/CreateChain",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ChainManagerServer).CreateChain(ctx, req.(*common.RawMessage))
	}
	return interceptor(ctx, in, info, handler)
}

func _ChainManager_DeleteChain_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(common.RawMessage)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ChainManagerServer).DeleteChain(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/nodeservice.ChainManager/DeleteChain",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ChainManagerServer).DeleteChain(ctx, req.(*common.RawMessage))
	}
	return interceptor(ctx, in, info, handler)
}

func _ChainManager_QueryChainInfo_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(common.RawMessage)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ChainManagerServer).QueryChainInfo(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/nodeservice.ChainManager/QueryChainInfo",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ChainManagerServer).QueryChainInfo(ctx, req.(*common.RawMessage))
	}
	return interceptor(ctx, in, info, handler)
}

func _ChainManager_QueryAllChainInfos_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(common.RawMessage)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ChainManagerServer).QueryAllChainInfos(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/nodeservice.ChainManager/QueryAllChainInfos",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ChainManagerServer).QueryAllChainInfos(ctx, req.(*common.RawMessage))
	}
	return interceptor(ctx, in, info, handler)
}

var _ChainManager_serviceDesc = grpc.ServiceDesc{
	ServiceName: "nodeservice.ChainManager",
	HandlerType: (*ChainManagerServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "CreateChain",
			Handler:    _ChainManager_CreateChain_Handler,
		},
		{
			MethodName: "DeleteChain",
			Handler:    _ChainManager_DeleteChain_Handler,
		},
		{
			MethodName: "QueryChainInfo",
			Handler:    _ChainManager_QueryChainInfo_Handler,
		},
		{
			MethodName: "QueryAllChainInfos",
			Handler:    _ChainManager_QueryAllChainInfos_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "nodeservice/chain_mgmt.proto",
}

func (m *ChainInfo) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ChainInfo) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ChainInfo) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Config != nil {
		{
			size, err := m.Config.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintChainMgmt(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *CreateInfo) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CreateInfo) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *CreateInfo) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Entrypoint) > 0 {
		i -= len(m.Entrypoint)
		copy(dAtA[i:], m.Entrypoint)
		i = encodeVarintChainMgmt(dAtA, i, uint64(len(m.Entrypoint)))
		i--
		dAtA[i] = 0x1a
	}
	if m.Config != nil {
		{
			size, err := m.Config.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintChainMgmt(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	if len(m.GenesisBlock) > 0 {
		i -= len(m.GenesisBlock)
		copy(dAtA[i:], m.GenesisBlock)
		i = encodeVarintChainMgmt(dAtA, i, uint64(len(m.GenesisBlock)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *DeleteInfo) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *DeleteInfo) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *DeleteInfo) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.ChainId) > 0 {
		i -= len(m.ChainId)
		copy(dAtA[i:], m.ChainId)
		i = encodeVarintChainMgmt(dAtA, i, uint64(len(m.ChainId)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *QueryInfo) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *QueryInfo) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *QueryInfo) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.ChainId) > 0 {
		i -= len(m.ChainId)
		copy(dAtA[i:], m.ChainId)
		i = encodeVarintChainMgmt(dAtA, i, uint64(len(m.ChainId)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *QueryInfoResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *QueryInfoResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *QueryInfoResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.ChainInfo != nil {
		{
			size, err := m.ChainInfo.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintChainMgmt(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *QueryAllInfoResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *QueryAllInfoResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *QueryAllInfoResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.ChainInfos) > 0 {
		for iNdEx := len(m.ChainInfos) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.ChainInfos[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintChainMgmt(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func encodeVarintChainMgmt(dAtA []byte, offset int, v uint64) int {
	offset -= sovChainMgmt(v)
	base := offset
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return base
}
func (m *ChainInfo) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Config != nil {
		l = m.Config.Size()
		n += 1 + l + sovChainMgmt(uint64(l))
	}
	return n
}

func (m *CreateInfo) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.GenesisBlock)
	if l > 0 {
		n += 1 + l + sovChainMgmt(uint64(l))
	}
	if m.Config != nil {
		l = m.Config.Size()
		n += 1 + l + sovChainMgmt(uint64(l))
	}
	l = len(m.Entrypoint)
	if l > 0 {
		n += 1 + l + sovChainMgmt(uint64(l))
	}
	return n
}

func (m *DeleteInfo) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.ChainId)
	if l > 0 {
		n += 1 + l + sovChainMgmt(uint64(l))
	}
	return n
}

func (m *QueryInfo) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.ChainId)
	if l > 0 {
		n += 1 + l + sovChainMgmt(uint64(l))
	}
	return n
}

func (m *QueryInfoResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.ChainInfo != nil {
		l = m.ChainInfo.Size()
		n += 1 + l + sovChainMgmt(uint64(l))
	}
	return n
}

func (m *QueryAllInfoResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.ChainInfos) > 0 {
		for _, e := range m.ChainInfos {
			l = e.Size()
			n += 1 + l + sovChainMgmt(uint64(l))
		}
	}
	return n
}

func sovChainMgmt(x uint64) (n int) {
	return (math_bits.Len64(x|1) + 6) / 7
}
func sozChainMgmt(x uint64) (n int) {
	return sovChainMgmt(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (m *ChainInfo) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowChainMgmt
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ChainInfo: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ChainInfo: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Config", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowChainMgmt
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthChainMgmt
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthChainMgmt
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Config == nil {
				m.Config = &common.ConfigInfo{}
			}
			if err := m.Config.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipChainMgmt(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthChainMgmt
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CreateInfo) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowChainMgmt
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CreateInfo: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CreateInfo: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field GenesisBlock", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowChainMgmt
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthChainMgmt
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthChainMgmt
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.GenesisBlock = append(m.GenesisBlock[:0], dAtA[iNdEx:postIndex]...)
			if m.GenesisBlock == nil {
				m.GenesisBlock = []byte{}
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Config", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowChainMgmt
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthChainMgmt
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthChainMgmt
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Config == nil {
				m.Config = &common.ConfigInfo{}
			}
			if err := m.Config.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Entrypoint", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowChainMgmt
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthChainMgmt
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthChainMgmt
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Entrypoint = append(m.Entrypoint[:0], dAtA[iNdEx:postIndex]...)
			if m.Entrypoint == nil {
				m.Entrypoint = []byte{}
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipChainMgmt(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthChainMgmt
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *DeleteInfo) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowChainMgmt
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: DeleteInfo: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: DeleteInfo: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ChainId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowChainMgmt
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthChainMgmt
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthChainMgmt
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ChainId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipChainMgmt(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthChainMgmt
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *QueryInfo) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowChainMgmt
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: QueryInfo: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: QueryInfo: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ChainId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowChainMgmt
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthChainMgmt
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthChainMgmt
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ChainId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipChainMgmt(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthChainMgmt
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *QueryInfoResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowChainMgmt
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: QueryInfoResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: QueryInfoResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ChainInfo", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowChainMgmt
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthChainMgmt
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthChainMgmt
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.ChainInfo == nil {
				m.ChainInfo = &ChainInfo{}
			}
			if err := m.ChainInfo.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipChainMgmt(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthChainMgmt
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *QueryAllInfoResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowChainMgmt
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: QueryAllInfoResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: QueryAllInfoResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ChainInfos", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowChainMgmt
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthChainMgmt
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthChainMgmt
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ChainInfos = append(m.ChainInfos, &ChainInfo{})
			if err := m.ChainInfos[len(m.ChainInfos)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipChainMgmt(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthChainMgmt
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipChainMgmt(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	depth := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowChainMgmt
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowChainMgmt
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
		case 1:
			iNdEx += 8
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowChainMgmt
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if length < 0 {
				return 0, ErrInvalidLengthChainMgmt
			}
			iNdEx += length
		case 3:
			depth++
		case 4:
			if depth == 0 {
				return 0, ErrUnexpectedEndOfGroupChainMgmt
			}
			depth--
		case 5:
			iNdEx += 4
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
		if iNdEx < 0 {
			return 0, ErrInvalidLengthChainMgmt
		}
		if depth == 0 {
			return iNdEx, nil
		}
	}
	return 0, io.ErrUnexpectedEOF
}

var (
	ErrInvalidLengthChainMgmt        = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowChainMgmt          = fmt.Errorf("proto: integer overflow")
	ErrUnexpectedEndOfGroupChainMgmt = fmt.Errorf("proto: unexpected end of group")
)
