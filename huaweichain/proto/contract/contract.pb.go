// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: contract/contract.proto

package contract

import (
	context "context"
	fmt "fmt"
	common "git.huawei.com/huaweichain/proto/common"
	_ "github.com/gogo/protobuf/gogoproto"
	proto "github.com/gogo/protobuf/proto"
	grpc "google.golang.org/grpc"
	codes "google.golang.org/grpc/codes"
	status "google.golang.org/grpc/status"
	io "io"
	math "math"
	math_bits "math/bits"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.GoGoProtoPackageIsVersion3 // please upgrade the proto package

type ContractExtensionType int32

const (
	ContractExtension_UNDEFINED ContractExtensionType = 0
	QUERY_REQ                   ContractExtensionType = 1
	DEFINITION                  ContractExtensionType = 2
	BIN_FILE                    ContractExtensionType = 3
	SOURCE_FILE                 ContractExtensionType = 4
	TEE_ENCRYPT_PUB_KEY         ContractExtensionType = 5
	TEE_SIGN_PUB_KEY            ContractExtensionType = 6
	CLIENT_IDENTITY_CERT        ContractExtensionType = 7
	CLIENT_IDENTITY_ID          ContractExtensionType = 8
)

var ContractExtensionType_name = map[int32]string{
	0: "ContractExtension_UNDEFINED",
	1: "QUERY_REQ",
	2: "DEFINITION",
	3: "BIN_FILE",
	4: "SOURCE_FILE",
	5: "TEE_ENCRYPT_PUB_KEY",
	6: "TEE_SIGN_PUB_KEY",
	7: "CLIENT_IDENTITY_CERT",
	8: "CLIENT_IDENTITY_ID",
}

var ContractExtensionType_value = map[string]int32{
	"ContractExtension_UNDEFINED": 0,
	"QUERY_REQ":                   1,
	"DEFINITION":                  2,
	"BIN_FILE":                    3,
	"SOURCE_FILE":                 4,
	"TEE_ENCRYPT_PUB_KEY":         5,
	"TEE_SIGN_PUB_KEY":            6,
	"CLIENT_IDENTITY_CERT":        7,
	"CLIENT_IDENTITY_ID":          8,
}

func (x ContractExtensionType) String() string {
	return proto.EnumName(ContractExtensionType_name, int32(x))
}

func (ContractExtensionType) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_d5ed56110ac5207b, []int{0}
}

type ContractMsg_Type int32

const (
	UNDEFINED           ContractMsg_Type = 0
	INIT                ContractMsg_Type = 1
	INVOKE              ContractMsg_Type = 2
	GET_KV              ContractMsg_Type = 3
	PUT_KV              ContractMsg_Type = 4
	DEL_KV              ContractMsg_Type = 5
	GET_KV_BY_RANGE     ContractMsg_Type = 6
	GET_HISTORY_FOR_KEY ContractMsg_Type = 7
	SQL_INIT            ContractMsg_Type = 8
	SQL_INVOKE          ContractMsg_Type = 9
	SQL_EXEC            ContractMsg_Type = 10
	SQL_QUERY           ContractMsg_Type = 11
	INSTANCE_IDENTITY   ContractMsg_Type = 12
	GetCreator          ContractMsg_Type = 13
)

var ContractMsg_Type_name = map[int32]string{
	0:  "UNDEFINED",
	1:  "INIT",
	2:  "INVOKE",
	3:  "GET_KV",
	4:  "PUT_KV",
	5:  "DEL_KV",
	6:  "GET_KV_BY_RANGE",
	7:  "GET_HISTORY_FOR_KEY",
	8:  "SQL_INIT",
	9:  "SQL_INVOKE",
	10: "SQL_EXEC",
	11: "SQL_QUERY",
	12: "INSTANCE_IDENTITY",
	13: "GetCreator",
}

var ContractMsg_Type_value = map[string]int32{
	"UNDEFINED":           0,
	"INIT":                1,
	"INVOKE":              2,
	"GET_KV":              3,
	"PUT_KV":              4,
	"DEL_KV":              5,
	"GET_KV_BY_RANGE":     6,
	"GET_HISTORY_FOR_KEY": 7,
	"SQL_INIT":            8,
	"SQL_INVOKE":          9,
	"SQL_EXEC":            10,
	"SQL_QUERY":           11,
	"INSTANCE_IDENTITY":   12,
	"GetCreator":          13,
}

func (x ContractMsg_Type) String() string {
	return proto.EnumName(ContractMsg_Type_name, int32(x))
}

func (ContractMsg_Type) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_d5ed56110ac5207b, []int{7, 0}
}

type ContractMsg_Stage int32

const (
	HandleInvoke ContractMsg_Stage = 0
	StartInvoke  ContractMsg_Stage = 1
	EndInvoke    ContractMsg_Stage = 2
)

var ContractMsg_Stage_name = map[int32]string{
	0: "HandleInvoke",
	1: "StartInvoke",
	2: "EndInvoke",
}

var ContractMsg_Stage_value = map[string]int32{
	"HandleInvoke": 0,
	"StartInvoke":  1,
	"EndInvoke":    2,
}

func (x ContractMsg_Stage) String() string {
	return proto.EnumName(ContractMsg_Stage_name, int32(x))
}

func (ContractMsg_Stage) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_d5ed56110ac5207b, []int{7, 1}
}

type ContractDefinition struct {
	ContractName        string            `protobuf:"bytes,1,opt,name=contract_name,json=contractName,proto3" json:"contract_name,omitempty"`
	SchemaVersion       string            `protobuf:"bytes,2,opt,name=schema_version,json=schemaVersion,proto3" json:"schema_version,omitempty"`
	SequenceNumber      uint32            `protobuf:"varint,3,opt,name=sequence_number,json=sequenceNumber,proto3" json:"sequence_number,omitempty"`
	Description         string            `protobuf:"bytes,4,opt,name=description,proto3" json:"description,omitempty"`
	RequireInit         bool              `protobuf:"varint,5,opt,name=require_init,json=requireInit,proto3" json:"require_init,omitempty"`
	SqlDbSchema         string            `protobuf:"bytes,6,opt,name=sql_db_schema,json=sqlDbSchema,proto3" json:"sql_db_schema,omitempty"`
	HistorySupport      bool              `protobuf:"varint,7,opt,name=history_support,json=historySupport,proto3" json:"history_support,omitempty"`
	ApprovalValidator   string            `protobuf:"bytes,10,opt,name=approval_validator,json=approvalValidator,proto3" json:"approval_validator,omitempty"`
	ValidatorExtensions map[string][]byte `protobuf:"bytes,11,rep,name=validator_extensions,json=validatorExtensions,proto3" json:"validator_extensions,omitempty" protobuf_key:"bytes,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value,proto3"`
}

func (m *ContractDefinition) Reset()         { *m = ContractDefinition{} }
func (m *ContractDefinition) String() string { return proto.CompactTextString(m) }
func (*ContractDefinition) ProtoMessage()    {}
func (*ContractDefinition) Descriptor() ([]byte, []int) {
	return fileDescriptor_d5ed56110ac5207b, []int{0}
}
func (m *ContractDefinition) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ContractDefinition) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ContractDefinition.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ContractDefinition) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ContractDefinition.Merge(m, src)
}
func (m *ContractDefinition) XXX_Size() int {
	return m.Size()
}
func (m *ContractDefinition) XXX_DiscardUnknown() {
	xxx_messageInfo_ContractDefinition.DiscardUnknown(m)
}

var xxx_messageInfo_ContractDefinition proto.InternalMessageInfo

type DockerImageInfo struct {
	ID      string `protobuf:"bytes,1,opt,name=ID,proto3" json:"ID,omitempty"`
	RepoTag string `protobuf:"bytes,2,opt,name=repo_tag,json=repoTag,proto3" json:"repo_tag,omitempty"`
}

func (m *DockerImageInfo) Reset()         { *m = DockerImageInfo{} }
func (m *DockerImageInfo) String() string { return proto.CompactTextString(m) }
func (*DockerImageInfo) ProtoMessage()    {}
func (*DockerImageInfo) Descriptor() ([]byte, []int) {
	return fileDescriptor_d5ed56110ac5207b, []int{1}
}
func (m *DockerImageInfo) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *DockerImageInfo) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_DockerImageInfo.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *DockerImageInfo) XXX_Merge(src proto.Message) {
	xxx_messageInfo_DockerImageInfo.Merge(m, src)
}
func (m *DockerImageInfo) XXX_Size() int {
	return m.Size()
}
func (m *DockerImageInfo) XXX_DiscardUnknown() {
	xxx_messageInfo_DockerImageInfo.DiscardUnknown(m)
}

var xxx_messageInfo_DockerImageInfo proto.InternalMessageInfo

type ExternalContractInfo struct {
	SandboxType   common.ContractRunEnv `protobuf:"varint,1,opt,name=sandbox_type,json=sandboxType,proto3,enum=common.ContractRunEnv" json:"sandbox_type,omitempty"`
	SchemaVersion string                `protobuf:"bytes,2,opt,name=schema_version,json=schemaVersion,proto3" json:"schema_version,omitempty"`
	Code          []byte                `protobuf:"bytes,3,opt,name=code,proto3" json:"code,omitempty"`
	PeerCert      []byte                `protobuf:"bytes,4,opt,name=peer_cert,json=peerCert,proto3" json:"peer_cert,omitempty"`
	Extensions    map[string][]byte     `protobuf:"bytes,5,rep,name=extensions,proto3" json:"extensions,omitempty" protobuf_key:"bytes,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value,proto3"`
	Language      string                `protobuf:"bytes,6,opt,name=language,proto3" json:"language,omitempty"`
}

func (m *ExternalContractInfo) Reset()         { *m = ExternalContractInfo{} }
func (m *ExternalContractInfo) String() string { return proto.CompactTextString(m) }
func (*ExternalContractInfo) ProtoMessage()    {}
func (*ExternalContractInfo) Descriptor() ([]byte, []int) {
	return fileDescriptor_d5ed56110ac5207b, []int{2}
}
func (m *ExternalContractInfo) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ExternalContractInfo) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ExternalContractInfo.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ExternalContractInfo) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ExternalContractInfo.Merge(m, src)
}
func (m *ExternalContractInfo) XXX_Size() int {
	return m.Size()
}
func (m *ExternalContractInfo) XXX_DiscardUnknown() {
	xxx_messageInfo_ExternalContractInfo.DiscardUnknown(m)
}

var xxx_messageInfo_ExternalContractInfo proto.InternalMessageInfo

type LogRotation struct {
	Enabled    bool   `protobuf:"varint,1,opt,name=Enabled,proto3" json:"Enabled,omitempty"`
	Filename   string `protobuf:"bytes,2,opt,name=Filename,proto3" json:"Filename,omitempty"`
	MaxSize    uint32 `protobuf:"varint,3,opt,name=MaxSize,proto3" json:"MaxSize,omitempty"`
	MaxAge     uint32 `protobuf:"varint,4,opt,name=MaxAge,proto3" json:"MaxAge,omitempty"`
	MaxBackups uint32 `protobuf:"varint,5,opt,name=MaxBackups,proto3" json:"MaxBackups,omitempty"`
	LocalTime  bool   `protobuf:"varint,6,opt,name=LocalTime,proto3" json:"LocalTime,omitempty"`
	Compress   bool   `protobuf:"varint,7,opt,name=Compress,proto3" json:"Compress,omitempty"`
}

func (m *LogRotation) Reset()         { *m = LogRotation{} }
func (m *LogRotation) String() string { return proto.CompactTextString(m) }
func (*LogRotation) ProtoMessage()    {}
func (*LogRotation) Descriptor() ([]byte, []int) {
	return fileDescriptor_d5ed56110ac5207b, []int{3}
}
func (m *LogRotation) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *LogRotation) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_LogRotation.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *LogRotation) XXX_Merge(src proto.Message) {
	xxx_messageInfo_LogRotation.Merge(m, src)
}
func (m *LogRotation) XXX_Size() int {
	return m.Size()
}
func (m *LogRotation) XXX_DiscardUnknown() {
	xxx_messageInfo_LogRotation.DiscardUnknown(m)
}

var xxx_messageInfo_LogRotation proto.InternalMessageInfo

type ContractConfig struct {
	TlsConfig    *ContractTLSConfig  `protobuf:"bytes,1,opt,name=tls_config,json=tlsConfig,proto3" json:"tls_config,omitempty"`
	GrpcConfig   *ContractGRPCConfig `protobuf:"bytes,2,opt,name=grpc_config,json=grpcConfig,proto3" json:"grpc_config,omitempty"`
	Port         string              `protobuf:"bytes,3,opt,name=port,proto3" json:"port,omitempty"`
	LogLevel     string              `protobuf:"bytes,4,opt,name=log_level,json=logLevel,proto3" json:"log_level,omitempty"`
	NodeAddr     string              `protobuf:"bytes,5,opt,name=nodeAddr,proto3" json:"nodeAddr,omitempty"`
	NodeName     string              `protobuf:"bytes,6,opt,name=nodeName,proto3" json:"nodeName,omitempty"`
	ChainID      string              `protobuf:"bytes,7,opt,name=chainID,proto3" json:"chainID,omitempty"`
	ContractName string              `protobuf:"bytes,8,opt,name=contractName,proto3" json:"contractName,omitempty"`
	Extension    string              `protobuf:"bytes,9,opt,name=extension,proto3" json:"extension,omitempty"`
	Rotation     *LogRotation        `protobuf:"bytes,10,opt,name=rotation,proto3" json:"rotation,omitempty"`
}

func (m *ContractConfig) Reset()         { *m = ContractConfig{} }
func (m *ContractConfig) String() string { return proto.CompactTextString(m) }
func (*ContractConfig) ProtoMessage()    {}
func (*ContractConfig) Descriptor() ([]byte, []int) {
	return fileDescriptor_d5ed56110ac5207b, []int{4}
}
func (m *ContractConfig) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ContractConfig) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ContractConfig.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ContractConfig) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ContractConfig.Merge(m, src)
}
func (m *ContractConfig) XXX_Size() int {
	return m.Size()
}
func (m *ContractConfig) XXX_DiscardUnknown() {
	xxx_messageInfo_ContractConfig.DiscardUnknown(m)
}

var xxx_messageInfo_ContractConfig proto.InternalMessageInfo

type ContractGRPCConfig struct {
	Interval             uint32 `protobuf:"varint,1,opt,name=interval,proto3" json:"interval,omitempty"`
	Timeout              uint32 `protobuf:"varint,2,opt,name=timeout,proto3" json:"timeout,omitempty"`
	MinInterval          uint32 `protobuf:"varint,3,opt,name=minInterval,proto3" json:"minInterval,omitempty"`
	MaxConcurrentStreams uint32 `protobuf:"varint,4,opt,name=maxConcurrentStreams,proto3" json:"maxConcurrentStreams,omitempty"`
	MaxSendMsgSize       uint32 `protobuf:"varint,5,opt,name=maxSendMsgSize,proto3" json:"maxSendMsgSize,omitempty"`
	MaxRecvMsgSize       uint32 `protobuf:"varint,6,opt,name=maxRecvMsgSize,proto3" json:"maxRecvMsgSize,omitempty"`
}

func (m *ContractGRPCConfig) Reset()         { *m = ContractGRPCConfig{} }
func (m *ContractGRPCConfig) String() string { return proto.CompactTextString(m) }
func (*ContractGRPCConfig) ProtoMessage()    {}
func (*ContractGRPCConfig) Descriptor() ([]byte, []int) {
	return fileDescriptor_d5ed56110ac5207b, []int{5}
}
func (m *ContractGRPCConfig) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ContractGRPCConfig) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ContractGRPCConfig.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ContractGRPCConfig) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ContractGRPCConfig.Merge(m, src)
}
func (m *ContractGRPCConfig) XXX_Size() int {
	return m.Size()
}
func (m *ContractGRPCConfig) XXX_DiscardUnknown() {
	xxx_messageInfo_ContractGRPCConfig.DiscardUnknown(m)
}

var xxx_messageInfo_ContractGRPCConfig proto.InternalMessageInfo

type ContractTLSConfig struct {
	IsTlsEnabled      bool     `protobuf:"varint,1,opt,name=isTlsEnabled,proto3" json:"isTlsEnabled,omitempty"`
	IsMultiTls        bool     `protobuf:"varint,2,opt,name=isMultiTls,proto3" json:"isMultiTls,omitempty"`
	CertPath          string   `protobuf:"bytes,3,opt,name=cert_path,json=certPath,proto3" json:"cert_path,omitempty"`
	KeyPath           string   `protobuf:"bytes,4,opt,name=key_path,json=keyPath,proto3" json:"key_path,omitempty"`
	PeerRootcertsPath []string `protobuf:"bytes,5,rep,name=peer_rootcerts_path,json=peerRootcertsPath,proto3" json:"peer_rootcerts_path,omitempty"`
	ServerName        string   `protobuf:"bytes,6,opt,name=server_name,json=serverName,proto3" json:"server_name,omitempty"`
}

func (m *ContractTLSConfig) Reset()         { *m = ContractTLSConfig{} }
func (m *ContractTLSConfig) String() string { return proto.CompactTextString(m) }
func (*ContractTLSConfig) ProtoMessage()    {}
func (*ContractTLSConfig) Descriptor() ([]byte, []int) {
	return fileDescriptor_d5ed56110ac5207b, []int{6}
}
func (m *ContractTLSConfig) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ContractTLSConfig) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ContractTLSConfig.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ContractTLSConfig) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ContractTLSConfig.Merge(m, src)
}
func (m *ContractTLSConfig) XXX_Size() int {
	return m.Size()
}
func (m *ContractTLSConfig) XXX_DiscardUnknown() {
	xxx_messageInfo_ContractTLSConfig.DiscardUnknown(m)
}

var xxx_messageInfo_ContractTLSConfig proto.InternalMessageInfo

type ContractMsg struct {
	Stage ContractMsg_Stage `protobuf:"varint,1,opt,name=stage,proto3,enum=contract.ContractMsg_Stage" json:"stage,omitempty"`
	Type  ContractMsg_Type  `protobuf:"varint,2,opt,name=type,proto3,enum=contract.ContractMsg_Type" json:"type,omitempty"`
	// Explanation for payload:
	// when wonde call smartcontract req:ContractInvocation
	// when wonde call smartcontract response:InvocationResponse
	// when smartcontract call wnode req:GetState or PutState or DelState or GetStateByRange
	// when smartcontract call wnode response: GetState:bytes PutState:nothing DelState:nothing GetStateByRange:QueryResponse
	Payload      []byte `protobuf:"bytes,3,opt,name=payload,proto3" json:"payload,omitempty"`
	Txid         string `protobuf:"bytes,4,opt,name=txid,proto3" json:"txid,omitempty"`
	Contractid   string `protobuf:"bytes,5,opt,name=contractid,proto3" json:"contractid,omitempty"`
	Chainid      string `protobuf:"bytes,6,opt,name=chainid,proto3" json:"chainid,omitempty"`
	InstanceName string `protobuf:"bytes,7,opt,name=instanceName,proto3" json:"instanceName,omitempty"`
}

func (m *ContractMsg) Reset()         { *m = ContractMsg{} }
func (m *ContractMsg) String() string { return proto.CompactTextString(m) }
func (*ContractMsg) ProtoMessage()    {}
func (*ContractMsg) Descriptor() ([]byte, []int) {
	return fileDescriptor_d5ed56110ac5207b, []int{7}
}
func (m *ContractMsg) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ContractMsg) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ContractMsg.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ContractMsg) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ContractMsg.Merge(m, src)
}
func (m *ContractMsg) XXX_Size() int {
	return m.Size()
}
func (m *ContractMsg) XXX_DiscardUnknown() {
	xxx_messageInfo_ContractMsg.DiscardUnknown(m)
}

var xxx_messageInfo_ContractMsg proto.InternalMessageInfo

type ContractMsgsWrap struct {
	Msgs []*ContractMsg `protobuf:"bytes,1,rep,name=msgs,proto3" json:"msgs,omitempty"`
}

func (m *ContractMsgsWrap) Reset()         { *m = ContractMsgsWrap{} }
func (m *ContractMsgsWrap) String() string { return proto.CompactTextString(m) }
func (*ContractMsgsWrap) ProtoMessage()    {}
func (*ContractMsgsWrap) Descriptor() ([]byte, []int) {
	return fileDescriptor_d5ed56110ac5207b, []int{8}
}
func (m *ContractMsgsWrap) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ContractMsgsWrap) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ContractMsgsWrap.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ContractMsgsWrap) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ContractMsgsWrap.Merge(m, src)
}
func (m *ContractMsgsWrap) XXX_Size() int {
	return m.Size()
}
func (m *ContractMsgsWrap) XXX_DiscardUnknown() {
	xxx_messageInfo_ContractMsgsWrap.DiscardUnknown(m)
}

var xxx_messageInfo_ContractMsgsWrap proto.InternalMessageInfo

type InstanceId struct {
	Identity  []byte `protobuf:"bytes,1,opt,name=identity,proto3" json:"identity,omitempty"`
	Sig       []byte `protobuf:"bytes,2,opt,name=sig,proto3" json:"sig,omitempty"`
	Msg       []byte `protobuf:"bytes,3,opt,name=msg,proto3" json:"msg,omitempty"`
	Extension []byte `protobuf:"bytes,4,opt,name=extension,proto3" json:"extension,omitempty"`
}

func (m *InstanceId) Reset()         { *m = InstanceId{} }
func (m *InstanceId) String() string { return proto.CompactTextString(m) }
func (*InstanceId) ProtoMessage()    {}
func (*InstanceId) Descriptor() ([]byte, []int) {
	return fileDescriptor_d5ed56110ac5207b, []int{9}
}
func (m *InstanceId) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *InstanceId) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_InstanceId.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *InstanceId) XXX_Merge(src proto.Message) {
	xxx_messageInfo_InstanceId.Merge(m, src)
}
func (m *InstanceId) XXX_Size() int {
	return m.Size()
}
func (m *InstanceId) XXX_DiscardUnknown() {
	xxx_messageInfo_InstanceId.DiscardUnknown(m)
}

var xxx_messageInfo_InstanceId proto.InternalMessageInfo

type InvokeMsg struct {
	FuncName string   `protobuf:"bytes,1,opt,name=funcName,proto3" json:"funcName,omitempty"`
	Args     [][]byte `protobuf:"bytes,2,rep,name=args,proto3" json:"args,omitempty"`
	Orgs     []string `protobuf:"bytes,3,rep,name=orgs,proto3" json:"orgs,omitempty"`
	Cn       string   `protobuf:"bytes,4,opt,name=cn,proto3" json:"cn,omitempty"`
}

func (m *InvokeMsg) Reset()         { *m = InvokeMsg{} }
func (m *InvokeMsg) String() string { return proto.CompactTextString(m) }
func (*InvokeMsg) ProtoMessage()    {}
func (*InvokeMsg) Descriptor() ([]byte, []int) {
	return fileDescriptor_d5ed56110ac5207b, []int{10}
}
func (m *InvokeMsg) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *InvokeMsg) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_InvokeMsg.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *InvokeMsg) XXX_Merge(src proto.Message) {
	xxx_messageInfo_InvokeMsg.Merge(m, src)
}
func (m *InvokeMsg) XXX_Size() int {
	return m.Size()
}
func (m *InvokeMsg) XXX_DiscardUnknown() {
	xxx_messageInfo_InvokeMsg.DiscardUnknown(m)
}

var xxx_messageInfo_InvokeMsg proto.InternalMessageInfo

type GetState struct {
	Key string `protobuf:"bytes,1,opt,name=key,proto3" json:"key,omitempty"`
}

func (m *GetState) Reset()         { *m = GetState{} }
func (m *GetState) String() string { return proto.CompactTextString(m) }
func (*GetState) ProtoMessage()    {}
func (*GetState) Descriptor() ([]byte, []int) {
	return fileDescriptor_d5ed56110ac5207b, []int{11}
}
func (m *GetState) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *GetState) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_GetState.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *GetState) XXX_Merge(src proto.Message) {
	xxx_messageInfo_GetState.Merge(m, src)
}
func (m *GetState) XXX_Size() int {
	return m.Size()
}
func (m *GetState) XXX_DiscardUnknown() {
	xxx_messageInfo_GetState.DiscardUnknown(m)
}

var xxx_messageInfo_GetState proto.InternalMessageInfo

type PutState struct {
	Key   string `protobuf:"bytes,1,opt,name=key,proto3" json:"key,omitempty"`
	Value []byte `protobuf:"bytes,2,opt,name=value,proto3" json:"value,omitempty"`
}

func (m *PutState) Reset()         { *m = PutState{} }
func (m *PutState) String() string { return proto.CompactTextString(m) }
func (*PutState) ProtoMessage()    {}
func (*PutState) Descriptor() ([]byte, []int) {
	return fileDescriptor_d5ed56110ac5207b, []int{12}
}
func (m *PutState) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *PutState) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_PutState.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *PutState) XXX_Merge(src proto.Message) {
	xxx_messageInfo_PutState.Merge(m, src)
}
func (m *PutState) XXX_Size() int {
	return m.Size()
}
func (m *PutState) XXX_DiscardUnknown() {
	xxx_messageInfo_PutState.DiscardUnknown(m)
}

var xxx_messageInfo_PutState proto.InternalMessageInfo

type DelState struct {
	Key string `protobuf:"bytes,1,opt,name=key,proto3" json:"key,omitempty"`
}

func (m *DelState) Reset()         { *m = DelState{} }
func (m *DelState) String() string { return proto.CompactTextString(m) }
func (*DelState) ProtoMessage()    {}
func (*DelState) Descriptor() ([]byte, []int) {
	return fileDescriptor_d5ed56110ac5207b, []int{13}
}
func (m *DelState) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *DelState) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_DelState.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *DelState) XXX_Merge(src proto.Message) {
	xxx_messageInfo_DelState.Merge(m, src)
}
func (m *DelState) XXX_Size() int {
	return m.Size()
}
func (m *DelState) XXX_DiscardUnknown() {
	xxx_messageInfo_DelState.DiscardUnknown(m)
}

var xxx_messageInfo_DelState proto.InternalMessageInfo

type GetStateByRange struct {
	BeginKey   string `protobuf:"bytes,1,opt,name=beginKey,proto3" json:"beginKey,omitempty"`
	EndKey     string `protobuf:"bytes,2,opt,name=endKey,proto3" json:"endKey,omitempty"`
	BufferSize uint32 `protobuf:"varint,3,opt,name=buffer_size,json=bufferSize,proto3" json:"buffer_size,omitempty"`
	QueryId    string `protobuf:"bytes,5,opt,name=query_id,json=queryId,proto3" json:"query_id,omitempty"`
}

func (m *GetStateByRange) Reset()         { *m = GetStateByRange{} }
func (m *GetStateByRange) String() string { return proto.CompactTextString(m) }
func (*GetStateByRange) ProtoMessage()    {}
func (*GetStateByRange) Descriptor() ([]byte, []int) {
	return fileDescriptor_d5ed56110ac5207b, []int{14}
}
func (m *GetStateByRange) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *GetStateByRange) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_GetStateByRange.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *GetStateByRange) XXX_Merge(src proto.Message) {
	xxx_messageInfo_GetStateByRange.Merge(m, src)
}
func (m *GetStateByRange) XXX_Size() int {
	return m.Size()
}
func (m *GetStateByRange) XXX_DiscardUnknown() {
	xxx_messageInfo_GetStateByRange.DiscardUnknown(m)
}

var xxx_messageInfo_GetStateByRange proto.InternalMessageInfo

type GetHistoryForKey struct {
	Key        string `protobuf:"bytes,1,opt,name=key,proto3" json:"key,omitempty"`
	BufferSize uint32 `protobuf:"varint,2,opt,name=buffer_size,json=bufferSize,proto3" json:"buffer_size,omitempty"`
	QueryId    string `protobuf:"bytes,3,opt,name=query_id,json=queryId,proto3" json:"query_id,omitempty"`
}

func (m *GetHistoryForKey) Reset()         { *m = GetHistoryForKey{} }
func (m *GetHistoryForKey) String() string { return proto.CompactTextString(m) }
func (*GetHistoryForKey) ProtoMessage()    {}
func (*GetHistoryForKey) Descriptor() ([]byte, []int) {
	return fileDescriptor_d5ed56110ac5207b, []int{15}
}
func (m *GetHistoryForKey) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *GetHistoryForKey) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_GetHistoryForKey.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *GetHistoryForKey) XXX_Merge(src proto.Message) {
	xxx_messageInfo_GetHistoryForKey.Merge(m, src)
}
func (m *GetHistoryForKey) XXX_Size() int {
	return m.Size()
}
func (m *GetHistoryForKey) XXX_DiscardUnknown() {
	xxx_messageInfo_GetHistoryForKey.DiscardUnknown(m)
}

var xxx_messageInfo_GetHistoryForKey proto.InternalMessageInfo

type HistoryForKey struct {
	HistoryArray []*common.KeyModification `protobuf:"bytes,1,rep,name=history_array,json=historyArray,proto3" json:"history_array,omitempty"`
	IsOver       bool                      `protobuf:"varint,2,opt,name=isOver,proto3" json:"isOver,omitempty"`
	QueryId      string                    `protobuf:"bytes,3,opt,name=query_id,json=queryId,proto3" json:"query_id,omitempty"`
}

func (m *HistoryForKey) Reset()         { *m = HistoryForKey{} }
func (m *HistoryForKey) String() string { return proto.CompactTextString(m) }
func (*HistoryForKey) ProtoMessage()    {}
func (*HistoryForKey) Descriptor() ([]byte, []int) {
	return fileDescriptor_d5ed56110ac5207b, []int{16}
}
func (m *HistoryForKey) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *HistoryForKey) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_HistoryForKey.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *HistoryForKey) XXX_Merge(src proto.Message) {
	xxx_messageInfo_HistoryForKey.Merge(m, src)
}
func (m *HistoryForKey) XXX_Size() int {
	return m.Size()
}
func (m *HistoryForKey) XXX_DiscardUnknown() {
	xxx_messageInfo_HistoryForKey.DiscardUnknown(m)
}

var xxx_messageInfo_HistoryForKey proto.InternalMessageInfo

type QueryResponse struct {
	KvArray []*KVInfo `protobuf:"bytes,1,rep,name=kv_array,json=kvArray,proto3" json:"kv_array,omitempty"`
	IsOver  bool      `protobuf:"varint,2,opt,name=isOver,proto3" json:"isOver,omitempty"`
	QueryId string    `protobuf:"bytes,3,opt,name=query_id,json=queryId,proto3" json:"query_id,omitempty"`
}

func (m *QueryResponse) Reset()         { *m = QueryResponse{} }
func (m *QueryResponse) String() string { return proto.CompactTextString(m) }
func (*QueryResponse) ProtoMessage()    {}
func (*QueryResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_d5ed56110ac5207b, []int{17}
}
func (m *QueryResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *QueryResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_QueryResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *QueryResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_QueryResponse.Merge(m, src)
}
func (m *QueryResponse) XXX_Size() int {
	return m.Size()
}
func (m *QueryResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_QueryResponse.DiscardUnknown(m)
}

var xxx_messageInfo_QueryResponse proto.InternalMessageInfo

type KVInfo struct {
	Key   string `protobuf:"bytes,1,opt,name=key,proto3" json:"key,omitempty"`
	Value []byte `protobuf:"bytes,2,opt,name=value,proto3" json:"value,omitempty"`
}

func (m *KVInfo) Reset()         { *m = KVInfo{} }
func (m *KVInfo) String() string { return proto.CompactTextString(m) }
func (*KVInfo) ProtoMessage()    {}
func (*KVInfo) Descriptor() ([]byte, []int) {
	return fileDescriptor_d5ed56110ac5207b, []int{18}
}
func (m *KVInfo) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *KVInfo) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_KVInfo.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *KVInfo) XXX_Merge(src proto.Message) {
	xxx_messageInfo_KVInfo.Merge(m, src)
}
func (m *KVInfo) XXX_Size() int {
	return m.Size()
}
func (m *KVInfo) XXX_DiscardUnknown() {
	xxx_messageInfo_KVInfo.DiscardUnknown(m)
}

var xxx_messageInfo_KVInfo proto.InternalMessageInfo

type SqlQuery struct {
	Query      string                  `protobuf:"bytes,1,opt,name=query,proto3" json:"query,omitempty"`
	Args       *common.PrimitiveValues `protobuf:"bytes,2,opt,name=args,proto3" json:"args,omitempty"`
	BufferSize uint32                  `protobuf:"varint,3,opt,name=buffer_size,json=bufferSize,proto3" json:"buffer_size,omitempty"`
	QId        string                  `protobuf:"bytes,4,opt,name=q_id,json=qId,proto3" json:"q_id,omitempty"`
}

func (m *SqlQuery) Reset()         { *m = SqlQuery{} }
func (m *SqlQuery) String() string { return proto.CompactTextString(m) }
func (*SqlQuery) ProtoMessage()    {}
func (*SqlQuery) Descriptor() ([]byte, []int) {
	return fileDescriptor_d5ed56110ac5207b, []int{19}
}
func (m *SqlQuery) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *SqlQuery) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_SqlQuery.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *SqlQuery) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SqlQuery.Merge(m, src)
}
func (m *SqlQuery) XXX_Size() int {
	return m.Size()
}
func (m *SqlQuery) XXX_DiscardUnknown() {
	xxx_messageInfo_SqlQuery.DiscardUnknown(m)
}

var xxx_messageInfo_SqlQuery proto.InternalMessageInfo

type SqlExec struct {
	Query string                  `protobuf:"bytes,1,opt,name=query,proto3" json:"query,omitempty"`
	Args  *common.PrimitiveValues `protobuf:"bytes,2,opt,name=args,proto3" json:"args,omitempty"`
}

func (m *SqlExec) Reset()         { *m = SqlExec{} }
func (m *SqlExec) String() string { return proto.CompactTextString(m) }
func (*SqlExec) ProtoMessage()    {}
func (*SqlExec) Descriptor() ([]byte, []int) {
	return fileDescriptor_d5ed56110ac5207b, []int{20}
}
func (m *SqlExec) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *SqlExec) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_SqlExec.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *SqlExec) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SqlExec.Merge(m, src)
}
func (m *SqlExec) XXX_Size() int {
	return m.Size()
}
func (m *SqlExec) XXX_DiscardUnknown() {
	xxx_messageInfo_SqlExec.DiscardUnknown(m)
}

var xxx_messageInfo_SqlExec proto.InternalMessageInfo

type SqlQueryResponse struct {
	SqlRows *SqlRows `protobuf:"bytes,1,opt,name=sql_rows,json=sqlRows,proto3" json:"sql_rows,omitempty"`
	IsOver  bool     `protobuf:"varint,2,opt,name=is_over,json=isOver,proto3" json:"is_over,omitempty"`
	QueryId string   `protobuf:"bytes,3,opt,name=query_id,json=queryId,proto3" json:"query_id,omitempty"`
}

func (m *SqlQueryResponse) Reset()         { *m = SqlQueryResponse{} }
func (m *SqlQueryResponse) String() string { return proto.CompactTextString(m) }
func (*SqlQueryResponse) ProtoMessage()    {}
func (*SqlQueryResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_d5ed56110ac5207b, []int{21}
}
func (m *SqlQueryResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *SqlQueryResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_SqlQueryResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *SqlQueryResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SqlQueryResponse.Merge(m, src)
}
func (m *SqlQueryResponse) XXX_Size() int {
	return m.Size()
}
func (m *SqlQueryResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_SqlQueryResponse.DiscardUnknown(m)
}

var xxx_messageInfo_SqlQueryResponse proto.InternalMessageInfo

type SqlRows struct {
	Rows []*SqlRow `protobuf:"bytes,1,rep,name=rows,proto3" json:"rows,omitempty"`
}

func (m *SqlRows) Reset()         { *m = SqlRows{} }
func (m *SqlRows) String() string { return proto.CompactTextString(m) }
func (*SqlRows) ProtoMessage()    {}
func (*SqlRows) Descriptor() ([]byte, []int) {
	return fileDescriptor_d5ed56110ac5207b, []int{22}
}
func (m *SqlRows) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *SqlRows) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_SqlRows.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *SqlRows) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SqlRows.Merge(m, src)
}
func (m *SqlRows) XXX_Size() int {
	return m.Size()
}
func (m *SqlRows) XXX_DiscardUnknown() {
	xxx_messageInfo_SqlRows.DiscardUnknown(m)
}

var xxx_messageInfo_SqlRows proto.InternalMessageInfo

type SqlRow struct {
	Columns []*SqlColumn `protobuf:"bytes,1,rep,name=columns,proto3" json:"columns,omitempty"`
}

func (m *SqlRow) Reset()         { *m = SqlRow{} }
func (m *SqlRow) String() string { return proto.CompactTextString(m) }
func (*SqlRow) ProtoMessage()    {}
func (*SqlRow) Descriptor() ([]byte, []int) {
	return fileDescriptor_d5ed56110ac5207b, []int{23}
}
func (m *SqlRow) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *SqlRow) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_SqlRow.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *SqlRow) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SqlRow.Merge(m, src)
}
func (m *SqlRow) XXX_Size() int {
	return m.Size()
}
func (m *SqlRow) XXX_DiscardUnknown() {
	xxx_messageInfo_SqlRow.DiscardUnknown(m)
}

var xxx_messageInfo_SqlRow proto.InternalMessageInfo

type SqlColumn struct {
	Name  string `protobuf:"bytes,1,opt,name=name,proto3" json:"name,omitempty"`
	Index uint32 `protobuf:"varint,2,opt,name=index,proto3" json:"index,omitempty"`
	Value string `protobuf:"bytes,3,opt,name=value,proto3" json:"value,omitempty"`
}

func (m *SqlColumn) Reset()         { *m = SqlColumn{} }
func (m *SqlColumn) String() string { return proto.CompactTextString(m) }
func (*SqlColumn) ProtoMessage()    {}
func (*SqlColumn) Descriptor() ([]byte, []int) {
	return fileDescriptor_d5ed56110ac5207b, []int{24}
}
func (m *SqlColumn) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *SqlColumn) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_SqlColumn.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *SqlColumn) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SqlColumn.Merge(m, src)
}
func (m *SqlColumn) XXX_Size() int {
	return m.Size()
}
func (m *SqlColumn) XXX_DiscardUnknown() {
	xxx_messageInfo_SqlColumn.DiscardUnknown(m)
}

var xxx_messageInfo_SqlColumn proto.InternalMessageInfo

// A response with a representation similar to an HTTP response that can
// be used within another message.
type Response struct {
	// A status code that should follow the HTTP status codes.
	Status int32 `protobuf:"varint,1,opt,name=status,proto3" json:"status,omitempty"`
	// A message associated with the response code.
	Message string `protobuf:"bytes,2,opt,name=message,proto3" json:"message,omitempty"`
	// A payload that can be used to include metadata with this response.
	Payload []byte `protobuf:"bytes,3,opt,name=payload,proto3" json:"payload,omitempty"`
}

func (m *Response) Reset()         { *m = Response{} }
func (m *Response) String() string { return proto.CompactTextString(m) }
func (*Response) ProtoMessage()    {}
func (*Response) Descriptor() ([]byte, []int) {
	return fileDescriptor_d5ed56110ac5207b, []int{25}
}
func (m *Response) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Response) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Response.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Response) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Response.Merge(m, src)
}
func (m *Response) XXX_Size() int {
	return m.Size()
}
func (m *Response) XXX_DiscardUnknown() {
	xxx_messageInfo_Response.DiscardUnknown(m)
}

var xxx_messageInfo_Response proto.InternalMessageInfo

func init() {
	proto.RegisterEnum("contract.ContractExtensionType", ContractExtensionType_name, ContractExtensionType_value)
	proto.RegisterEnum("contract.ContractMsg_Type", ContractMsg_Type_name, ContractMsg_Type_value)
	proto.RegisterEnum("contract.ContractMsg_Stage", ContractMsg_Stage_name, ContractMsg_Stage_value)
	proto.RegisterType((*ContractDefinition)(nil), "contract.ContractDefinition")
	proto.RegisterMapType((map[string][]byte)(nil), "contract.ContractDefinition.ValidatorExtensionsEntry")
	proto.RegisterType((*DockerImageInfo)(nil), "contract.DockerImageInfo")
	proto.RegisterType((*ExternalContractInfo)(nil), "contract.ExternalContractInfo")
	proto.RegisterMapType((map[string][]byte)(nil), "contract.ExternalContractInfo.ExtensionsEntry")
	proto.RegisterType((*LogRotation)(nil), "contract.LogRotation")
	proto.RegisterType((*ContractConfig)(nil), "contract.ContractConfig")
	proto.RegisterType((*ContractGRPCConfig)(nil), "contract.ContractGRPCConfig")
	proto.RegisterType((*ContractTLSConfig)(nil), "contract.ContractTLSConfig")
	proto.RegisterType((*ContractMsg)(nil), "contract.ContractMsg")
	proto.RegisterType((*ContractMsgsWrap)(nil), "contract.ContractMsgsWrap")
	proto.RegisterType((*InstanceId)(nil), "contract.InstanceId")
	proto.RegisterType((*InvokeMsg)(nil), "contract.InvokeMsg")
	proto.RegisterType((*GetState)(nil), "contract.GetState")
	proto.RegisterType((*PutState)(nil), "contract.PutState")
	proto.RegisterType((*DelState)(nil), "contract.DelState")
	proto.RegisterType((*GetStateByRange)(nil), "contract.GetStateByRange")
	proto.RegisterType((*GetHistoryForKey)(nil), "contract.GetHistoryForKey")
	proto.RegisterType((*HistoryForKey)(nil), "contract.HistoryForKey")
	proto.RegisterType((*QueryResponse)(nil), "contract.QueryResponse")
	proto.RegisterType((*KVInfo)(nil), "contract.KVInfo")
	proto.RegisterType((*SqlQuery)(nil), "contract.SqlQuery")
	proto.RegisterType((*SqlExec)(nil), "contract.SqlExec")
	proto.RegisterType((*SqlQueryResponse)(nil), "contract.SqlQueryResponse")
	proto.RegisterType((*SqlRows)(nil), "contract.SqlRows")
	proto.RegisterType((*SqlRow)(nil), "contract.SqlRow")
	proto.RegisterType((*SqlColumn)(nil), "contract.SqlColumn")
	proto.RegisterType((*Response)(nil), "contract.Response")
}

func init() { proto.RegisterFile("contract/contract.proto", fileDescriptor_d5ed56110ac5207b) }

var fileDescriptor_d5ed56110ac5207b = []byte{
	// 2046 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xac, 0x58, 0x4f, 0x73, 0xdb, 0xc6,
	0x15, 0x17, 0x48, 0x4a, 0x04, 0x1f, 0x49, 0x09, 0x5a, 0xc9, 0x36, 0x23, 0x7b, 0x14, 0x17, 0x6d,
	0x5a, 0xb7, 0x69, 0xa4, 0x44, 0x9d, 0x4e, 0x9a, 0x4c, 0x7c, 0xb0, 0x48, 0x48, 0xc6, 0x48, 0xa2,
	0xe4, 0x25, 0xad, 0x56, 0xbd, 0xa0, 0x2b, 0x60, 0x05, 0xa1, 0x02, 0x01, 0x6a, 0x17, 0xa4, 0xc5,
	0x9e, 0x92, 0xe9, 0x17, 0xe8, 0xb5, 0xdf, 0x28, 0xb7, 0xfa, 0xd0, 0x99, 0xf6, 0xd6, 0xc4, 0xfe,
	0x02, 0xfd, 0x00, 0x3d, 0x74, 0xf6, 0x0f, 0x40, 0xca, 0x92, 0xdd, 0xb4, 0xcd, 0xed, 0xbd, 0xdf,
	0xfb, 0xb3, 0xbb, 0xef, 0x2f, 0x48, 0xb8, 0xe7, 0xa7, 0x49, 0xc6, 0x88, 0x9f, 0x6d, 0xe6, 0xc4,
	0xc6, 0x90, 0xa5, 0x59, 0x8a, 0xcc, 0x9c, 0x5f, 0x5b, 0x0d, 0xd3, 0x30, 0x95, 0xe0, 0xa6, 0xa0,
	0x94, 0x7c, 0x6d, 0xc5, 0x4f, 0x07, 0x83, 0x34, 0xd9, 0x8c, 0x69, 0x10, 0x52, 0xa6, 0xc1, 0x96,
	0x06, 0x33, 0x46, 0x12, 0x4e, 0xfc, 0x2c, 0x4a, 0x13, 0x25, 0xb1, 0xff, 0x55, 0x06, 0xd4, 0xd6,
	0x1e, 0x3b, 0xf4, 0x2c, 0x4a, 0x22, 0x21, 0x44, 0x3f, 0x84, 0x66, 0x7e, 0x8e, 0x97, 0x90, 0x01,
	0x6d, 0x19, 0x0f, 0x8d, 0x47, 0x35, 0xdc, 0xc8, 0xc1, 0x2e, 0x19, 0x50, 0xf4, 0x01, 0x2c, 0x72,
	0xff, 0x9c, 0x0e, 0x88, 0x37, 0xa6, 0x8c, 0x47, 0x69, 0xd2, 0x2a, 0x49, 0xad, 0xa6, 0x42, 0x8f,
	0x15, 0x88, 0x7e, 0x02, 0x4b, 0x9c, 0x5e, 0x8e, 0x68, 0xe2, 0x53, 0x2f, 0x19, 0x0d, 0x4e, 0x29,
	0x6b, 0x95, 0x1f, 0x1a, 0x8f, 0x9a, 0x78, 0x31, 0x87, 0xbb, 0x12, 0x45, 0x0f, 0xa1, 0x1e, 0x50,
	0xee, 0xb3, 0x68, 0x28, 0xee, 0xd0, 0xaa, 0x48, 0x67, 0xb3, 0x10, 0xfa, 0x01, 0x34, 0x18, 0xbd,
	0x1c, 0x45, 0x8c, 0x7a, 0xe2, 0xa6, 0xad, 0xf9, 0x87, 0xc6, 0x23, 0x13, 0xd7, 0x35, 0xe6, 0x26,
	0x51, 0x86, 0x6c, 0x68, 0xf2, 0xcb, 0xd8, 0x0b, 0x4e, 0x3d, 0x75, 0x8b, 0xd6, 0x82, 0x72, 0xc3,
	0x2f, 0xe3, 0xce, 0x69, 0x4f, 0x42, 0xe2, 0x46, 0xe7, 0x11, 0xcf, 0x52, 0x36, 0xf1, 0xf8, 0x68,
	0x38, 0x4c, 0x59, 0xd6, 0xaa, 0x4a, 0x4f, 0x8b, 0x1a, 0xee, 0x29, 0x14, 0x7d, 0x04, 0x88, 0x0c,
	0x87, 0x2c, 0x1d, 0x93, 0xd8, 0x1b, 0x93, 0x38, 0x0a, 0x48, 0x96, 0xb2, 0x16, 0x48, 0x8f, 0xcb,
	0xb9, 0xe4, 0x38, 0x17, 0xa0, 0x73, 0x58, 0x2d, 0xb4, 0x3c, 0x7a, 0x95, 0xd1, 0x44, 0x04, 0x80,
	0xb7, 0xea, 0x0f, 0xcb, 0x8f, 0xea, 0x5b, 0xbf, 0xdc, 0x28, 0x52, 0x79, 0x33, 0xe2, 0x1b, 0x85,
	0x17, 0xa7, 0xb0, 0x73, 0x92, 0x8c, 0x4d, 0xf0, 0xca, 0xf8, 0xa6, 0x64, 0x6d, 0x07, 0x5a, 0x6f,
	0x33, 0x40, 0x16, 0x94, 0x2f, 0xe8, 0x44, 0x67, 0x4c, 0x90, 0x68, 0x15, 0xe6, 0xc7, 0x24, 0x1e,
	0x51, 0x99, 0x9f, 0x06, 0x56, 0xcc, 0xe7, 0xa5, 0x5f, 0x19, 0xf6, 0x17, 0xb0, 0xd4, 0x49, 0xfd,
	0x0b, 0xca, 0xdc, 0x01, 0x09, 0xa9, 0x9b, 0x9c, 0xa5, 0x68, 0x11, 0x4a, 0x6e, 0x47, 0x5b, 0x97,
	0xdc, 0x0e, 0x7a, 0x0f, 0x4c, 0x46, 0x87, 0xa9, 0x97, 0x91, 0x50, 0xe7, 0xb7, 0x2a, 0xf8, 0x3e,
	0x09, 0xed, 0xbf, 0x96, 0x60, 0x55, 0x9c, 0xce, 0x12, 0x12, 0xe7, 0x4f, 0x92, 0x3e, 0x3e, 0x83,
	0x06, 0x27, 0x49, 0x70, 0x9a, 0x5e, 0x79, 0xd9, 0x64, 0xa8, 0xaa, 0x67, 0x71, 0xeb, 0xee, 0x86,
	0x2a, 0xc3, 0xe2, 0xf9, 0x78, 0x94, 0x38, 0xc9, 0x18, 0xd7, 0xb5, 0x6e, 0x7f, 0x32, 0xfc, 0xce,
	0x45, 0x85, 0xa0, 0xe2, 0xa7, 0x01, 0x95, 0x95, 0xd4, 0xc0, 0x92, 0x46, 0xf7, 0xa1, 0x36, 0xa4,
	0x94, 0x79, 0x3e, 0x65, 0x99, 0xac, 0x9e, 0x06, 0x36, 0x05, 0xd0, 0xa6, 0x2c, 0x43, 0x5d, 0x80,
	0x99, 0x8c, 0xcc, 0xcb, 0x8c, 0x6c, 0x4c, 0x33, 0x72, 0xdb, 0x33, 0x36, 0xde, 0x4c, 0xc5, 0x8c,
	0x07, 0xb4, 0x06, 0x66, 0x4c, 0x92, 0x70, 0x44, 0x42, 0xaa, 0x4b, 0xac, 0xe0, 0xd7, 0x1e, 0xc3,
	0xd2, 0xff, 0x93, 0x94, 0xbf, 0x18, 0x50, 0xdf, 0x4f, 0x43, 0x9c, 0x66, 0x44, 0x56, 0x7d, 0x0b,
	0xaa, 0x4e, 0x42, 0x4e, 0x63, 0x1a, 0x48, 0x7b, 0x13, 0xe7, 0xac, 0xb8, 0xc4, 0x4e, 0x14, 0x53,
	0xd9, 0xa1, 0x2a, 0x4c, 0x05, 0x2f, 0xac, 0x0e, 0xc8, 0x55, 0x2f, 0xfa, 0x03, 0xd5, 0xed, 0x96,
	0xb3, 0xe8, 0x2e, 0x2c, 0x1c, 0x90, 0xab, 0x27, 0x21, 0x95, 0x41, 0x6a, 0x62, 0xcd, 0xa1, 0x75,
	0x80, 0x03, 0x72, 0xb5, 0x4d, 0xfc, 0x8b, 0xd1, 0x90, 0xcb, 0xde, 0x6a, 0xe2, 0x19, 0x04, 0x3d,
	0x80, 0xda, 0x7e, 0xea, 0x93, 0xb8, 0x1f, 0x0d, 0xd4, 0x9b, 0x4d, 0x3c, 0x05, 0xc4, 0x5d, 0xda,
	0xe9, 0x60, 0xc8, 0x28, 0xe7, 0xba, 0x9b, 0x0a, 0xde, 0xfe, 0x63, 0x19, 0x16, 0xf3, 0xc8, 0xb6,
	0xd3, 0xe4, 0x2c, 0x0a, 0xd1, 0xe7, 0x00, 0x59, 0xcc, 0x3d, 0x5f, 0x72, 0xf2, 0x5d, 0xf5, 0xad,
	0xfb, 0x37, 0x3b, 0xa4, 0xbf, 0xdf, 0x53, 0x06, 0xb8, 0x96, 0xc5, 0x5c, 0xdb, 0x3e, 0x86, 0x7a,
	0xc8, 0x86, 0x7e, 0x6e, 0x5c, 0x92, 0xc6, 0x0f, 0x6e, 0x1a, 0xef, 0xe2, 0xa3, 0xb6, 0xb6, 0x06,
	0x61, 0xa0, 0xcd, 0x11, 0x54, 0x64, 0xcf, 0x97, 0x65, 0xc4, 0x24, 0x2d, 0x6a, 0x27, 0x4e, 0x43,
	0x2f, 0xa6, 0x63, 0x1a, 0xeb, 0xc9, 0x63, 0xc6, 0x69, 0xb8, 0x2f, 0x78, 0xf1, 0xb4, 0x24, 0x0d,
	0xe8, 0x93, 0x20, 0x60, 0x32, 0x2c, 0x35, 0x5c, 0xf0, 0xb9, 0x4c, 0x0c, 0xc4, 0xbc, 0x0e, 0x72,
	0x5e, 0xa4, 0xc0, 0x3f, 0x27, 0x51, 0xe2, 0x76, 0x64, 0x44, 0x6a, 0x38, 0x67, 0x91, 0x0d, 0xd7,
	0x46, 0x69, 0xcb, 0xbc, 0x65, 0xbc, 0x3e, 0x80, 0x5a, 0x51, 0x6f, 0xad, 0x9a, 0x54, 0x98, 0x02,
	0xe8, 0x13, 0x30, 0x99, 0x2e, 0x10, 0x39, 0x90, 0xea, 0x5b, 0x77, 0xa6, 0x01, 0x98, 0xa9, 0x1e,
	0x5c, 0xa8, 0xd9, 0xff, 0x34, 0xa6, 0xb3, 0x7e, 0x1a, 0x1a, 0xf1, 0x82, 0x28, 0xc9, 0x28, 0x1b,
	0x93, 0x58, 0xe6, 0xa1, 0x89, 0x0b, 0x5e, 0xbc, 0x20, 0x8b, 0x06, 0x34, 0x1d, 0x65, 0x32, 0xca,
	0x4d, 0x9c, 0xb3, 0x62, 0x58, 0x0f, 0xa2, 0xc4, 0xcd, 0x0d, 0x55, 0x89, 0xcd, 0x42, 0x68, 0x0b,
	0x56, 0x07, 0xe4, 0xaa, 0x9d, 0x26, 0xfe, 0x88, 0x31, 0x9a, 0x64, 0xbd, 0x8c, 0x51, 0x32, 0xe0,
	0xba, 0xe8, 0x6e, 0x95, 0xa1, 0x1f, 0xc3, 0xe2, 0x80, 0x5c, 0xf5, 0x68, 0x12, 0x1c, 0xf0, 0x50,
	0xd6, 0xae, 0x2a, 0xc3, 0x37, 0x50, 0xad, 0x87, 0xa9, 0x3f, 0xce, 0xf5, 0x16, 0x0a, 0xbd, 0x19,
	0xd4, 0xfe, 0xc6, 0x80, 0xe5, 0x1b, 0xa5, 0x24, 0xa2, 0x1f, 0xf1, 0x7e, 0xcc, 0xaf, 0x77, 0xd5,
	0x35, 0x4c, 0x34, 0x43, 0xc4, 0x0f, 0x46, 0x71, 0x16, 0xf5, 0x63, 0x2e, 0x1f, 0x6f, 0xe2, 0x19,
	0x44, 0x14, 0x8c, 0x98, 0x33, 0xde, 0x90, 0x64, 0xe7, 0xba, 0x92, 0x4c, 0x01, 0x1c, 0x91, 0xec,
	0x5c, 0xcc, 0xcc, 0x0b, 0x3a, 0x51, 0x32, 0x55, 0x4c, 0xd5, 0x0b, 0x3a, 0x91, 0xa2, 0x0d, 0x58,
	0x91, 0x43, 0x8a, 0xa5, 0x69, 0x26, 0xf4, 0xb9, 0xd2, 0x12, 0x03, 0xa9, 0x86, 0x97, 0x85, 0x08,
	0xe7, 0x12, 0xa9, 0xff, 0x3e, 0xd4, 0x39, 0x65, 0x63, 0xca, 0xd4, 0x1e, 0x56, 0x25, 0x06, 0x0a,
	0x12, 0x65, 0x62, 0xff, 0xb9, 0x02, 0xf5, 0xfc, 0x89, 0x07, 0x3c, 0x44, 0x9f, 0xc0, 0x3c, 0xcf,
	0xc4, 0x54, 0x52, 0x43, 0xf7, 0x96, 0x9e, 0x3a, 0xe0, 0xe1, 0x46, 0x4f, 0xa8, 0x60, 0xa5, 0x89,
	0x36, 0xa0, 0x22, 0xc7, 0x74, 0x49, 0x5a, 0xac, 0xdd, 0x6e, 0x21, 0xa6, 0x33, 0x96, 0x7a, 0xa2,
	0x2a, 0x86, 0x64, 0x12, 0xa7, 0x24, 0xd0, 0xf3, 0x37, 0x67, 0x45, 0x6b, 0x65, 0x57, 0x51, 0xa0,
	0x1f, 0x2d, 0x69, 0x11, 0xc9, 0xdc, 0x61, 0x14, 0xe8, 0xfe, 0x99, 0x41, 0x8a, 0x2e, 0x89, 0x02,
	0xfd, 0xba, 0x9c, 0x95, 0x79, 0x4a, 0x78, 0x46, 0xc4, 0x27, 0x82, 0x78, 0xbc, 0x6a, 0xa2, 0x6b,
	0x98, 0xfd, 0x0f, 0x03, 0x2a, 0x72, 0x71, 0x34, 0xa1, 0xf6, 0xbc, 0xdb, 0x71, 0x76, 0xdc, 0xae,
	0xd3, 0xb1, 0xe6, 0x90, 0x09, 0x15, 0xb7, 0xeb, 0xf6, 0x2d, 0x03, 0x01, 0x2c, 0xb8, 0xdd, 0xe3,
	0xc3, 0x3d, 0xc7, 0x2a, 0x09, 0x7a, 0xd7, 0xe9, 0x7b, 0x7b, 0xc7, 0x56, 0x59, 0xd0, 0x47, 0xcf,
	0x25, 0x5d, 0x11, 0x74, 0xc7, 0xd9, 0x17, 0xf4, 0x3c, 0x5a, 0x81, 0x25, 0xa5, 0xe3, 0x6d, 0x9f,
	0x78, 0xf8, 0x49, 0x77, 0xd7, 0xb1, 0x16, 0xd0, 0x3d, 0x58, 0x11, 0xe0, 0x53, 0xb7, 0xd7, 0x3f,
	0xc4, 0x27, 0xde, 0xce, 0x21, 0xf6, 0xf6, 0x9c, 0x13, 0xab, 0x8a, 0x1a, 0x60, 0xf6, 0x9e, 0xed,
	0x7b, 0xf2, 0x2c, 0x13, 0x2d, 0x02, 0x28, 0x4e, 0x9e, 0x57, 0xcb, 0xa5, 0xce, 0x6f, 0x9c, 0xb6,
	0x05, 0xe2, 0x8a, 0x82, 0x7b, 0xf6, 0xdc, 0xc1, 0x27, 0x56, 0x1d, 0xdd, 0x81, 0x65, 0xb7, 0xdb,
	0xeb, 0x3f, 0xe9, 0xb6, 0x1d, 0xcf, 0xed, 0x38, 0xdd, 0xbe, 0xdb, 0x3f, 0xb1, 0x1a, 0xc2, 0xc7,
	0x2e, 0xcd, 0xda, 0x8c, 0x8a, 0xe5, 0x6e, 0x35, 0xed, 0xcf, 0x60, 0x5e, 0x66, 0x0b, 0x59, 0xd0,
	0x78, 0x4a, 0x92, 0x20, 0xa6, 0x6e, 0x32, 0x4e, 0x2f, 0xa8, 0x35, 0x87, 0x96, 0xa0, 0xde, 0xcb,
	0x08, 0xcb, 0x34, 0x60, 0x88, 0x13, 0x9c, 0x24, 0xd0, 0x6c, 0xc9, 0x7e, 0x0c, 0xd6, 0x4c, 0x0a,
	0xf9, 0xaf, 0x19, 0x19, 0xa2, 0x9f, 0x42, 0x65, 0xc0, 0x43, 0xde, 0x32, 0xe4, 0x0a, 0xbc, 0x73,
	0x6b, 0xb2, 0xb1, 0x54, 0xb1, 0x7f, 0x0f, 0xe0, 0xea, 0x58, 0xbb, 0x72, 0xd9, 0x44, 0x01, 0x4d,
	0xb2, 0x28, 0x53, 0x7b, 0xac, 0x81, 0x0b, 0x5e, 0xac, 0x37, 0xae, 0x27, 0x71, 0x03, 0x0b, 0x52,
	0x20, 0x03, 0x1e, 0xea, 0xfa, 0x10, 0xe4, 0xf5, 0x79, 0xa6, 0xd6, 0xf3, 0x14, 0xb0, 0x3d, 0xa8,
	0xa9, 0x6b, 0x8b, 0x1a, 0x5e, 0x03, 0xf3, 0x6c, 0x94, 0xf8, 0xdd, 0xe9, 0x97, 0x67, 0xc1, 0x8b,
	0x12, 0x23, 0x2c, 0x14, 0x2d, 0x59, 0x16, 0x9b, 0x5f, 0xd0, 0x02, 0x4b, 0x05, 0x56, 0x96, 0x5d,
	0x24, 0x69, 0xf1, 0x1d, 0xe3, 0xe7, 0x1f, 0x91, 0x25, 0x3f, 0xb1, 0x1f, 0x80, 0xb9, 0x4b, 0xb3,
	0x5e, 0x46, 0x32, 0x7a, 0x73, 0x1b, 0xdb, 0x5b, 0x60, 0x1e, 0x8d, 0xde, 0x26, 0xbd, 0x7d, 0x57,
	0x0b, 0x8f, 0x1d, 0x1a, 0xbf, 0xcd, 0xe3, 0x57, 0x06, 0x2c, 0xe5, 0x07, 0x6e, 0x4f, 0x30, 0x49,
	0x42, 0xb9, 0x23, 0x4f, 0x69, 0x18, 0x25, 0x7b, 0x85, 0x6a, 0xc1, 0x8b, 0xad, 0x4c, 0x93, 0x40,
	0x48, 0xd4, 0x26, 0xd7, 0x9c, 0x18, 0x00, 0xa7, 0xa3, 0xb3, 0x33, 0xca, 0x3c, 0x3e, 0xdd, 0xe5,
	0xa0, 0x20, 0x39, 0x0b, 0xdf, 0x03, 0xf3, 0x72, 0x44, 0xd9, 0xc4, 0x2b, 0xba, 0xab, 0x2a, 0x79,
	0x37, 0xb0, 0x7f, 0x07, 0xd6, 0x2e, 0xcd, 0x9e, 0xaa, 0x8f, 0xda, 0x9d, 0x94, 0x09, 0x7f, 0x37,
	0x5f, 0xf7, 0xc6, 0x09, 0xa5, 0x77, 0x9e, 0x50, 0xbe, 0x7e, 0xc2, 0x97, 0x06, 0x34, 0xaf, 0xfb,
	0xff, 0x02, 0x9a, 0xf9, 0xc7, 0x35, 0x61, 0x8c, 0x4c, 0x74, 0xa1, 0xdd, 0xcb, 0x3f, 0xfe, 0xf6,
	0xe8, 0xe4, 0x20, 0x0d, 0xa2, 0xb3, 0xc8, 0x57, 0xfb, 0xa9, 0xa1, 0xb5, 0x9f, 0x08, 0x65, 0x11,
	0x85, 0x88, 0x1f, 0x8e, 0x29, 0xd3, 0x23, 0x57, 0x73, 0xef, 0xba, 0x42, 0x0a, 0xcd, 0x67, 0x82,
	0xc4, 0x94, 0x0f, 0xd3, 0x84, 0x53, 0xf4, 0x21, 0x98, 0x17, 0xe3, 0x6b, 0x87, 0x5b, 0xd3, 0x2a,
	0xdf, 0x3b, 0x16, 0x9f, 0x76, 0xb8, 0x7a, 0x31, 0xfe, 0x9f, 0x0f, 0xfc, 0x18, 0x16, 0x94, 0x97,
	0xef, 0x5c, 0x29, 0x5f, 0x19, 0x60, 0xf6, 0x2e, 0x63, 0x79, 0x4d, 0xa1, 0x22, 0x3d, 0x69, 0x33,
	0xc5, 0xa0, 0x0f, 0x8b, 0xb2, 0x36, 0x66, 0xa3, 0x75, 0xc4, 0xa2, 0x41, 0x94, 0x45, 0x63, 0x7a,
	0x2c, 0x1c, 0x71, 0x5d, 0xef, 0xff, 0xb1, 0x26, 0x96, 0xa1, 0x72, 0xe9, 0x15, 0x73, 0xb8, 0x7c,
	0xe9, 0x06, 0xf6, 0x3e, 0x54, 0x7b, 0x97, 0xb1, 0x73, 0x45, 0xfd, 0xef, 0xe1, 0x06, 0x76, 0x06,
	0x56, 0xfe, 0xa0, 0x22, 0xee, 0x3f, 0x07, 0x53, 0xfc, 0xf4, 0x62, 0xe9, 0x0b, 0xae, 0x3f, 0xe8,
	0x96, 0xa7, 0x71, 0xef, 0x5d, 0xc6, 0x38, 0x7d, 0xc1, 0x71, 0x95, 0x2b, 0x02, 0xdd, 0x83, 0x6a,
	0xc4, 0xbd, 0xf4, 0xbf, 0x8a, 0xfc, 0xa6, 0x7c, 0x83, 0x34, 0xff, 0x11, 0x54, 0xf4, 0x41, 0x6f,
	0x24, 0x58, 0x29, 0x60, 0x29, 0xb5, 0x3f, 0x85, 0x05, 0xc5, 0xa3, 0x8f, 0xa0, 0xea, 0xa7, 0xf1,
	0x68, 0x90, 0xe4, 0x26, 0x2b, 0xd7, 0x4c, 0xda, 0x52, 0x86, 0x73, 0x1d, 0x7b, 0x0f, 0x6a, 0x05,
	0x2a, 0xc6, 0xcb, 0xcc, 0x8f, 0x60, 0x49, 0x8b, 0x18, 0x46, 0x49, 0x40, 0xaf, 0x74, 0xbb, 0x28,
	0x66, 0x9a, 0x7e, 0x75, 0x71, 0x9d, 0xfe, 0x63, 0x30, 0x8b, 0x20, 0xdd, 0x85, 0x05, 0x9e, 0x91,
	0x6c, 0xa4, 0x42, 0x34, 0x8f, 0x35, 0x27, 0xb6, 0xe0, 0x80, 0x72, 0x2e, 0x16, 0xb7, 0xfe, 0x95,
	0xa5, 0xd9, 0xb7, 0x6f, 0xdb, 0x9f, 0xfd, 0xcd, 0x80, 0x3b, 0xf9, 0xd4, 0x2e, 0x7e, 0x70, 0xc8,
	0x65, 0xf8, 0x3e, 0xdc, 0xbf, 0x21, 0xf0, 0x66, 0xd7, 0x63, 0x13, 0x6a, 0x72, 0x0d, 0x79, 0xd8,
	0x79, 0x66, 0x19, 0x62, 0xe7, 0x48, 0x99, 0xdb, 0x77, 0x0f, 0xbb, 0x56, 0x49, 0xec, 0xad, 0x6d,
	0xb7, 0xeb, 0xed, 0xb8, 0xfb, 0x8e, 0x55, 0x96, 0x6b, 0xe6, 0xf0, 0x39, 0x6e, 0x3b, 0x0a, 0xa8,
	0x88, 0x6d, 0xd8, 0x77, 0x1c, 0xcf, 0xe9, 0xb6, 0xf1, 0xc9, 0x51, 0xdf, 0x3b, 0x7a, 0xbe, 0x2d,
	0xb7, 0xe1, 0x3c, 0x5a, 0x05, 0x4b, 0x08, 0x7a, 0xee, 0x6e, 0xb7, 0x40, 0x17, 0x50, 0x0b, 0x56,
	0xdb, 0xfb, 0xae, 0xd3, 0xed, 0x17, 0x6b, 0xce, 0x6b, 0x3b, 0xb8, 0x6f, 0x55, 0xd1, 0x5d, 0x40,
	0x6f, 0x4a, 0xdc, 0x8e, 0x65, 0x6e, 0x61, 0x30, 0x7b, 0x07, 0x6d, 0x12, 0xc7, 0x94, 0xa1, 0x1d,
	0x58, 0x10, 0x54, 0xef, 0x00, 0xdd, 0xfe, 0x65, 0x22, 0xd7, 0xda, 0xda, 0x3b, 0x64, 0xf6, 0xdc,
	0x23, 0xe3, 0x63, 0x63, 0xfb, 0x4b, 0xe3, 0xeb, 0x6f, 0xd7, 0xe7, 0x5e, 0x7e, 0xbb, 0x3e, 0xf7,
	0xf5, 0xab, 0x75, 0xe3, 0xe5, 0xab, 0x75, 0xe3, 0x9b, 0x57, 0xeb, 0xc6, 0x9f, 0x5e, 0xaf, 0xcf,
	0xbd, 0x7c, 0xbd, 0x3e, 0xf7, 0xf7, 0xd7, 0xeb, 0x73, 0xf0, 0x81, 0x9f, 0x0e, 0x36, 0xce, 0x47,
	0xe4, 0x05, 0x8d, 0x36, 0x5e, 0x44, 0x34, 0xa1, 0x4c, 0x7e, 0x8a, 0xa8, 0xff, 0x4a, 0x8a, 0x03,
	0x7e, 0xfb, 0x69, 0x18, 0x65, 0xb9, 0x9a, 0x9f, 0x0e, 0x36, 0x87, 0x69, 0xc4, 0xb9, 0xc8, 0x2e,
	0x61, 0xfe, 0xf9, 0xe6, 0x8c, 0xe1, 0xa6, 0xfa, 0x7b, 0x26, 0x37, 0x3c, 0x5d, 0x90, 0xfc, 0x2f,
	0xfe, 0x1d, 0x00, 0x00, 0xff, 0xff, 0x35, 0x33, 0x23, 0x91, 0xde, 0x11, 0x00, 0x00,
}

// Reference imports to suppress errors if they are not otherwise used.
var _ context.Context
var _ grpc.ClientConn

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
const _ = grpc.SupportPackageIsVersion4

// SMCallerClient is the client API for SMCaller service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://godoc.org/google.golang.org/grpc#ClientConn.NewStream.
type SMCallerClient interface {
	CallSM(ctx context.Context, opts ...grpc.CallOption) (SMCaller_CallSMClient, error)
}

type sMCallerClient struct {
	cc *grpc.ClientConn
}

func NewSMCallerClient(cc *grpc.ClientConn) SMCallerClient {
	return &sMCallerClient{cc}
}

func (c *sMCallerClient) CallSM(ctx context.Context, opts ...grpc.CallOption) (SMCaller_CallSMClient, error) {
	stream, err := c.cc.NewStream(ctx, &_SMCaller_serviceDesc.Streams[0], "/contract.SMCaller/CallSM", opts...)
	if err != nil {
		return nil, err
	}
	x := &sMCallerCallSMClient{stream}
	return x, nil
}

type SMCaller_CallSMClient interface {
	Send(*ContractMsgsWrap) error
	Recv() (*ContractMsgsWrap, error)
	grpc.ClientStream
}

type sMCallerCallSMClient struct {
	grpc.ClientStream
}

func (x *sMCallerCallSMClient) Send(m *ContractMsgsWrap) error {
	return x.ClientStream.SendMsg(m)
}

func (x *sMCallerCallSMClient) Recv() (*ContractMsgsWrap, error) {
	m := new(ContractMsgsWrap)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

// SMCallerServer is the server API for SMCaller service.
type SMCallerServer interface {
	CallSM(SMCaller_CallSMServer) error
}

// UnimplementedSMCallerServer can be embedded to have forward compatible implementations.
type UnimplementedSMCallerServer struct {
}

func (*UnimplementedSMCallerServer) CallSM(srv SMCaller_CallSMServer) error {
	return status.Errorf(codes.Unimplemented, "method CallSM not implemented")
}

func RegisterSMCallerServer(s *grpc.Server, srv SMCallerServer) {
	s.RegisterService(&_SMCaller_serviceDesc, srv)
}

func _SMCaller_CallSM_Handler(srv interface{}, stream grpc.ServerStream) error {
	return srv.(SMCallerServer).CallSM(&sMCallerCallSMServer{stream})
}

type SMCaller_CallSMServer interface {
	Send(*ContractMsgsWrap) error
	Recv() (*ContractMsgsWrap, error)
	grpc.ServerStream
}

type sMCallerCallSMServer struct {
	grpc.ServerStream
}

func (x *sMCallerCallSMServer) Send(m *ContractMsgsWrap) error {
	return x.ServerStream.SendMsg(m)
}

func (x *sMCallerCallSMServer) Recv() (*ContractMsgsWrap, error) {
	m := new(ContractMsgsWrap)
	if err := x.ServerStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

var _SMCaller_serviceDesc = grpc.ServiceDesc{
	ServiceName: "contract.SMCaller",
	HandlerType: (*SMCallerServer)(nil),
	Methods:     []grpc.MethodDesc{},
	Streams: []grpc.StreamDesc{
		{
			StreamName:    "CallSM",
			Handler:       _SMCaller_CallSM_Handler,
			ServerStreams: true,
			ClientStreams: true,
		},
	},
	Metadata: "contract/contract.proto",
}

func (m *ContractDefinition) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ContractDefinition) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ContractDefinition) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.ValidatorExtensions) > 0 {
		for k := range m.ValidatorExtensions {
			v := m.ValidatorExtensions[k]
			baseI := i
			if len(v) > 0 {
				i -= len(v)
				copy(dAtA[i:], v)
				i = encodeVarintContract(dAtA, i, uint64(len(v)))
				i--
				dAtA[i] = 0x12
			}
			i -= len(k)
			copy(dAtA[i:], k)
			i = encodeVarintContract(dAtA, i, uint64(len(k)))
			i--
			dAtA[i] = 0xa
			i = encodeVarintContract(dAtA, i, uint64(baseI-i))
			i--
			dAtA[i] = 0x5a
		}
	}
	if len(m.ApprovalValidator) > 0 {
		i -= len(m.ApprovalValidator)
		copy(dAtA[i:], m.ApprovalValidator)
		i = encodeVarintContract(dAtA, i, uint64(len(m.ApprovalValidator)))
		i--
		dAtA[i] = 0x52
	}
	if m.HistorySupport {
		i--
		if m.HistorySupport {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x38
	}
	if len(m.SqlDbSchema) > 0 {
		i -= len(m.SqlDbSchema)
		copy(dAtA[i:], m.SqlDbSchema)
		i = encodeVarintContract(dAtA, i, uint64(len(m.SqlDbSchema)))
		i--
		dAtA[i] = 0x32
	}
	if m.RequireInit {
		i--
		if m.RequireInit {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x28
	}
	if len(m.Description) > 0 {
		i -= len(m.Description)
		copy(dAtA[i:], m.Description)
		i = encodeVarintContract(dAtA, i, uint64(len(m.Description)))
		i--
		dAtA[i] = 0x22
	}
	if m.SequenceNumber != 0 {
		i = encodeVarintContract(dAtA, i, uint64(m.SequenceNumber))
		i--
		dAtA[i] = 0x18
	}
	if len(m.SchemaVersion) > 0 {
		i -= len(m.SchemaVersion)
		copy(dAtA[i:], m.SchemaVersion)
		i = encodeVarintContract(dAtA, i, uint64(len(m.SchemaVersion)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.ContractName) > 0 {
		i -= len(m.ContractName)
		copy(dAtA[i:], m.ContractName)
		i = encodeVarintContract(dAtA, i, uint64(len(m.ContractName)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *DockerImageInfo) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *DockerImageInfo) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *DockerImageInfo) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.RepoTag) > 0 {
		i -= len(m.RepoTag)
		copy(dAtA[i:], m.RepoTag)
		i = encodeVarintContract(dAtA, i, uint64(len(m.RepoTag)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.ID) > 0 {
		i -= len(m.ID)
		copy(dAtA[i:], m.ID)
		i = encodeVarintContract(dAtA, i, uint64(len(m.ID)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *ExternalContractInfo) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ExternalContractInfo) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ExternalContractInfo) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Language) > 0 {
		i -= len(m.Language)
		copy(dAtA[i:], m.Language)
		i = encodeVarintContract(dAtA, i, uint64(len(m.Language)))
		i--
		dAtA[i] = 0x32
	}
	if len(m.Extensions) > 0 {
		for k := range m.Extensions {
			v := m.Extensions[k]
			baseI := i
			if len(v) > 0 {
				i -= len(v)
				copy(dAtA[i:], v)
				i = encodeVarintContract(dAtA, i, uint64(len(v)))
				i--
				dAtA[i] = 0x12
			}
			i -= len(k)
			copy(dAtA[i:], k)
			i = encodeVarintContract(dAtA, i, uint64(len(k)))
			i--
			dAtA[i] = 0xa
			i = encodeVarintContract(dAtA, i, uint64(baseI-i))
			i--
			dAtA[i] = 0x2a
		}
	}
	if len(m.PeerCert) > 0 {
		i -= len(m.PeerCert)
		copy(dAtA[i:], m.PeerCert)
		i = encodeVarintContract(dAtA, i, uint64(len(m.PeerCert)))
		i--
		dAtA[i] = 0x22
	}
	if len(m.Code) > 0 {
		i -= len(m.Code)
		copy(dAtA[i:], m.Code)
		i = encodeVarintContract(dAtA, i, uint64(len(m.Code)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.SchemaVersion) > 0 {
		i -= len(m.SchemaVersion)
		copy(dAtA[i:], m.SchemaVersion)
		i = encodeVarintContract(dAtA, i, uint64(len(m.SchemaVersion)))
		i--
		dAtA[i] = 0x12
	}
	if m.SandboxType != 0 {
		i = encodeVarintContract(dAtA, i, uint64(m.SandboxType))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *LogRotation) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *LogRotation) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *LogRotation) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Compress {
		i--
		if m.Compress {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x38
	}
	if m.LocalTime {
		i--
		if m.LocalTime {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x30
	}
	if m.MaxBackups != 0 {
		i = encodeVarintContract(dAtA, i, uint64(m.MaxBackups))
		i--
		dAtA[i] = 0x28
	}
	if m.MaxAge != 0 {
		i = encodeVarintContract(dAtA, i, uint64(m.MaxAge))
		i--
		dAtA[i] = 0x20
	}
	if m.MaxSize != 0 {
		i = encodeVarintContract(dAtA, i, uint64(m.MaxSize))
		i--
		dAtA[i] = 0x18
	}
	if len(m.Filename) > 0 {
		i -= len(m.Filename)
		copy(dAtA[i:], m.Filename)
		i = encodeVarintContract(dAtA, i, uint64(len(m.Filename)))
		i--
		dAtA[i] = 0x12
	}
	if m.Enabled {
		i--
		if m.Enabled {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *ContractConfig) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ContractConfig) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ContractConfig) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Rotation != nil {
		{
			size, err := m.Rotation.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintContract(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x52
	}
	if len(m.Extension) > 0 {
		i -= len(m.Extension)
		copy(dAtA[i:], m.Extension)
		i = encodeVarintContract(dAtA, i, uint64(len(m.Extension)))
		i--
		dAtA[i] = 0x4a
	}
	if len(m.ContractName) > 0 {
		i -= len(m.ContractName)
		copy(dAtA[i:], m.ContractName)
		i = encodeVarintContract(dAtA, i, uint64(len(m.ContractName)))
		i--
		dAtA[i] = 0x42
	}
	if len(m.ChainID) > 0 {
		i -= len(m.ChainID)
		copy(dAtA[i:], m.ChainID)
		i = encodeVarintContract(dAtA, i, uint64(len(m.ChainID)))
		i--
		dAtA[i] = 0x3a
	}
	if len(m.NodeName) > 0 {
		i -= len(m.NodeName)
		copy(dAtA[i:], m.NodeName)
		i = encodeVarintContract(dAtA, i, uint64(len(m.NodeName)))
		i--
		dAtA[i] = 0x32
	}
	if len(m.NodeAddr) > 0 {
		i -= len(m.NodeAddr)
		copy(dAtA[i:], m.NodeAddr)
		i = encodeVarintContract(dAtA, i, uint64(len(m.NodeAddr)))
		i--
		dAtA[i] = 0x2a
	}
	if len(m.LogLevel) > 0 {
		i -= len(m.LogLevel)
		copy(dAtA[i:], m.LogLevel)
		i = encodeVarintContract(dAtA, i, uint64(len(m.LogLevel)))
		i--
		dAtA[i] = 0x22
	}
	if len(m.Port) > 0 {
		i -= len(m.Port)
		copy(dAtA[i:], m.Port)
		i = encodeVarintContract(dAtA, i, uint64(len(m.Port)))
		i--
		dAtA[i] = 0x1a
	}
	if m.GrpcConfig != nil {
		{
			size, err := m.GrpcConfig.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintContract(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	if m.TlsConfig != nil {
		{
			size, err := m.TlsConfig.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintContract(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *ContractGRPCConfig) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ContractGRPCConfig) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ContractGRPCConfig) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.MaxRecvMsgSize != 0 {
		i = encodeVarintContract(dAtA, i, uint64(m.MaxRecvMsgSize))
		i--
		dAtA[i] = 0x30
	}
	if m.MaxSendMsgSize != 0 {
		i = encodeVarintContract(dAtA, i, uint64(m.MaxSendMsgSize))
		i--
		dAtA[i] = 0x28
	}
	if m.MaxConcurrentStreams != 0 {
		i = encodeVarintContract(dAtA, i, uint64(m.MaxConcurrentStreams))
		i--
		dAtA[i] = 0x20
	}
	if m.MinInterval != 0 {
		i = encodeVarintContract(dAtA, i, uint64(m.MinInterval))
		i--
		dAtA[i] = 0x18
	}
	if m.Timeout != 0 {
		i = encodeVarintContract(dAtA, i, uint64(m.Timeout))
		i--
		dAtA[i] = 0x10
	}
	if m.Interval != 0 {
		i = encodeVarintContract(dAtA, i, uint64(m.Interval))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *ContractTLSConfig) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ContractTLSConfig) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ContractTLSConfig) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.ServerName) > 0 {
		i -= len(m.ServerName)
		copy(dAtA[i:], m.ServerName)
		i = encodeVarintContract(dAtA, i, uint64(len(m.ServerName)))
		i--
		dAtA[i] = 0x32
	}
	if len(m.PeerRootcertsPath) > 0 {
		for iNdEx := len(m.PeerRootcertsPath) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.PeerRootcertsPath[iNdEx])
			copy(dAtA[i:], m.PeerRootcertsPath[iNdEx])
			i = encodeVarintContract(dAtA, i, uint64(len(m.PeerRootcertsPath[iNdEx])))
			i--
			dAtA[i] = 0x2a
		}
	}
	if len(m.KeyPath) > 0 {
		i -= len(m.KeyPath)
		copy(dAtA[i:], m.KeyPath)
		i = encodeVarintContract(dAtA, i, uint64(len(m.KeyPath)))
		i--
		dAtA[i] = 0x22
	}
	if len(m.CertPath) > 0 {
		i -= len(m.CertPath)
		copy(dAtA[i:], m.CertPath)
		i = encodeVarintContract(dAtA, i, uint64(len(m.CertPath)))
		i--
		dAtA[i] = 0x1a
	}
	if m.IsMultiTls {
		i--
		if m.IsMultiTls {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x10
	}
	if m.IsTlsEnabled {
		i--
		if m.IsTlsEnabled {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *ContractMsg) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ContractMsg) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ContractMsg) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.InstanceName) > 0 {
		i -= len(m.InstanceName)
		copy(dAtA[i:], m.InstanceName)
		i = encodeVarintContract(dAtA, i, uint64(len(m.InstanceName)))
		i--
		dAtA[i] = 0x3a
	}
	if len(m.Chainid) > 0 {
		i -= len(m.Chainid)
		copy(dAtA[i:], m.Chainid)
		i = encodeVarintContract(dAtA, i, uint64(len(m.Chainid)))
		i--
		dAtA[i] = 0x32
	}
	if len(m.Contractid) > 0 {
		i -= len(m.Contractid)
		copy(dAtA[i:], m.Contractid)
		i = encodeVarintContract(dAtA, i, uint64(len(m.Contractid)))
		i--
		dAtA[i] = 0x2a
	}
	if len(m.Txid) > 0 {
		i -= len(m.Txid)
		copy(dAtA[i:], m.Txid)
		i = encodeVarintContract(dAtA, i, uint64(len(m.Txid)))
		i--
		dAtA[i] = 0x22
	}
	if len(m.Payload) > 0 {
		i -= len(m.Payload)
		copy(dAtA[i:], m.Payload)
		i = encodeVarintContract(dAtA, i, uint64(len(m.Payload)))
		i--
		dAtA[i] = 0x1a
	}
	if m.Type != 0 {
		i = encodeVarintContract(dAtA, i, uint64(m.Type))
		i--
		dAtA[i] = 0x10
	}
	if m.Stage != 0 {
		i = encodeVarintContract(dAtA, i, uint64(m.Stage))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *ContractMsgsWrap) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ContractMsgsWrap) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ContractMsgsWrap) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Msgs) > 0 {
		for iNdEx := len(m.Msgs) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Msgs[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintContract(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *InstanceId) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *InstanceId) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *InstanceId) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Extension) > 0 {
		i -= len(m.Extension)
		copy(dAtA[i:], m.Extension)
		i = encodeVarintContract(dAtA, i, uint64(len(m.Extension)))
		i--
		dAtA[i] = 0x22
	}
	if len(m.Msg) > 0 {
		i -= len(m.Msg)
		copy(dAtA[i:], m.Msg)
		i = encodeVarintContract(dAtA, i, uint64(len(m.Msg)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.Sig) > 0 {
		i -= len(m.Sig)
		copy(dAtA[i:], m.Sig)
		i = encodeVarintContract(dAtA, i, uint64(len(m.Sig)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Identity) > 0 {
		i -= len(m.Identity)
		copy(dAtA[i:], m.Identity)
		i = encodeVarintContract(dAtA, i, uint64(len(m.Identity)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *InvokeMsg) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *InvokeMsg) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *InvokeMsg) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Cn) > 0 {
		i -= len(m.Cn)
		copy(dAtA[i:], m.Cn)
		i = encodeVarintContract(dAtA, i, uint64(len(m.Cn)))
		i--
		dAtA[i] = 0x22
	}
	if len(m.Orgs) > 0 {
		for iNdEx := len(m.Orgs) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.Orgs[iNdEx])
			copy(dAtA[i:], m.Orgs[iNdEx])
			i = encodeVarintContract(dAtA, i, uint64(len(m.Orgs[iNdEx])))
			i--
			dAtA[i] = 0x1a
		}
	}
	if len(m.Args) > 0 {
		for iNdEx := len(m.Args) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.Args[iNdEx])
			copy(dAtA[i:], m.Args[iNdEx])
			i = encodeVarintContract(dAtA, i, uint64(len(m.Args[iNdEx])))
			i--
			dAtA[i] = 0x12
		}
	}
	if len(m.FuncName) > 0 {
		i -= len(m.FuncName)
		copy(dAtA[i:], m.FuncName)
		i = encodeVarintContract(dAtA, i, uint64(len(m.FuncName)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *GetState) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GetState) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *GetState) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Key) > 0 {
		i -= len(m.Key)
		copy(dAtA[i:], m.Key)
		i = encodeVarintContract(dAtA, i, uint64(len(m.Key)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *PutState) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *PutState) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *PutState) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Value) > 0 {
		i -= len(m.Value)
		copy(dAtA[i:], m.Value)
		i = encodeVarintContract(dAtA, i, uint64(len(m.Value)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Key) > 0 {
		i -= len(m.Key)
		copy(dAtA[i:], m.Key)
		i = encodeVarintContract(dAtA, i, uint64(len(m.Key)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *DelState) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *DelState) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *DelState) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Key) > 0 {
		i -= len(m.Key)
		copy(dAtA[i:], m.Key)
		i = encodeVarintContract(dAtA, i, uint64(len(m.Key)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *GetStateByRange) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GetStateByRange) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *GetStateByRange) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.QueryId) > 0 {
		i -= len(m.QueryId)
		copy(dAtA[i:], m.QueryId)
		i = encodeVarintContract(dAtA, i, uint64(len(m.QueryId)))
		i--
		dAtA[i] = 0x2a
	}
	if m.BufferSize != 0 {
		i = encodeVarintContract(dAtA, i, uint64(m.BufferSize))
		i--
		dAtA[i] = 0x18
	}
	if len(m.EndKey) > 0 {
		i -= len(m.EndKey)
		copy(dAtA[i:], m.EndKey)
		i = encodeVarintContract(dAtA, i, uint64(len(m.EndKey)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.BeginKey) > 0 {
		i -= len(m.BeginKey)
		copy(dAtA[i:], m.BeginKey)
		i = encodeVarintContract(dAtA, i, uint64(len(m.BeginKey)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *GetHistoryForKey) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GetHistoryForKey) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *GetHistoryForKey) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.QueryId) > 0 {
		i -= len(m.QueryId)
		copy(dAtA[i:], m.QueryId)
		i = encodeVarintContract(dAtA, i, uint64(len(m.QueryId)))
		i--
		dAtA[i] = 0x1a
	}
	if m.BufferSize != 0 {
		i = encodeVarintContract(dAtA, i, uint64(m.BufferSize))
		i--
		dAtA[i] = 0x10
	}
	if len(m.Key) > 0 {
		i -= len(m.Key)
		copy(dAtA[i:], m.Key)
		i = encodeVarintContract(dAtA, i, uint64(len(m.Key)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *HistoryForKey) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *HistoryForKey) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *HistoryForKey) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.QueryId) > 0 {
		i -= len(m.QueryId)
		copy(dAtA[i:], m.QueryId)
		i = encodeVarintContract(dAtA, i, uint64(len(m.QueryId)))
		i--
		dAtA[i] = 0x1a
	}
	if m.IsOver {
		i--
		if m.IsOver {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x10
	}
	if len(m.HistoryArray) > 0 {
		for iNdEx := len(m.HistoryArray) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.HistoryArray[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintContract(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *QueryResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *QueryResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *QueryResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.QueryId) > 0 {
		i -= len(m.QueryId)
		copy(dAtA[i:], m.QueryId)
		i = encodeVarintContract(dAtA, i, uint64(len(m.QueryId)))
		i--
		dAtA[i] = 0x1a
	}
	if m.IsOver {
		i--
		if m.IsOver {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x10
	}
	if len(m.KvArray) > 0 {
		for iNdEx := len(m.KvArray) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.KvArray[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintContract(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *KVInfo) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *KVInfo) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *KVInfo) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Value) > 0 {
		i -= len(m.Value)
		copy(dAtA[i:], m.Value)
		i = encodeVarintContract(dAtA, i, uint64(len(m.Value)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Key) > 0 {
		i -= len(m.Key)
		copy(dAtA[i:], m.Key)
		i = encodeVarintContract(dAtA, i, uint64(len(m.Key)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *SqlQuery) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SqlQuery) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *SqlQuery) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.QId) > 0 {
		i -= len(m.QId)
		copy(dAtA[i:], m.QId)
		i = encodeVarintContract(dAtA, i, uint64(len(m.QId)))
		i--
		dAtA[i] = 0x22
	}
	if m.BufferSize != 0 {
		i = encodeVarintContract(dAtA, i, uint64(m.BufferSize))
		i--
		dAtA[i] = 0x18
	}
	if m.Args != nil {
		{
			size, err := m.Args.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintContract(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	if len(m.Query) > 0 {
		i -= len(m.Query)
		copy(dAtA[i:], m.Query)
		i = encodeVarintContract(dAtA, i, uint64(len(m.Query)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *SqlExec) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SqlExec) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *SqlExec) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Args != nil {
		{
			size, err := m.Args.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintContract(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	if len(m.Query) > 0 {
		i -= len(m.Query)
		copy(dAtA[i:], m.Query)
		i = encodeVarintContract(dAtA, i, uint64(len(m.Query)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *SqlQueryResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SqlQueryResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *SqlQueryResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.QueryId) > 0 {
		i -= len(m.QueryId)
		copy(dAtA[i:], m.QueryId)
		i = encodeVarintContract(dAtA, i, uint64(len(m.QueryId)))
		i--
		dAtA[i] = 0x1a
	}
	if m.IsOver {
		i--
		if m.IsOver {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x10
	}
	if m.SqlRows != nil {
		{
			size, err := m.SqlRows.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintContract(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *SqlRows) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SqlRows) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *SqlRows) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Rows) > 0 {
		for iNdEx := len(m.Rows) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Rows[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintContract(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *SqlRow) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SqlRow) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *SqlRow) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Columns) > 0 {
		for iNdEx := len(m.Columns) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Columns[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintContract(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *SqlColumn) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SqlColumn) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *SqlColumn) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Value) > 0 {
		i -= len(m.Value)
		copy(dAtA[i:], m.Value)
		i = encodeVarintContract(dAtA, i, uint64(len(m.Value)))
		i--
		dAtA[i] = 0x1a
	}
	if m.Index != 0 {
		i = encodeVarintContract(dAtA, i, uint64(m.Index))
		i--
		dAtA[i] = 0x10
	}
	if len(m.Name) > 0 {
		i -= len(m.Name)
		copy(dAtA[i:], m.Name)
		i = encodeVarintContract(dAtA, i, uint64(len(m.Name)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *Response) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Response) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Response) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Payload) > 0 {
		i -= len(m.Payload)
		copy(dAtA[i:], m.Payload)
		i = encodeVarintContract(dAtA, i, uint64(len(m.Payload)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.Message) > 0 {
		i -= len(m.Message)
		copy(dAtA[i:], m.Message)
		i = encodeVarintContract(dAtA, i, uint64(len(m.Message)))
		i--
		dAtA[i] = 0x12
	}
	if m.Status != 0 {
		i = encodeVarintContract(dAtA, i, uint64(m.Status))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func encodeVarintContract(dAtA []byte, offset int, v uint64) int {
	offset -= sovContract(v)
	base := offset
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return base
}
func (m *ContractDefinition) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.ContractName)
	if l > 0 {
		n += 1 + l + sovContract(uint64(l))
	}
	l = len(m.SchemaVersion)
	if l > 0 {
		n += 1 + l + sovContract(uint64(l))
	}
	if m.SequenceNumber != 0 {
		n += 1 + sovContract(uint64(m.SequenceNumber))
	}
	l = len(m.Description)
	if l > 0 {
		n += 1 + l + sovContract(uint64(l))
	}
	if m.RequireInit {
		n += 2
	}
	l = len(m.SqlDbSchema)
	if l > 0 {
		n += 1 + l + sovContract(uint64(l))
	}
	if m.HistorySupport {
		n += 2
	}
	l = len(m.ApprovalValidator)
	if l > 0 {
		n += 1 + l + sovContract(uint64(l))
	}
	if len(m.ValidatorExtensions) > 0 {
		for k, v := range m.ValidatorExtensions {
			_ = k
			_ = v
			l = 0
			if len(v) > 0 {
				l = 1 + len(v) + sovContract(uint64(len(v)))
			}
			mapEntrySize := 1 + len(k) + sovContract(uint64(len(k))) + l
			n += mapEntrySize + 1 + sovContract(uint64(mapEntrySize))
		}
	}
	return n
}

func (m *DockerImageInfo) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.ID)
	if l > 0 {
		n += 1 + l + sovContract(uint64(l))
	}
	l = len(m.RepoTag)
	if l > 0 {
		n += 1 + l + sovContract(uint64(l))
	}
	return n
}

func (m *ExternalContractInfo) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.SandboxType != 0 {
		n += 1 + sovContract(uint64(m.SandboxType))
	}
	l = len(m.SchemaVersion)
	if l > 0 {
		n += 1 + l + sovContract(uint64(l))
	}
	l = len(m.Code)
	if l > 0 {
		n += 1 + l + sovContract(uint64(l))
	}
	l = len(m.PeerCert)
	if l > 0 {
		n += 1 + l + sovContract(uint64(l))
	}
	if len(m.Extensions) > 0 {
		for k, v := range m.Extensions {
			_ = k
			_ = v
			l = 0
			if len(v) > 0 {
				l = 1 + len(v) + sovContract(uint64(len(v)))
			}
			mapEntrySize := 1 + len(k) + sovContract(uint64(len(k))) + l
			n += mapEntrySize + 1 + sovContract(uint64(mapEntrySize))
		}
	}
	l = len(m.Language)
	if l > 0 {
		n += 1 + l + sovContract(uint64(l))
	}
	return n
}

func (m *LogRotation) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Enabled {
		n += 2
	}
	l = len(m.Filename)
	if l > 0 {
		n += 1 + l + sovContract(uint64(l))
	}
	if m.MaxSize != 0 {
		n += 1 + sovContract(uint64(m.MaxSize))
	}
	if m.MaxAge != 0 {
		n += 1 + sovContract(uint64(m.MaxAge))
	}
	if m.MaxBackups != 0 {
		n += 1 + sovContract(uint64(m.MaxBackups))
	}
	if m.LocalTime {
		n += 2
	}
	if m.Compress {
		n += 2
	}
	return n
}

func (m *ContractConfig) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.TlsConfig != nil {
		l = m.TlsConfig.Size()
		n += 1 + l + sovContract(uint64(l))
	}
	if m.GrpcConfig != nil {
		l = m.GrpcConfig.Size()
		n += 1 + l + sovContract(uint64(l))
	}
	l = len(m.Port)
	if l > 0 {
		n += 1 + l + sovContract(uint64(l))
	}
	l = len(m.LogLevel)
	if l > 0 {
		n += 1 + l + sovContract(uint64(l))
	}
	l = len(m.NodeAddr)
	if l > 0 {
		n += 1 + l + sovContract(uint64(l))
	}
	l = len(m.NodeName)
	if l > 0 {
		n += 1 + l + sovContract(uint64(l))
	}
	l = len(m.ChainID)
	if l > 0 {
		n += 1 + l + sovContract(uint64(l))
	}
	l = len(m.ContractName)
	if l > 0 {
		n += 1 + l + sovContract(uint64(l))
	}
	l = len(m.Extension)
	if l > 0 {
		n += 1 + l + sovContract(uint64(l))
	}
	if m.Rotation != nil {
		l = m.Rotation.Size()
		n += 1 + l + sovContract(uint64(l))
	}
	return n
}

func (m *ContractGRPCConfig) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Interval != 0 {
		n += 1 + sovContract(uint64(m.Interval))
	}
	if m.Timeout != 0 {
		n += 1 + sovContract(uint64(m.Timeout))
	}
	if m.MinInterval != 0 {
		n += 1 + sovContract(uint64(m.MinInterval))
	}
	if m.MaxConcurrentStreams != 0 {
		n += 1 + sovContract(uint64(m.MaxConcurrentStreams))
	}
	if m.MaxSendMsgSize != 0 {
		n += 1 + sovContract(uint64(m.MaxSendMsgSize))
	}
	if m.MaxRecvMsgSize != 0 {
		n += 1 + sovContract(uint64(m.MaxRecvMsgSize))
	}
	return n
}

func (m *ContractTLSConfig) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.IsTlsEnabled {
		n += 2
	}
	if m.IsMultiTls {
		n += 2
	}
	l = len(m.CertPath)
	if l > 0 {
		n += 1 + l + sovContract(uint64(l))
	}
	l = len(m.KeyPath)
	if l > 0 {
		n += 1 + l + sovContract(uint64(l))
	}
	if len(m.PeerRootcertsPath) > 0 {
		for _, s := range m.PeerRootcertsPath {
			l = len(s)
			n += 1 + l + sovContract(uint64(l))
		}
	}
	l = len(m.ServerName)
	if l > 0 {
		n += 1 + l + sovContract(uint64(l))
	}
	return n
}

func (m *ContractMsg) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Stage != 0 {
		n += 1 + sovContract(uint64(m.Stage))
	}
	if m.Type != 0 {
		n += 1 + sovContract(uint64(m.Type))
	}
	l = len(m.Payload)
	if l > 0 {
		n += 1 + l + sovContract(uint64(l))
	}
	l = len(m.Txid)
	if l > 0 {
		n += 1 + l + sovContract(uint64(l))
	}
	l = len(m.Contractid)
	if l > 0 {
		n += 1 + l + sovContract(uint64(l))
	}
	l = len(m.Chainid)
	if l > 0 {
		n += 1 + l + sovContract(uint64(l))
	}
	l = len(m.InstanceName)
	if l > 0 {
		n += 1 + l + sovContract(uint64(l))
	}
	return n
}

func (m *ContractMsgsWrap) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Msgs) > 0 {
		for _, e := range m.Msgs {
			l = e.Size()
			n += 1 + l + sovContract(uint64(l))
		}
	}
	return n
}

func (m *InstanceId) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Identity)
	if l > 0 {
		n += 1 + l + sovContract(uint64(l))
	}
	l = len(m.Sig)
	if l > 0 {
		n += 1 + l + sovContract(uint64(l))
	}
	l = len(m.Msg)
	if l > 0 {
		n += 1 + l + sovContract(uint64(l))
	}
	l = len(m.Extension)
	if l > 0 {
		n += 1 + l + sovContract(uint64(l))
	}
	return n
}

func (m *InvokeMsg) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.FuncName)
	if l > 0 {
		n += 1 + l + sovContract(uint64(l))
	}
	if len(m.Args) > 0 {
		for _, b := range m.Args {
			l = len(b)
			n += 1 + l + sovContract(uint64(l))
		}
	}
	if len(m.Orgs) > 0 {
		for _, s := range m.Orgs {
			l = len(s)
			n += 1 + l + sovContract(uint64(l))
		}
	}
	l = len(m.Cn)
	if l > 0 {
		n += 1 + l + sovContract(uint64(l))
	}
	return n
}

func (m *GetState) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Key)
	if l > 0 {
		n += 1 + l + sovContract(uint64(l))
	}
	return n
}

func (m *PutState) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Key)
	if l > 0 {
		n += 1 + l + sovContract(uint64(l))
	}
	l = len(m.Value)
	if l > 0 {
		n += 1 + l + sovContract(uint64(l))
	}
	return n
}

func (m *DelState) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Key)
	if l > 0 {
		n += 1 + l + sovContract(uint64(l))
	}
	return n
}

func (m *GetStateByRange) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.BeginKey)
	if l > 0 {
		n += 1 + l + sovContract(uint64(l))
	}
	l = len(m.EndKey)
	if l > 0 {
		n += 1 + l + sovContract(uint64(l))
	}
	if m.BufferSize != 0 {
		n += 1 + sovContract(uint64(m.BufferSize))
	}
	l = len(m.QueryId)
	if l > 0 {
		n += 1 + l + sovContract(uint64(l))
	}
	return n
}

func (m *GetHistoryForKey) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Key)
	if l > 0 {
		n += 1 + l + sovContract(uint64(l))
	}
	if m.BufferSize != 0 {
		n += 1 + sovContract(uint64(m.BufferSize))
	}
	l = len(m.QueryId)
	if l > 0 {
		n += 1 + l + sovContract(uint64(l))
	}
	return n
}

func (m *HistoryForKey) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.HistoryArray) > 0 {
		for _, e := range m.HistoryArray {
			l = e.Size()
			n += 1 + l + sovContract(uint64(l))
		}
	}
	if m.IsOver {
		n += 2
	}
	l = len(m.QueryId)
	if l > 0 {
		n += 1 + l + sovContract(uint64(l))
	}
	return n
}

func (m *QueryResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.KvArray) > 0 {
		for _, e := range m.KvArray {
			l = e.Size()
			n += 1 + l + sovContract(uint64(l))
		}
	}
	if m.IsOver {
		n += 2
	}
	l = len(m.QueryId)
	if l > 0 {
		n += 1 + l + sovContract(uint64(l))
	}
	return n
}

func (m *KVInfo) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Key)
	if l > 0 {
		n += 1 + l + sovContract(uint64(l))
	}
	l = len(m.Value)
	if l > 0 {
		n += 1 + l + sovContract(uint64(l))
	}
	return n
}

func (m *SqlQuery) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Query)
	if l > 0 {
		n += 1 + l + sovContract(uint64(l))
	}
	if m.Args != nil {
		l = m.Args.Size()
		n += 1 + l + sovContract(uint64(l))
	}
	if m.BufferSize != 0 {
		n += 1 + sovContract(uint64(m.BufferSize))
	}
	l = len(m.QId)
	if l > 0 {
		n += 1 + l + sovContract(uint64(l))
	}
	return n
}

func (m *SqlExec) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Query)
	if l > 0 {
		n += 1 + l + sovContract(uint64(l))
	}
	if m.Args != nil {
		l = m.Args.Size()
		n += 1 + l + sovContract(uint64(l))
	}
	return n
}

func (m *SqlQueryResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.SqlRows != nil {
		l = m.SqlRows.Size()
		n += 1 + l + sovContract(uint64(l))
	}
	if m.IsOver {
		n += 2
	}
	l = len(m.QueryId)
	if l > 0 {
		n += 1 + l + sovContract(uint64(l))
	}
	return n
}

func (m *SqlRows) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Rows) > 0 {
		for _, e := range m.Rows {
			l = e.Size()
			n += 1 + l + sovContract(uint64(l))
		}
	}
	return n
}

func (m *SqlRow) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Columns) > 0 {
		for _, e := range m.Columns {
			l = e.Size()
			n += 1 + l + sovContract(uint64(l))
		}
	}
	return n
}

func (m *SqlColumn) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovContract(uint64(l))
	}
	if m.Index != 0 {
		n += 1 + sovContract(uint64(m.Index))
	}
	l = len(m.Value)
	if l > 0 {
		n += 1 + l + sovContract(uint64(l))
	}
	return n
}

func (m *Response) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Status != 0 {
		n += 1 + sovContract(uint64(m.Status))
	}
	l = len(m.Message)
	if l > 0 {
		n += 1 + l + sovContract(uint64(l))
	}
	l = len(m.Payload)
	if l > 0 {
		n += 1 + l + sovContract(uint64(l))
	}
	return n
}

func sovContract(x uint64) (n int) {
	return (math_bits.Len64(x|1) + 6) / 7
}
func sozContract(x uint64) (n int) {
	return sovContract(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (m *ContractDefinition) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowContract
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ContractDefinition: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ContractDefinition: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ContractName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContract
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthContract
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthContract
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ContractName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SchemaVersion", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContract
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthContract
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthContract
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.SchemaVersion = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SequenceNumber", wireType)
			}
			m.SequenceNumber = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContract
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.SequenceNumber |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Description", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContract
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthContract
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthContract
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Description = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RequireInit", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContract
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.RequireInit = bool(v != 0)
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SqlDbSchema", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContract
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthContract
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthContract
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.SqlDbSchema = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field HistorySupport", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContract
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.HistorySupport = bool(v != 0)
		case 10:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ApprovalValidator", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContract
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthContract
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthContract
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ApprovalValidator = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 11:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ValidatorExtensions", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContract
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthContract
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthContract
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.ValidatorExtensions == nil {
				m.ValidatorExtensions = make(map[string][]byte)
			}
			var mapkey string
			mapvalue := []byte{}
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowContract
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					var stringLenmapkey uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowContract
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapkey |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapkey := int(stringLenmapkey)
					if intStringLenmapkey < 0 {
						return ErrInvalidLengthContract
					}
					postStringIndexmapkey := iNdEx + intStringLenmapkey
					if postStringIndexmapkey < 0 {
						return ErrInvalidLengthContract
					}
					if postStringIndexmapkey > l {
						return io.ErrUnexpectedEOF
					}
					mapkey = string(dAtA[iNdEx:postStringIndexmapkey])
					iNdEx = postStringIndexmapkey
				} else if fieldNum == 2 {
					var mapbyteLen uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowContract
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapbyteLen |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intMapbyteLen := int(mapbyteLen)
					if intMapbyteLen < 0 {
						return ErrInvalidLengthContract
					}
					postbytesIndex := iNdEx + intMapbyteLen
					if postbytesIndex < 0 {
						return ErrInvalidLengthContract
					}
					if postbytesIndex > l {
						return io.ErrUnexpectedEOF
					}
					mapvalue = make([]byte, mapbyteLen)
					copy(mapvalue, dAtA[iNdEx:postbytesIndex])
					iNdEx = postbytesIndex
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipContract(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if (skippy < 0) || (iNdEx+skippy) < 0 {
						return ErrInvalidLengthContract
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.ValidatorExtensions[mapkey] = mapvalue
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipContract(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthContract
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *DockerImageInfo) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowContract
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: DockerImageInfo: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: DockerImageInfo: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ID", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContract
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthContract
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthContract
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ID = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RepoTag", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContract
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthContract
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthContract
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.RepoTag = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipContract(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthContract
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ExternalContractInfo) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowContract
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ExternalContractInfo: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ExternalContractInfo: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SandboxType", wireType)
			}
			m.SandboxType = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContract
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.SandboxType |= common.ContractRunEnv(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SchemaVersion", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContract
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthContract
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthContract
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.SchemaVersion = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Code", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContract
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthContract
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthContract
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Code = append(m.Code[:0], dAtA[iNdEx:postIndex]...)
			if m.Code == nil {
				m.Code = []byte{}
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PeerCert", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContract
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthContract
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthContract
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.PeerCert = append(m.PeerCert[:0], dAtA[iNdEx:postIndex]...)
			if m.PeerCert == nil {
				m.PeerCert = []byte{}
			}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Extensions", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContract
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthContract
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthContract
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Extensions == nil {
				m.Extensions = make(map[string][]byte)
			}
			var mapkey string
			mapvalue := []byte{}
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowContract
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					var stringLenmapkey uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowContract
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapkey |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapkey := int(stringLenmapkey)
					if intStringLenmapkey < 0 {
						return ErrInvalidLengthContract
					}
					postStringIndexmapkey := iNdEx + intStringLenmapkey
					if postStringIndexmapkey < 0 {
						return ErrInvalidLengthContract
					}
					if postStringIndexmapkey > l {
						return io.ErrUnexpectedEOF
					}
					mapkey = string(dAtA[iNdEx:postStringIndexmapkey])
					iNdEx = postStringIndexmapkey
				} else if fieldNum == 2 {
					var mapbyteLen uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowContract
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapbyteLen |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intMapbyteLen := int(mapbyteLen)
					if intMapbyteLen < 0 {
						return ErrInvalidLengthContract
					}
					postbytesIndex := iNdEx + intMapbyteLen
					if postbytesIndex < 0 {
						return ErrInvalidLengthContract
					}
					if postbytesIndex > l {
						return io.ErrUnexpectedEOF
					}
					mapvalue = make([]byte, mapbyteLen)
					copy(mapvalue, dAtA[iNdEx:postbytesIndex])
					iNdEx = postbytesIndex
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipContract(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if (skippy < 0) || (iNdEx+skippy) < 0 {
						return ErrInvalidLengthContract
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.Extensions[mapkey] = mapvalue
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Language", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContract
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthContract
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthContract
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Language = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipContract(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthContract
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *LogRotation) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowContract
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: LogRotation: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: LogRotation: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Enabled", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContract
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Enabled = bool(v != 0)
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Filename", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContract
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthContract
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthContract
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Filename = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MaxSize", wireType)
			}
			m.MaxSize = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContract
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MaxSize |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MaxAge", wireType)
			}
			m.MaxAge = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContract
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MaxAge |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MaxBackups", wireType)
			}
			m.MaxBackups = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContract
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MaxBackups |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field LocalTime", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContract
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.LocalTime = bool(v != 0)
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Compress", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContract
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Compress = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipContract(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthContract
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ContractConfig) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowContract
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ContractConfig: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ContractConfig: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TlsConfig", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContract
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthContract
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthContract
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.TlsConfig == nil {
				m.TlsConfig = &ContractTLSConfig{}
			}
			if err := m.TlsConfig.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field GrpcConfig", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContract
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthContract
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthContract
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.GrpcConfig == nil {
				m.GrpcConfig = &ContractGRPCConfig{}
			}
			if err := m.GrpcConfig.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Port", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContract
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthContract
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthContract
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Port = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field LogLevel", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContract
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthContract
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthContract
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.LogLevel = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field NodeAddr", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContract
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthContract
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthContract
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.NodeAddr = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field NodeName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContract
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthContract
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthContract
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.NodeName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ChainID", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContract
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthContract
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthContract
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ChainID = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ContractName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContract
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthContract
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthContract
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ContractName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Extension", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContract
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthContract
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthContract
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Extension = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 10:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Rotation", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContract
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthContract
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthContract
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Rotation == nil {
				m.Rotation = &LogRotation{}
			}
			if err := m.Rotation.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipContract(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthContract
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ContractGRPCConfig) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowContract
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ContractGRPCConfig: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ContractGRPCConfig: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Interval", wireType)
			}
			m.Interval = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContract
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Interval |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Timeout", wireType)
			}
			m.Timeout = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContract
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Timeout |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MinInterval", wireType)
			}
			m.MinInterval = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContract
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MinInterval |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MaxConcurrentStreams", wireType)
			}
			m.MaxConcurrentStreams = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContract
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MaxConcurrentStreams |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MaxSendMsgSize", wireType)
			}
			m.MaxSendMsgSize = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContract
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MaxSendMsgSize |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MaxRecvMsgSize", wireType)
			}
			m.MaxRecvMsgSize = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContract
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MaxRecvMsgSize |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipContract(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthContract
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ContractTLSConfig) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowContract
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ContractTLSConfig: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ContractTLSConfig: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IsTlsEnabled", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContract
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.IsTlsEnabled = bool(v != 0)
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IsMultiTls", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContract
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.IsMultiTls = bool(v != 0)
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CertPath", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContract
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthContract
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthContract
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.CertPath = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field KeyPath", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContract
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthContract
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthContract
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.KeyPath = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PeerRootcertsPath", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContract
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthContract
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthContract
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.PeerRootcertsPath = append(m.PeerRootcertsPath, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ServerName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContract
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthContract
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthContract
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ServerName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipContract(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthContract
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ContractMsg) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowContract
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ContractMsg: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ContractMsg: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Stage", wireType)
			}
			m.Stage = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContract
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Stage |= ContractMsg_Stage(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Type", wireType)
			}
			m.Type = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContract
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Type |= ContractMsg_Type(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Payload", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContract
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthContract
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthContract
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Payload = append(m.Payload[:0], dAtA[iNdEx:postIndex]...)
			if m.Payload == nil {
				m.Payload = []byte{}
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Txid", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContract
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthContract
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthContract
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Txid = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Contractid", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContract
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthContract
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthContract
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Contractid = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Chainid", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContract
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthContract
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthContract
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Chainid = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field InstanceName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContract
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthContract
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthContract
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.InstanceName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipContract(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthContract
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ContractMsgsWrap) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowContract
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ContractMsgsWrap: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ContractMsgsWrap: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Msgs", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContract
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthContract
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthContract
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Msgs = append(m.Msgs, &ContractMsg{})
			if err := m.Msgs[len(m.Msgs)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipContract(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthContract
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *InstanceId) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowContract
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: InstanceId: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: InstanceId: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Identity", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContract
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthContract
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthContract
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Identity = append(m.Identity[:0], dAtA[iNdEx:postIndex]...)
			if m.Identity == nil {
				m.Identity = []byte{}
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Sig", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContract
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthContract
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthContract
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Sig = append(m.Sig[:0], dAtA[iNdEx:postIndex]...)
			if m.Sig == nil {
				m.Sig = []byte{}
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Msg", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContract
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthContract
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthContract
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Msg = append(m.Msg[:0], dAtA[iNdEx:postIndex]...)
			if m.Msg == nil {
				m.Msg = []byte{}
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Extension", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContract
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthContract
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthContract
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Extension = append(m.Extension[:0], dAtA[iNdEx:postIndex]...)
			if m.Extension == nil {
				m.Extension = []byte{}
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipContract(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthContract
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *InvokeMsg) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowContract
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: InvokeMsg: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: InvokeMsg: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field FuncName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContract
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthContract
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthContract
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.FuncName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Args", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContract
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthContract
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthContract
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Args = append(m.Args, make([]byte, postIndex-iNdEx))
			copy(m.Args[len(m.Args)-1], dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Orgs", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContract
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthContract
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthContract
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Orgs = append(m.Orgs, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Cn", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContract
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthContract
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthContract
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Cn = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipContract(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthContract
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GetState) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowContract
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GetState: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GetState: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Key", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContract
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthContract
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthContract
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Key = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipContract(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthContract
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *PutState) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowContract
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: PutState: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: PutState: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Key", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContract
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthContract
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthContract
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Key = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Value", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContract
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthContract
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthContract
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Value = append(m.Value[:0], dAtA[iNdEx:postIndex]...)
			if m.Value == nil {
				m.Value = []byte{}
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipContract(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthContract
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *DelState) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowContract
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: DelState: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: DelState: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Key", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContract
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthContract
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthContract
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Key = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipContract(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthContract
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GetStateByRange) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowContract
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GetStateByRange: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GetStateByRange: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field BeginKey", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContract
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthContract
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthContract
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.BeginKey = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field EndKey", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContract
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthContract
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthContract
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.EndKey = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field BufferSize", wireType)
			}
			m.BufferSize = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContract
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.BufferSize |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field QueryId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContract
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthContract
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthContract
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.QueryId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipContract(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthContract
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GetHistoryForKey) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowContract
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GetHistoryForKey: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GetHistoryForKey: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Key", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContract
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthContract
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthContract
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Key = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field BufferSize", wireType)
			}
			m.BufferSize = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContract
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.BufferSize |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field QueryId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContract
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthContract
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthContract
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.QueryId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipContract(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthContract
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *HistoryForKey) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowContract
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: HistoryForKey: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: HistoryForKey: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field HistoryArray", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContract
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthContract
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthContract
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.HistoryArray = append(m.HistoryArray, &common.KeyModification{})
			if err := m.HistoryArray[len(m.HistoryArray)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IsOver", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContract
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.IsOver = bool(v != 0)
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field QueryId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContract
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthContract
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthContract
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.QueryId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipContract(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthContract
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *QueryResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowContract
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: QueryResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: QueryResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field KvArray", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContract
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthContract
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthContract
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.KvArray = append(m.KvArray, &KVInfo{})
			if err := m.KvArray[len(m.KvArray)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IsOver", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContract
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.IsOver = bool(v != 0)
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field QueryId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContract
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthContract
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthContract
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.QueryId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipContract(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthContract
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *KVInfo) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowContract
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: KVInfo: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: KVInfo: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Key", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContract
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthContract
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthContract
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Key = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Value", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContract
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthContract
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthContract
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Value = append(m.Value[:0], dAtA[iNdEx:postIndex]...)
			if m.Value == nil {
				m.Value = []byte{}
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipContract(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthContract
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SqlQuery) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowContract
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SqlQuery: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SqlQuery: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Query", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContract
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthContract
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthContract
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Query = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Args", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContract
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthContract
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthContract
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Args == nil {
				m.Args = &common.PrimitiveValues{}
			}
			if err := m.Args.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field BufferSize", wireType)
			}
			m.BufferSize = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContract
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.BufferSize |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field QId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContract
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthContract
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthContract
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.QId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipContract(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthContract
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SqlExec) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowContract
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SqlExec: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SqlExec: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Query", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContract
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthContract
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthContract
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Query = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Args", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContract
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthContract
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthContract
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Args == nil {
				m.Args = &common.PrimitiveValues{}
			}
			if err := m.Args.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipContract(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthContract
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SqlQueryResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowContract
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SqlQueryResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SqlQueryResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SqlRows", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContract
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthContract
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthContract
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.SqlRows == nil {
				m.SqlRows = &SqlRows{}
			}
			if err := m.SqlRows.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IsOver", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContract
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.IsOver = bool(v != 0)
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field QueryId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContract
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthContract
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthContract
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.QueryId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipContract(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthContract
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SqlRows) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowContract
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SqlRows: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SqlRows: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Rows", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContract
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthContract
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthContract
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Rows = append(m.Rows, &SqlRow{})
			if err := m.Rows[len(m.Rows)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipContract(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthContract
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SqlRow) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowContract
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SqlRow: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SqlRow: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Columns", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContract
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthContract
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthContract
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Columns = append(m.Columns, &SqlColumn{})
			if err := m.Columns[len(m.Columns)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipContract(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthContract
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SqlColumn) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowContract
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SqlColumn: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SqlColumn: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContract
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthContract
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthContract
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Index", wireType)
			}
			m.Index = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContract
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Index |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Value", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContract
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthContract
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthContract
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Value = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipContract(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthContract
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Response) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowContract
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Response: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Response: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Status", wireType)
			}
			m.Status = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContract
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Status |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Message", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContract
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthContract
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthContract
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Message = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Payload", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContract
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthContract
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthContract
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Payload = append(m.Payload[:0], dAtA[iNdEx:postIndex]...)
			if m.Payload == nil {
				m.Payload = []byte{}
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipContract(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthContract
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipContract(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	depth := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowContract
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowContract
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
		case 1:
			iNdEx += 8
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowContract
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if length < 0 {
				return 0, ErrInvalidLengthContract
			}
			iNdEx += length
		case 3:
			depth++
		case 4:
			if depth == 0 {
				return 0, ErrUnexpectedEndOfGroupContract
			}
			depth--
		case 5:
			iNdEx += 4
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
		if iNdEx < 0 {
			return 0, ErrInvalidLengthContract
		}
		if depth == 0 {
			return iNdEx, nil
		}
	}
	return 0, io.ErrUnexpectedEOF
}

var (
	ErrInvalidLengthContract        = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowContract          = fmt.Errorf("proto: integer overflow")
	ErrUnexpectedEndOfGroupContract = fmt.Errorf("proto: unexpected end of group")
)
