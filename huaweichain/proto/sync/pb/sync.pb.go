// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: sync/sync.proto

package pb

import (
	context "context"
	fmt "fmt"
	common "git.huawei.com/huaweichain/proto/common"
	pb "git.huawei.com/huaweichain/proto/consensus/raft/pb"
	_ "github.com/gogo/protobuf/gogoproto"
	proto "github.com/gogo/protobuf/proto"
	grpc "google.golang.org/grpc"
	codes "google.golang.org/grpc/codes"
	status "google.golang.org/grpc/status"
	io "io"
	math "math"
	math_bits "math/bits"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.GoGoProtoPackageIsVersion3 // please upgrade the proto package

type ConnectionState int32

const (
	PeerInit         ConnectionState = 0
	PeerActive       ConnectionState = 1
	PeerConnecting   ConnectionState = 2
	PeerReady        ConnectionState = 3
	PeerIdle         ConnectionState = 4
	PeerFaulty       ConnectionState = 5
	PeerDisconnected ConnectionState = 6
	PeerRemoving     ConnectionState = 7
	PeerRemoved      ConnectionState = 8
)

var ConnectionState_name = map[int32]string{
	0: "PeerInit",
	1: "PeerActive",
	2: "PeerConnecting",
	3: "PeerReady",
	4: "PeerIdle",
	5: "PeerFaulty",
	6: "PeerDisconnected",
	7: "PeerRemoving",
	8: "PeerRemoved",
}

var ConnectionState_value = map[string]int32{
	"PeerInit":         0,
	"PeerActive":       1,
	"PeerConnecting":   2,
	"PeerReady":        3,
	"PeerIdle":         4,
	"PeerFaulty":       5,
	"PeerDisconnected": 6,
	"PeerRemoving":     7,
	"PeerRemoved":      8,
}

func (x ConnectionState) String() string {
	return proto.EnumName(ConnectionState_name, int32(x))
}

func (ConnectionState) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_221a5c59bc60326f, []int{0}
}

type Connection int32

const (
	Establish Connection = 0
	Process   Connection = 1
	Terminate Connection = 2
)

var Connection_name = map[int32]string{
	0: "Establish",
	1: "Process",
	2: "Terminate",
}

var Connection_value = map[string]int32{
	"Establish": 0,
	"Process":   1,
	"Terminate": 2,
}

func (x Connection) String() string {
	return proto.EnumName(Connection_name, int32(x))
}

func (Connection) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_221a5c59bc60326f, []int{1}
}

type Op int32

const (
	Join  Op = 0
	Leave Op = 1
	Fail  Op = 2
)

var Op_name = map[int32]string{
	0: "Join",
	1: "Leave",
	2: "Fail",
}

var Op_value = map[string]int32{
	"Join":  0,
	"Leave": 1,
	"Fail":  2,
}

func (x Op) String() string {
	return proto.EnumName(Op_name, int32(x))
}

func (Op) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_221a5c59bc60326f, []int{2}
}

type Metadata_Service int32

const (
	Consensus    Metadata_Service = 0
	Synchronizer Metadata_Service = 1
	Sharding     Metadata_Service = 2
)

var Metadata_Service_name = map[int32]string{
	0: "Consensus",
	1: "Synchronizer",
	2: "Sharding",
}

var Metadata_Service_value = map[string]int32{
	"Consensus":    0,
	"Synchronizer": 1,
	"Sharding":     2,
}

func (x Metadata_Service) String() string {
	return proto.EnumName(Metadata_Service_name, int32(x))
}

func (Metadata_Service) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_221a5c59bc60326f, []int{1, 0}
}

type Node_State int32

const (
	Alive     Node_State = 0
	Suspected Node_State = 1
	Faulty    Node_State = 2
)

var Node_State_name = map[int32]string{
	0: "Alive",
	1: "Suspected",
	2: "Faulty",
}

var Node_State_value = map[string]int32{
	"Alive":     0,
	"Suspected": 1,
	"Faulty":    2,
}

func (x Node_State) String() string {
	return proto.EnumName(Node_State_name, int32(x))
}

func (Node_State) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_221a5c59bc60326f, []int{12, 0}
}

type Envelope struct {
	Terminate bool `protobuf:"varint,1,opt,name=terminate,proto3" json:"terminate,omitempty"`
	// Types that are valid to be assigned to M:
	//	*Envelope_Meta
	//	*Envelope_Msg
	//	*Envelope_Cons
	M isEnvelope_M `protobuf_oneof:"m"`
}

func (m *Envelope) Reset()         { *m = Envelope{} }
func (m *Envelope) String() string { return proto.CompactTextString(m) }
func (*Envelope) ProtoMessage()    {}
func (*Envelope) Descriptor() ([]byte, []int) {
	return fileDescriptor_221a5c59bc60326f, []int{0}
}
func (m *Envelope) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Envelope) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Envelope.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Envelope) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Envelope.Merge(m, src)
}
func (m *Envelope) XXX_Size() int {
	return m.Size()
}
func (m *Envelope) XXX_DiscardUnknown() {
	xxx_messageInfo_Envelope.DiscardUnknown(m)
}

var xxx_messageInfo_Envelope proto.InternalMessageInfo

type isEnvelope_M interface {
	isEnvelope_M()
	MarshalTo([]byte) (int, error)
	Size() int
}

type Envelope_Meta struct {
	Meta *Metadata `protobuf:"bytes,2,opt,name=meta,proto3,oneof" json:"meta,omitempty"`
}
type Envelope_Msg struct {
	Msg *Msg `protobuf:"bytes,3,opt,name=msg,proto3,oneof" json:"msg,omitempty"`
}
type Envelope_Cons struct {
	Cons *pb.Cons `protobuf:"bytes,4,opt,name=cons,proto3,oneof" json:"cons,omitempty"`
}

func (*Envelope_Meta) isEnvelope_M() {}
func (*Envelope_Msg) isEnvelope_M()  {}
func (*Envelope_Cons) isEnvelope_M() {}

func (m *Envelope) GetM() isEnvelope_M {
	if m != nil {
		return m.M
	}
	return nil
}

func (m *Envelope) GetMeta() *Metadata {
	if x, ok := m.GetM().(*Envelope_Meta); ok {
		return x.Meta
	}
	return nil
}

func (m *Envelope) GetMsg() *Msg {
	if x, ok := m.GetM().(*Envelope_Msg); ok {
		return x.Msg
	}
	return nil
}

func (m *Envelope) GetCons() *pb.Cons {
	if x, ok := m.GetM().(*Envelope_Cons); ok {
		return x.Cons
	}
	return nil
}

// XXX_OneofWrappers is for the internal use of the proto package.
func (*Envelope) XXX_OneofWrappers() []interface{} {
	return []interface{}{
		(*Envelope_Meta)(nil),
		(*Envelope_Msg)(nil),
		(*Envelope_Cons)(nil),
	}
}

type Metadata struct {
	ChainId  string           `protobuf:"bytes,1,opt,name=chain_id,json=chainId,proto3" json:"chain_id,omitempty"`
	FromId   int32            `protobuf:"varint,2,opt,name=from_id,json=fromId,proto3" json:"from_id,omitempty"`
	FromNode string           `protobuf:"bytes,3,opt,name=from_node,json=fromNode,proto3" json:"from_node,omitempty"`
	Service  Metadata_Service `protobuf:"varint,4,opt,name=service,proto3,enum=sync.Metadata_Service" json:"service,omitempty"`
}

func (m *Metadata) Reset()         { *m = Metadata{} }
func (m *Metadata) String() string { return proto.CompactTextString(m) }
func (*Metadata) ProtoMessage()    {}
func (*Metadata) Descriptor() ([]byte, []int) {
	return fileDescriptor_221a5c59bc60326f, []int{1}
}
func (m *Metadata) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Metadata) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Metadata.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Metadata) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Metadata.Merge(m, src)
}
func (m *Metadata) XXX_Size() int {
	return m.Size()
}
func (m *Metadata) XXX_DiscardUnknown() {
	xxx_messageInfo_Metadata.DiscardUnknown(m)
}

var xxx_messageInfo_Metadata proto.InternalMessageInfo

type Msg struct {
	ZoneId string     `protobuf:"bytes,1,opt,name=zone_id,json=zoneId,proto3" json:"zone_id,omitempty"`
	Conn   Connection `protobuf:"varint,2,opt,name=conn,proto3,enum=sync.Connection" json:"conn,omitempty"`
	Reason string     `protobuf:"bytes,3,opt,name=reason,proto3" json:"reason,omitempty"`
	// Types that are valid to be assigned to Payload:
	//	*Msg_SourceInfo
	//	*Msg_Membership
	//	*Msg_MembershipDiff
	//	*Msg_Blocks
	//	*Msg_Response
	//	*Msg_Heartbeat
	//	*Msg_BlockReq
	Payload isMsg_Payload `protobuf_oneof:"payload"`
}

func (m *Msg) Reset()         { *m = Msg{} }
func (m *Msg) String() string { return proto.CompactTextString(m) }
func (*Msg) ProtoMessage()    {}
func (*Msg) Descriptor() ([]byte, []int) {
	return fileDescriptor_221a5c59bc60326f, []int{2}
}
func (m *Msg) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Msg) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Msg.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Msg) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Msg.Merge(m, src)
}
func (m *Msg) XXX_Size() int {
	return m.Size()
}
func (m *Msg) XXX_DiscardUnknown() {
	xxx_messageInfo_Msg.DiscardUnknown(m)
}

var xxx_messageInfo_Msg proto.InternalMessageInfo

type isMsg_Payload interface {
	isMsg_Payload()
	MarshalTo([]byte) (int, error)
	Size() int
}

type Msg_SourceInfo struct {
	SourceInfo *SourceInfo `protobuf:"bytes,4,opt,name=source_info,json=sourceInfo,proto3,oneof" json:"source_info,omitempty"`
}
type Msg_Membership struct {
	Membership *Membership `protobuf:"bytes,5,opt,name=membership,proto3,oneof" json:"membership,omitempty"`
}
type Msg_MembershipDiff struct {
	MembershipDiff *MemberDiff `protobuf:"bytes,6,opt,name=membership_diff,json=membershipDiff,proto3,oneof" json:"membership_diff,omitempty"`
}
type Msg_Blocks struct {
	Blocks *BlockSeq `protobuf:"bytes,7,opt,name=blocks,proto3,oneof" json:"blocks,omitempty"`
}
type Msg_Response struct {
	Response *ProgressResponse `protobuf:"bytes,8,opt,name=response,proto3,oneof" json:"response,omitempty"`
}
type Msg_Heartbeat struct {
	Heartbeat *Heartbeat `protobuf:"bytes,9,opt,name=heartbeat,proto3,oneof" json:"heartbeat,omitempty"`
}
type Msg_BlockReq struct {
	BlockReq *BlockRequest `protobuf:"bytes,10,opt,name=block_req,json=blockReq,proto3,oneof" json:"block_req,omitempty"`
}

func (*Msg_SourceInfo) isMsg_Payload()     {}
func (*Msg_Membership) isMsg_Payload()     {}
func (*Msg_MembershipDiff) isMsg_Payload() {}
func (*Msg_Blocks) isMsg_Payload()         {}
func (*Msg_Response) isMsg_Payload()       {}
func (*Msg_Heartbeat) isMsg_Payload()      {}
func (*Msg_BlockReq) isMsg_Payload()       {}

func (m *Msg) GetPayload() isMsg_Payload {
	if m != nil {
		return m.Payload
	}
	return nil
}

func (m *Msg) GetSourceInfo() *SourceInfo {
	if x, ok := m.GetPayload().(*Msg_SourceInfo); ok {
		return x.SourceInfo
	}
	return nil
}

func (m *Msg) GetMembership() *Membership {
	if x, ok := m.GetPayload().(*Msg_Membership); ok {
		return x.Membership
	}
	return nil
}

func (m *Msg) GetMembershipDiff() *MemberDiff {
	if x, ok := m.GetPayload().(*Msg_MembershipDiff); ok {
		return x.MembershipDiff
	}
	return nil
}

func (m *Msg) GetBlocks() *BlockSeq {
	if x, ok := m.GetPayload().(*Msg_Blocks); ok {
		return x.Blocks
	}
	return nil
}

func (m *Msg) GetResponse() *ProgressResponse {
	if x, ok := m.GetPayload().(*Msg_Response); ok {
		return x.Response
	}
	return nil
}

func (m *Msg) GetHeartbeat() *Heartbeat {
	if x, ok := m.GetPayload().(*Msg_Heartbeat); ok {
		return x.Heartbeat
	}
	return nil
}

func (m *Msg) GetBlockReq() *BlockRequest {
	if x, ok := m.GetPayload().(*Msg_BlockReq); ok {
		return x.BlockReq
	}
	return nil
}

// XXX_OneofWrappers is for the internal use of the proto package.
func (*Msg) XXX_OneofWrappers() []interface{} {
	return []interface{}{
		(*Msg_SourceInfo)(nil),
		(*Msg_Membership)(nil),
		(*Msg_MembershipDiff)(nil),
		(*Msg_Blocks)(nil),
		(*Msg_Response)(nil),
		(*Msg_Heartbeat)(nil),
		(*Msg_BlockReq)(nil),
	}
}

type Location struct {
	Id         int32   `protobuf:"varint,1,opt,name=id,proto3" json:"id,omitempty"`
	Upstream   []int32 `protobuf:"varint,2,rep,packed,name=upstream,proto3" json:"upstream,omitempty"`
	Downstream []int32 `protobuf:"varint,3,rep,packed,name=downstream,proto3" json:"downstream,omitempty"`
}

func (m *Location) Reset()         { *m = Location{} }
func (m *Location) String() string { return proto.CompactTextString(m) }
func (*Location) ProtoMessage()    {}
func (*Location) Descriptor() ([]byte, []int) {
	return fileDescriptor_221a5c59bc60326f, []int{3}
}
func (m *Location) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Location) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Location.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Location) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Location.Merge(m, src)
}
func (m *Location) XXX_Size() int {
	return m.Size()
}
func (m *Location) XXX_DiscardUnknown() {
	xxx_messageInfo_Location.DiscardUnknown(m)
}

var xxx_messageInfo_Location proto.InternalMessageInfo

type CoordinatorList struct {
	Coordinators []*CoordinatorList_Coordinator `protobuf:"bytes,1,rep,name=coordinators,proto3" json:"coordinators,omitempty"`
}

func (m *CoordinatorList) Reset()         { *m = CoordinatorList{} }
func (m *CoordinatorList) String() string { return proto.CompactTextString(m) }
func (*CoordinatorList) ProtoMessage()    {}
func (*CoordinatorList) Descriptor() ([]byte, []int) {
	return fileDescriptor_221a5c59bc60326f, []int{4}
}
func (m *CoordinatorList) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *CoordinatorList) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_CoordinatorList.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *CoordinatorList) XXX_Merge(src proto.Message) {
	xxx_messageInfo_CoordinatorList.Merge(m, src)
}
func (m *CoordinatorList) XXX_Size() int {
	return m.Size()
}
func (m *CoordinatorList) XXX_DiscardUnknown() {
	xxx_messageInfo_CoordinatorList.DiscardUnknown(m)
}

var xxx_messageInfo_CoordinatorList proto.InternalMessageInfo

type CoordinatorList_Coordinator struct {
	Endpoint *Endpoint `protobuf:"bytes,1,opt,name=endpoint,proto3" json:"endpoint,omitempty"`
	IsMaster bool      `protobuf:"varint,2,opt,name=is_master,json=isMaster,proto3" json:"is_master,omitempty"`
}

func (m *CoordinatorList_Coordinator) Reset()         { *m = CoordinatorList_Coordinator{} }
func (m *CoordinatorList_Coordinator) String() string { return proto.CompactTextString(m) }
func (*CoordinatorList_Coordinator) ProtoMessage()    {}
func (*CoordinatorList_Coordinator) Descriptor() ([]byte, []int) {
	return fileDescriptor_221a5c59bc60326f, []int{4, 0}
}
func (m *CoordinatorList_Coordinator) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *CoordinatorList_Coordinator) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_CoordinatorList_Coordinator.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *CoordinatorList_Coordinator) XXX_Merge(src proto.Message) {
	xxx_messageInfo_CoordinatorList_Coordinator.Merge(m, src)
}
func (m *CoordinatorList_Coordinator) XXX_Size() int {
	return m.Size()
}
func (m *CoordinatorList_Coordinator) XXX_DiscardUnknown() {
	xxx_messageInfo_CoordinatorList_Coordinator.DiscardUnknown(m)
}

var xxx_messageInfo_CoordinatorList_Coordinator proto.InternalMessageInfo

type SourceInfo struct {
	IsCoordinator     bool   `protobuf:"varint,1,opt,name=is_coordinator,json=isCoordinator,proto3" json:"is_coordinator,omitempty"`
	IsConsenter       bool   `protobuf:"varint,2,opt,name=is_consenter,json=isConsenter,proto3" json:"is_consenter,omitempty"`
	MembershipVersion uint64 `protobuf:"varint,3,opt,name=membership_version,json=membershipVersion,proto3" json:"membership_version,omitempty"`
	BlockHeight       uint64 `protobuf:"varint,4,opt,name=block_height,json=blockHeight,proto3" json:"block_height,omitempty"`
}

func (m *SourceInfo) Reset()         { *m = SourceInfo{} }
func (m *SourceInfo) String() string { return proto.CompactTextString(m) }
func (*SourceInfo) ProtoMessage()    {}
func (*SourceInfo) Descriptor() ([]byte, []int) {
	return fileDescriptor_221a5c59bc60326f, []int{5}
}
func (m *SourceInfo) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *SourceInfo) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_SourceInfo.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *SourceInfo) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SourceInfo.Merge(m, src)
}
func (m *SourceInfo) XXX_Size() int {
	return m.Size()
}
func (m *SourceInfo) XXX_DiscardUnknown() {
	xxx_messageInfo_SourceInfo.DiscardUnknown(m)
}

var xxx_messageInfo_SourceInfo proto.InternalMessageInfo

type Heartbeat struct {
	MembershipVersion uint64 `protobuf:"varint,1,opt,name=membership_version,json=membershipVersion,proto3" json:"membership_version,omitempty"`
	BlockHeight       uint64 `protobuf:"varint,2,opt,name=block_height,json=blockHeight,proto3" json:"block_height,omitempty"`
}

func (m *Heartbeat) Reset()         { *m = Heartbeat{} }
func (m *Heartbeat) String() string { return proto.CompactTextString(m) }
func (*Heartbeat) ProtoMessage()    {}
func (*Heartbeat) Descriptor() ([]byte, []int) {
	return fileDescriptor_221a5c59bc60326f, []int{6}
}
func (m *Heartbeat) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Heartbeat) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Heartbeat.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Heartbeat) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Heartbeat.Merge(m, src)
}
func (m *Heartbeat) XXX_Size() int {
	return m.Size()
}
func (m *Heartbeat) XXX_DiscardUnknown() {
	xxx_messageInfo_Heartbeat.DiscardUnknown(m)
}

var xxx_messageInfo_Heartbeat proto.InternalMessageInfo

type Handshake struct {
	TargetId   int32       `protobuf:"varint,1,opt,name=target_id,json=targetId,proto3" json:"target_id,omitempty"`
	Membership *Membership `protobuf:"bytes,2,opt,name=membership,proto3" json:"membership,omitempty"`
}

func (m *Handshake) Reset()         { *m = Handshake{} }
func (m *Handshake) String() string { return proto.CompactTextString(m) }
func (*Handshake) ProtoMessage()    {}
func (*Handshake) Descriptor() ([]byte, []int) {
	return fileDescriptor_221a5c59bc60326f, []int{7}
}
func (m *Handshake) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Handshake) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Handshake.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Handshake) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Handshake.Merge(m, src)
}
func (m *Handshake) XXX_Size() int {
	return m.Size()
}
func (m *Handshake) XXX_DiscardUnknown() {
	xxx_messageInfo_Handshake.DiscardUnknown(m)
}

var xxx_messageInfo_Handshake proto.InternalMessageInfo

type BlockSeq struct {
	Height uint64          `protobuf:"varint,1,opt,name=height,proto3" json:"height,omitempty"`
	Blocks []*common.Block `protobuf:"bytes,2,rep,name=blocks,proto3" json:"blocks,omitempty"`
}

func (m *BlockSeq) Reset()         { *m = BlockSeq{} }
func (m *BlockSeq) String() string { return proto.CompactTextString(m) }
func (*BlockSeq) ProtoMessage()    {}
func (*BlockSeq) Descriptor() ([]byte, []int) {
	return fileDescriptor_221a5c59bc60326f, []int{8}
}
func (m *BlockSeq) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *BlockSeq) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_BlockSeq.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *BlockSeq) XXX_Merge(src proto.Message) {
	xxx_messageInfo_BlockSeq.Merge(m, src)
}
func (m *BlockSeq) XXX_Size() int {
	return m.Size()
}
func (m *BlockSeq) XXX_DiscardUnknown() {
	xxx_messageInfo_BlockSeq.DiscardUnknown(m)
}

var xxx_messageInfo_BlockSeq proto.InternalMessageInfo

type BlockRequest struct {
	Begin uint64 `protobuf:"varint,1,opt,name=begin,proto3" json:"begin,omitempty"`
}

func (m *BlockRequest) Reset()         { *m = BlockRequest{} }
func (m *BlockRequest) String() string { return proto.CompactTextString(m) }
func (*BlockRequest) ProtoMessage()    {}
func (*BlockRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_221a5c59bc60326f, []int{9}
}
func (m *BlockRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *BlockRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_BlockRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *BlockRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_BlockRequest.Merge(m, src)
}
func (m *BlockRequest) XXX_Size() int {
	return m.Size()
}
func (m *BlockRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_BlockRequest.DiscardUnknown(m)
}

var xxx_messageInfo_BlockRequest proto.InternalMessageInfo

type ProgressResponse struct {
	Reject      bool   `protobuf:"varint,1,opt,name=reject,proto3" json:"reject,omitempty"`
	MatchHeight uint64 `protobuf:"varint,2,opt,name=match_height,json=matchHeight,proto3" json:"match_height,omitempty"`
	LastHeight  uint64 `protobuf:"varint,3,opt,name=last_height,json=lastHeight,proto3" json:"last_height,omitempty"`
}

func (m *ProgressResponse) Reset()         { *m = ProgressResponse{} }
func (m *ProgressResponse) String() string { return proto.CompactTextString(m) }
func (*ProgressResponse) ProtoMessage()    {}
func (*ProgressResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_221a5c59bc60326f, []int{10}
}
func (m *ProgressResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ProgressResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ProgressResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ProgressResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ProgressResponse.Merge(m, src)
}
func (m *ProgressResponse) XXX_Size() int {
	return m.Size()
}
func (m *ProgressResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_ProgressResponse.DiscardUnknown(m)
}

var xxx_messageInfo_ProgressResponse proto.InternalMessageInfo

type Membership struct {
	Nodes   []*Node     `protobuf:"bytes,1,rep,name=nodes,proto3" json:"nodes,omitempty"`
	Master  int32       `protobuf:"varint,3,opt,name=master,proto3" json:"master,omitempty"`
	Version uint64      `protobuf:"varint,2,opt,name=version,proto3" json:"version,omitempty"`
	Self    int32       `protobuf:"varint,4,opt,name=self,proto3" json:"self,omitempty"`
	Linkers []*Endpoint `protobuf:"bytes,5,rep,name=linkers,proto3" json:"linkers,omitempty"`
}

func (m *Membership) Reset()         { *m = Membership{} }
func (m *Membership) String() string { return proto.CompactTextString(m) }
func (*Membership) ProtoMessage()    {}
func (*Membership) Descriptor() ([]byte, []int) {
	return fileDescriptor_221a5c59bc60326f, []int{11}
}
func (m *Membership) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Membership) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Membership.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Membership) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Membership.Merge(m, src)
}
func (m *Membership) XXX_Size() int {
	return m.Size()
}
func (m *Membership) XXX_DiscardUnknown() {
	xxx_messageInfo_Membership.DiscardUnknown(m)
}

var xxx_messageInfo_Membership proto.InternalMessageInfo

type Node struct {
	Id            int32      `protobuf:"varint,1,opt,name=id,proto3" json:"id,omitempty"`
	Endpoint      *Endpoint  `protobuf:"bytes,2,opt,name=endpoint,proto3" json:"endpoint,omitempty"`
	Upstream      []int32    `protobuf:"varint,3,rep,packed,name=upstream,proto3" json:"upstream,omitempty"`
	Downstream    []int32    `protobuf:"varint,4,rep,packed,name=downstream,proto3" json:"downstream,omitempty"`
	State         Node_State `protobuf:"varint,5,opt,name=state,proto3,enum=sync.Node_State" json:"state,omitempty"`
	IsCoordinator bool       `protobuf:"varint,6,opt,name=is_coordinator,json=isCoordinator,proto3" json:"is_coordinator,omitempty"`
	IsConsenter   bool       `protobuf:"varint,7,opt,name=is_consenter,json=isConsenter,proto3" json:"is_consenter,omitempty"`
}

func (m *Node) Reset()         { *m = Node{} }
func (m *Node) String() string { return proto.CompactTextString(m) }
func (*Node) ProtoMessage()    {}
func (*Node) Descriptor() ([]byte, []int) {
	return fileDescriptor_221a5c59bc60326f, []int{12}
}
func (m *Node) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Node) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Node.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Node) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Node.Merge(m, src)
}
func (m *Node) XXX_Size() int {
	return m.Size()
}
func (m *Node) XXX_DiscardUnknown() {
	xxx_messageInfo_Node.DiscardUnknown(m)
}

var xxx_messageInfo_Node proto.InternalMessageInfo

type OpResult struct {
	// Types that are valid to be assigned to Res:
	//	*OpResult_Node
	//	*OpResult_Error
	Res isOpResult_Res `protobuf_oneof:"res"`
}

func (m *OpResult) Reset()         { *m = OpResult{} }
func (m *OpResult) String() string { return proto.CompactTextString(m) }
func (*OpResult) ProtoMessage()    {}
func (*OpResult) Descriptor() ([]byte, []int) {
	return fileDescriptor_221a5c59bc60326f, []int{13}
}
func (m *OpResult) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *OpResult) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_OpResult.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *OpResult) XXX_Merge(src proto.Message) {
	xxx_messageInfo_OpResult.Merge(m, src)
}
func (m *OpResult) XXX_Size() int {
	return m.Size()
}
func (m *OpResult) XXX_DiscardUnknown() {
	xxx_messageInfo_OpResult.DiscardUnknown(m)
}

var xxx_messageInfo_OpResult proto.InternalMessageInfo

type isOpResult_Res interface {
	isOpResult_Res()
	MarshalTo([]byte) (int, error)
	Size() int
}

type OpResult_Node struct {
	Node *Node `protobuf:"bytes,1,opt,name=node,proto3,oneof" json:"node,omitempty"`
}
type OpResult_Error struct {
	Error string `protobuf:"bytes,2,opt,name=error,proto3,oneof" json:"error,omitempty"`
}

func (*OpResult_Node) isOpResult_Res()  {}
func (*OpResult_Error) isOpResult_Res() {}

func (m *OpResult) GetRes() isOpResult_Res {
	if m != nil {
		return m.Res
	}
	return nil
}

func (m *OpResult) GetNode() *Node {
	if x, ok := m.GetRes().(*OpResult_Node); ok {
		return x.Node
	}
	return nil
}

func (m *OpResult) GetError() string {
	if x, ok := m.GetRes().(*OpResult_Error); ok {
		return x.Error
	}
	return ""
}

// XXX_OneofWrappers is for the internal use of the proto package.
func (*OpResult) XXX_OneofWrappers() []interface{} {
	return []interface{}{
		(*OpResult_Node)(nil),
		(*OpResult_Error)(nil),
	}
}

type StreamNode struct {
	Id            int32     `protobuf:"varint,1,opt,name=id,proto3" json:"id,omitempty"`
	Endpoint      *Endpoint `protobuf:"bytes,2,opt,name=endpoint,proto3" json:"endpoint,omitempty"`
	IsCoordinator bool      `protobuf:"varint,3,opt,name=is_coordinator,json=isCoordinator,proto3" json:"is_coordinator,omitempty"`
	IsConsenter   bool      `protobuf:"varint,4,opt,name=is_consenter,json=isConsenter,proto3" json:"is_consenter,omitempty"`
}

func (m *StreamNode) Reset()         { *m = StreamNode{} }
func (m *StreamNode) String() string { return proto.CompactTextString(m) }
func (*StreamNode) ProtoMessage()    {}
func (*StreamNode) Descriptor() ([]byte, []int) {
	return fileDescriptor_221a5c59bc60326f, []int{14}
}
func (m *StreamNode) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *StreamNode) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_StreamNode.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *StreamNode) XXX_Merge(src proto.Message) {
	xxx_messageInfo_StreamNode.Merge(m, src)
}
func (m *StreamNode) XXX_Size() int {
	return m.Size()
}
func (m *StreamNode) XXX_DiscardUnknown() {
	xxx_messageInfo_StreamNode.DiscardUnknown(m)
}

var xxx_messageInfo_StreamNode proto.InternalMessageInfo

type MemberMap struct {
	IdToNode   map[int32]*Node  `protobuf:"bytes,1,rep,name=id_to_node,json=idToNode,proto3" json:"id_to_node,omitempty" protobuf_key:"varint,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value,proto3"`
	NameToNode map[string]*Node `protobuf:"bytes,2,rep,name=name_to_node,json=nameToNode,proto3" json:"name_to_node,omitempty" protobuf_key:"bytes,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value,proto3"`
}

func (m *MemberMap) Reset()         { *m = MemberMap{} }
func (m *MemberMap) String() string { return proto.CompactTextString(m) }
func (*MemberMap) ProtoMessage()    {}
func (*MemberMap) Descriptor() ([]byte, []int) {
	return fileDescriptor_221a5c59bc60326f, []int{15}
}
func (m *MemberMap) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MemberMap) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MemberMap.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MemberMap) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MemberMap.Merge(m, src)
}
func (m *MemberMap) XXX_Size() int {
	return m.Size()
}
func (m *MemberMap) XXX_DiscardUnknown() {
	xxx_messageInfo_MemberMap.DiscardUnknown(m)
}

var xxx_messageInfo_MemberMap proto.InternalMessageInfo

type MemberDiff struct {
	AddNodes    []*Node     `protobuf:"bytes,1,rep,name=add_nodes,json=addNodes,proto3" json:"add_nodes,omitempty"`
	RemoveNodes []*Node     `protobuf:"bytes,2,rep,name=remove_nodes,json=removeNodes,proto3" json:"remove_nodes,omitempty"`
	UpdateNodes []*Node     `protobuf:"bytes,3,rep,name=update_nodes,json=updateNodes,proto3" json:"update_nodes,omitempty"`
	FromVersion uint64      `protobuf:"varint,4,opt,name=from_version,json=fromVersion,proto3" json:"from_version,omitempty"`
	ToVersion   uint64      `protobuf:"varint,5,opt,name=to_version,json=toVersion,proto3" json:"to_version,omitempty"`
	Master      int32       `protobuf:"varint,6,opt,name=master,proto3" json:"master,omitempty"`
	Linkers     []*Endpoint `protobuf:"bytes,7,rep,name=linkers,proto3" json:"linkers,omitempty"`
}

func (m *MemberDiff) Reset()         { *m = MemberDiff{} }
func (m *MemberDiff) String() string { return proto.CompactTextString(m) }
func (*MemberDiff) ProtoMessage()    {}
func (*MemberDiff) Descriptor() ([]byte, []int) {
	return fileDescriptor_221a5c59bc60326f, []int{16}
}
func (m *MemberDiff) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MemberDiff) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MemberDiff.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MemberDiff) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MemberDiff.Merge(m, src)
}
func (m *MemberDiff) XXX_Size() int {
	return m.Size()
}
func (m *MemberDiff) XXX_DiscardUnknown() {
	xxx_messageInfo_MemberDiff.DiscardUnknown(m)
}

var xxx_messageInfo_MemberDiff proto.InternalMessageInfo

type Ack struct {
	BlockHeight uint64 `protobuf:"varint,1,opt,name=block_height,json=blockHeight,proto3" json:"block_height,omitempty"`
}

func (m *Ack) Reset()         { *m = Ack{} }
func (m *Ack) String() string { return proto.CompactTextString(m) }
func (*Ack) ProtoMessage()    {}
func (*Ack) Descriptor() ([]byte, []int) {
	return fileDescriptor_221a5c59bc60326f, []int{17}
}
func (m *Ack) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Ack) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Ack.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Ack) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Ack.Merge(m, src)
}
func (m *Ack) XXX_Size() int {
	return m.Size()
}
func (m *Ack) XXX_DiscardUnknown() {
	xxx_messageInfo_Ack.DiscardUnknown(m)
}

var xxx_messageInfo_Ack proto.InternalMessageInfo

type Endpoint struct {
	Addr     string `protobuf:"bytes,5,opt,name=addr,proto3" json:"addr,omitempty"`
	Host     string `protobuf:"bytes,1,opt,name=host,proto3" json:"host,omitempty"`
	RestPort uint32 `protobuf:"varint,2,opt,name=rest_port,json=restPort,proto3" json:"rest_port,omitempty"`
	RpcPort  uint32 `protobuf:"varint,3,opt,name=rpc_port,json=rpcPort,proto3" json:"rpc_port,omitempty"`
	ReqPort  uint32 `protobuf:"varint,7,opt,name=req_port,json=reqPort,proto3" json:"req_port,omitempty"`
	Version  string `protobuf:"bytes,4,opt,name=version,proto3" json:"version,omitempty"`
}

func (m *Endpoint) Reset()         { *m = Endpoint{} }
func (m *Endpoint) String() string { return proto.CompactTextString(m) }
func (*Endpoint) ProtoMessage()    {}
func (*Endpoint) Descriptor() ([]byte, []int) {
	return fileDescriptor_221a5c59bc60326f, []int{18}
}
func (m *Endpoint) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Endpoint) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Endpoint.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Endpoint) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Endpoint.Merge(m, src)
}
func (m *Endpoint) XXX_Size() int {
	return m.Size()
}
func (m *Endpoint) XXX_DiscardUnknown() {
	xxx_messageInfo_Endpoint.DiscardUnknown(m)
}

var xxx_messageInfo_Endpoint proto.InternalMessageInfo

type Config struct {
	ChainId       string       `protobuf:"bytes,1,opt,name=chain_id,json=chainId,proto3" json:"chain_id,omitempty"`
	NodeId        string       `protobuf:"bytes,2,opt,name=node_id,json=nodeId,proto3" json:"node_id,omitempty"`
	Endpoint      *Endpoint    `protobuf:"bytes,3,opt,name=endpoint,proto3" json:"endpoint,omitempty"`
	Self          *Endpoint    `protobuf:"bytes,4,opt,name=self,proto3" json:"self,omitempty"`
	IsCoordinator bool         `protobuf:"varint,5,opt,name=is_coordinator,json=isCoordinator,proto3" json:"is_coordinator,omitempty"`
	IsConsenter   bool         `protobuf:"varint,6,opt,name=is_consenter,json=isConsenter,proto3" json:"is_consenter,omitempty"`
	SeedNodes     []*Endpoint  `protobuf:"bytes,7,rep,name=seed_nodes,json=seedNodes,proto3" json:"seed_nodes,omitempty"`
	LinkerNodes   []*Endpoint  `protobuf:"bytes,8,rep,name=linker_nodes,json=linkerNodes,proto3" json:"linker_nodes,omitempty"`
	Zone          *common.Zone `protobuf:"bytes,9,opt,name=zone,proto3" json:"zone,omitempty"`
	Org           *Org         `protobuf:"bytes,10,opt,name=org,proto3" json:"org,omitempty"`
	RestTls       bool         `protobuf:"varint,11,opt,name=rest_tls,json=restTls,proto3" json:"rest_tls,omitempty"`
}

func (m *Config) Reset()         { *m = Config{} }
func (m *Config) String() string { return proto.CompactTextString(m) }
func (*Config) ProtoMessage()    {}
func (*Config) Descriptor() ([]byte, []int) {
	return fileDescriptor_221a5c59bc60326f, []int{19}
}
func (m *Config) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Config) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Config.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Config) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Config.Merge(m, src)
}
func (m *Config) XXX_Size() int {
	return m.Size()
}
func (m *Config) XXX_DiscardUnknown() {
	xxx_messageInfo_Config.DiscardUnknown(m)
}

var xxx_messageInfo_Config proto.InternalMessageInfo

type Org struct {
	Name       string `protobuf:"bytes,1,opt,name=name,proto3" json:"name,omitempty"`
	Permission []byte `protobuf:"bytes,2,opt,name=permission,proto3" json:"permission,omitempty"`
}

func (m *Org) Reset()         { *m = Org{} }
func (m *Org) String() string { return proto.CompactTextString(m) }
func (*Org) ProtoMessage()    {}
func (*Org) Descriptor() ([]byte, []int) {
	return fileDescriptor_221a5c59bc60326f, []int{20}
}
func (m *Org) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Org) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Org.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Org) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Org.Merge(m, src)
}
func (m *Org) XXX_Size() int {
	return m.Size()
}
func (m *Org) XXX_DiscardUnknown() {
	xxx_messageInfo_Org.DiscardUnknown(m)
}

var xxx_messageInfo_Org proto.InternalMessageInfo

type MemberChange struct {
	// Types that are valid to be assigned to Op:
	//	*MemberChange_Add
	//	*MemberChange_RemoveCoordinator
	//	*MemberChange_RemovePeer
	//	*MemberChange_ChangeMaster
	//	*MemberChange_AddLinker
	Op isMemberChange_Op `protobuf_oneof:"op"`
}

func (m *MemberChange) Reset()         { *m = MemberChange{} }
func (m *MemberChange) String() string { return proto.CompactTextString(m) }
func (*MemberChange) ProtoMessage()    {}
func (*MemberChange) Descriptor() ([]byte, []int) {
	return fileDescriptor_221a5c59bc60326f, []int{21}
}
func (m *MemberChange) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MemberChange) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MemberChange.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MemberChange) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MemberChange.Merge(m, src)
}
func (m *MemberChange) XXX_Size() int {
	return m.Size()
}
func (m *MemberChange) XXX_DiscardUnknown() {
	xxx_messageInfo_MemberChange.DiscardUnknown(m)
}

var xxx_messageInfo_MemberChange proto.InternalMessageInfo

type isMemberChange_Op interface {
	isMemberChange_Op()
	MarshalTo([]byte) (int, error)
	Size() int
}

type MemberChange_Add struct {
	Add *StreamNode `protobuf:"bytes,1,opt,name=add,proto3,oneof" json:"add,omitempty"`
}
type MemberChange_RemoveCoordinator struct {
	RemoveCoordinator int32 `protobuf:"varint,2,opt,name=remove_coordinator,json=removeCoordinator,proto3,oneof" json:"remove_coordinator,omitempty"`
}
type MemberChange_RemovePeer struct {
	RemovePeer int32 `protobuf:"varint,3,opt,name=remove_peer,json=removePeer,proto3,oneof" json:"remove_peer,omitempty"`
}
type MemberChange_ChangeMaster struct {
	ChangeMaster int32 `protobuf:"varint,4,opt,name=change_master,json=changeMaster,proto3,oneof" json:"change_master,omitempty"`
}
type MemberChange_AddLinker struct {
	AddLinker *Endpoint `protobuf:"bytes,5,opt,name=add_linker,json=addLinker,proto3,oneof" json:"add_linker,omitempty"`
}

func (*MemberChange_Add) isMemberChange_Op()               {}
func (*MemberChange_RemoveCoordinator) isMemberChange_Op() {}
func (*MemberChange_RemovePeer) isMemberChange_Op()        {}
func (*MemberChange_ChangeMaster) isMemberChange_Op()      {}
func (*MemberChange_AddLinker) isMemberChange_Op()         {}

func (m *MemberChange) GetOp() isMemberChange_Op {
	if m != nil {
		return m.Op
	}
	return nil
}

func (m *MemberChange) GetAdd() *StreamNode {
	if x, ok := m.GetOp().(*MemberChange_Add); ok {
		return x.Add
	}
	return nil
}

func (m *MemberChange) GetRemoveCoordinator() int32 {
	if x, ok := m.GetOp().(*MemberChange_RemoveCoordinator); ok {
		return x.RemoveCoordinator
	}
	return 0
}

func (m *MemberChange) GetRemovePeer() int32 {
	if x, ok := m.GetOp().(*MemberChange_RemovePeer); ok {
		return x.RemovePeer
	}
	return 0
}

func (m *MemberChange) GetChangeMaster() int32 {
	if x, ok := m.GetOp().(*MemberChange_ChangeMaster); ok {
		return x.ChangeMaster
	}
	return 0
}

func (m *MemberChange) GetAddLinker() *Endpoint {
	if x, ok := m.GetOp().(*MemberChange_AddLinker); ok {
		return x.AddLinker
	}
	return nil
}

// XXX_OneofWrappers is for the internal use of the proto package.
func (*MemberChange) XXX_OneofWrappers() []interface{} {
	return []interface{}{
		(*MemberChange_Add)(nil),
		(*MemberChange_RemoveCoordinator)(nil),
		(*MemberChange_RemovePeer)(nil),
		(*MemberChange_ChangeMaster)(nil),
		(*MemberChange_AddLinker)(nil),
	}
}

func init() {
	proto.RegisterEnum("sync.ConnectionState", ConnectionState_name, ConnectionState_value)
	proto.RegisterEnum("sync.Connection", Connection_name, Connection_value)
	proto.RegisterEnum("sync.Op", Op_name, Op_value)
	proto.RegisterEnum("sync.Metadata_Service", Metadata_Service_name, Metadata_Service_value)
	proto.RegisterEnum("sync.Node_State", Node_State_name, Node_State_value)
	proto.RegisterType((*Envelope)(nil), "sync.Envelope")
	proto.RegisterType((*Metadata)(nil), "sync.Metadata")
	proto.RegisterType((*Msg)(nil), "sync.Msg")
	proto.RegisterType((*Location)(nil), "sync.Location")
	proto.RegisterType((*CoordinatorList)(nil), "sync.CoordinatorList")
	proto.RegisterType((*CoordinatorList_Coordinator)(nil), "sync.CoordinatorList.Coordinator")
	proto.RegisterType((*SourceInfo)(nil), "sync.SourceInfo")
	proto.RegisterType((*Heartbeat)(nil), "sync.Heartbeat")
	proto.RegisterType((*Handshake)(nil), "sync.Handshake")
	proto.RegisterType((*BlockSeq)(nil), "sync.BlockSeq")
	proto.RegisterType((*BlockRequest)(nil), "sync.BlockRequest")
	proto.RegisterType((*ProgressResponse)(nil), "sync.ProgressResponse")
	proto.RegisterType((*Membership)(nil), "sync.Membership")
	proto.RegisterType((*Node)(nil), "sync.Node")
	proto.RegisterType((*OpResult)(nil), "sync.OpResult")
	proto.RegisterType((*StreamNode)(nil), "sync.StreamNode")
	proto.RegisterType((*MemberMap)(nil), "sync.MemberMap")
	proto.RegisterMapType((map[int32]*Node)(nil), "sync.MemberMap.IdToNodeEntry")
	proto.RegisterMapType((map[string]*Node)(nil), "sync.MemberMap.NameToNodeEntry")
	proto.RegisterType((*MemberDiff)(nil), "sync.MemberDiff")
	proto.RegisterType((*Ack)(nil), "sync.Ack")
	proto.RegisterType((*Endpoint)(nil), "sync.Endpoint")
	proto.RegisterType((*Config)(nil), "sync.Config")
	proto.RegisterType((*Org)(nil), "sync.Org")
	proto.RegisterType((*MemberChange)(nil), "sync.MemberChange")
}

func init() { proto.RegisterFile("sync/sync.proto", fileDescriptor_221a5c59bc60326f) }

var fileDescriptor_221a5c59bc60326f = []byte{
	// 1883 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xa4, 0x58, 0x5f, 0x6f, 0x1b, 0xc7,
	0x11, 0xe7, 0xf1, 0xf8, 0xe7, 0x6e, 0x48, 0x49, 0x97, 0x85, 0xeb, 0xb2, 0x4a, 0x2d, 0xcb, 0xd7,
	0x38, 0x15, 0x0c, 0x58, 0x74, 0x94, 0x22, 0x4d, 0xdb, 0x27, 0x4b, 0x71, 0x4a, 0xb5, 0x96, 0x2d,
	0x9c, 0x0c, 0xa3, 0x30, 0x50, 0x10, 0xab, 0xbb, 0x25, 0x79, 0x35, 0xb9, 0x4b, 0xef, 0x2e, 0x65,
	0x28, 0x9f, 0xa2, 0xc8, 0x4b, 0x81, 0x3e, 0xd4, 0xaf, 0xed, 0x5b, 0xbf, 0x45, 0xf3, 0xe8, 0xbe,
	0xf5, 0xb1, 0xb1, 0x81, 0x7e, 0x8e, 0x62, 0x76, 0xf7, 0x8e, 0x27, 0x51, 0x89, 0x5d, 0xf4, 0x85,
	0xb8, 0x99, 0xdf, 0xec, 0xdc, 0xdc, 0xec, 0xfc, 0x66, 0x76, 0x09, 0x1b, 0xea, 0x9c, 0xa7, 0x7d,
	0xfc, 0xd9, 0x9d, 0x4b, 0xa1, 0x05, 0x69, 0xe0, 0xf3, 0xe6, 0xb5, 0xb1, 0x18, 0x0b, 0xa3, 0xe8,
	0xe3, 0x93, 0xc5, 0x36, 0x6f, 0xa6, 0x82, 0x2b, 0xc6, 0xd5, 0x42, 0xf5, 0x25, 0x1d, 0xe9, 0x7e,
	0x29, 0xee, 0x39, 0x03, 0x92, 0x8a, 0xd9, 0x4c, 0xf0, 0xfe, 0xe9, 0x54, 0xa4, 0xcf, 0x9d, 0xee,
	0x07, 0x4e, 0xc7, 0x99, 0x1e, 0xa6, 0x82, 0x8f, 0xac, 0x3a, 0xfe, 0xb3, 0x07, 0xc1, 0x03, 0x7e,
	0xc6, 0xa6, 0x62, 0xce, 0xc8, 0x8f, 0x21, 0xd4, 0x4c, 0xce, 0x72, 0x4e, 0x35, 0xeb, 0x79, 0xdb,
	0xde, 0x4e, 0x90, 0x2c, 0x15, 0xe4, 0x23, 0x68, 0xcc, 0x98, 0xa6, 0xbd, 0xfa, 0xb6, 0xb7, 0xd3,
	0xd9, 0x5b, 0xdf, 0x35, 0xd1, 0x1e, 0x31, 0x4d, 0x33, 0xaa, 0xe9, 0xa0, 0x96, 0x18, 0x94, 0xdc,
	0x00, 0x7f, 0xa6, 0xc6, 0x3d, 0xdf, 0x18, 0x85, 0xce, 0x48, 0x8d, 0x07, 0xb5, 0x04, 0xf5, 0xe4,
	0x63, 0x68, 0x60, 0xb8, 0xbd, 0x86, 0xc1, 0xa3, 0xdd, 0x4a, 0xec, 0x07, 0x82, 0x2b, 0x74, 0x83,
	0xaa, 0x7d, 0x1f, 0xbc, 0x59, 0xfc, 0x0f, 0x0f, 0x82, 0xe2, 0x05, 0xe4, 0x47, 0x10, 0xa4, 0x13,
	0x9a, 0xf3, 0x61, 0x9e, 0x99, 0xd8, 0xc2, 0xa4, 0x6d, 0xe4, 0xc3, 0x8c, 0xfc, 0x10, 0xda, 0x23,
	0x29, 0x66, 0x88, 0x60, 0x70, 0xcd, 0xa4, 0x85, 0xe2, 0x61, 0x46, 0x3e, 0x84, 0xd0, 0x00, 0x5c,
	0x64, 0xcc, 0x84, 0x14, 0x26, 0x01, 0x2a, 0x1e, 0x89, 0x8c, 0x91, 0x7b, 0xd0, 0x56, 0x4c, 0x9e,
	0xe5, 0x29, 0x33, 0xd1, 0xac, 0xef, 0x5d, 0xbf, 0xf8, 0x49, 0xbb, 0x27, 0x16, 0x4d, 0x0a, 0xb3,
	0xf8, 0x73, 0x68, 0x3b, 0x1d, 0x59, 0x83, 0xf0, 0xa0, 0x08, 0x3d, 0xaa, 0x91, 0x08, 0xba, 0x27,
	0xe7, 0x3c, 0x9d, 0x48, 0xc1, 0xf3, 0xaf, 0x98, 0x8c, 0x3c, 0xd2, 0x85, 0xe0, 0x64, 0x42, 0x65,
	0x96, 0xf3, 0x71, 0x54, 0x8f, 0xff, 0xe9, 0x83, 0x7f, 0xa4, 0xc6, 0x18, 0xe9, 0x57, 0x82, 0xb3,
	0xe5, 0x37, 0xb4, 0x50, 0x3c, 0xcc, 0x30, 0xb9, 0xa9, 0xe0, 0xdc, 0xc4, 0xbf, 0xbe, 0x17, 0xd9,
	0x48, 0x0e, 0x04, 0xe7, 0x2c, 0xd5, 0xb9, 0xe0, 0x26, 0x2b, 0x9c, 0x5c, 0x87, 0x96, 0x64, 0x54,
	0x09, 0xee, 0x3e, 0xc6, 0x49, 0xe4, 0x53, 0xe8, 0x28, 0xb1, 0x90, 0x29, 0x1b, 0xe6, 0x7c, 0x24,
	0xca, 0xe4, 0x1a, 0x27, 0x27, 0x06, 0x38, 0xe4, 0x23, 0x31, 0xa8, 0x25, 0xa0, 0x4a, 0x89, 0xec,
	0x01, 0xcc, 0xd8, 0xec, 0x94, 0x49, 0x35, 0xc9, 0xe7, 0xbd, 0x66, 0x75, 0xcd, 0x51, 0xa9, 0xc7,
	0x35, 0x4b, 0x2b, 0xf2, 0x2b, 0xd8, 0x58, 0x4a, 0xc3, 0x2c, 0x1f, 0x8d, 0x7a, 0xad, 0xd5, 0x85,
	0x5f, 0xe4, 0xa3, 0xd1, 0xa0, 0x96, 0xac, 0x2f, 0x4d, 0x51, 0x43, 0x76, 0xa0, 0x65, 0x2a, 0x52,
	0xf5, 0xda, 0xd5, 0x12, 0xda, 0x47, 0xdd, 0x09, 0x7b, 0x31, 0xa8, 0x25, 0x0e, 0x27, 0x3f, 0x83,
	0x40, 0x32, 0x35, 0xc7, 0x04, 0xf7, 0x02, 0x63, 0xeb, 0xf6, 0xe6, 0x58, 0x8a, 0xb1, 0x64, 0x4a,
	0x25, 0x0e, 0x1d, 0xd4, 0x92, 0xd2, 0x92, 0xf4, 0x21, 0x9c, 0x30, 0x2a, 0xf5, 0x29, 0xa3, 0xba,
	0x17, 0x9a, 0x65, 0x1b, 0x76, 0xd9, 0xa0, 0x50, 0x0f, 0x6a, 0xc9, 0xd2, 0x86, 0x7c, 0x02, 0xa1,
	0x79, 0xe1, 0x50, 0xb2, 0x17, 0x3d, 0x30, 0x0b, 0x48, 0x25, 0xa6, 0x84, 0xbd, 0x58, 0x30, 0x85,
	0x6b, 0x82, 0x53, 0x27, 0xef, 0x87, 0xd0, 0x9e, 0xd3, 0xf3, 0xa9, 0xa0, 0x59, 0xfc, 0x14, 0x82,
	0x87, 0x22, 0xa5, 0xb8, 0x3d, 0x64, 0x1d, 0xea, 0x6e, 0x4b, 0x9b, 0x49, 0x3d, 0xcf, 0xc8, 0x26,
	0x04, 0x8b, 0xb9, 0xd2, 0x92, 0xd1, 0x59, 0xaf, 0xbe, 0xed, 0xef, 0x34, 0x93, 0x52, 0x26, 0x5b,
	0x00, 0x99, 0x78, 0xc9, 0x1d, 0xea, 0x1b, 0xb4, 0xa2, 0x89, 0xff, 0xee, 0xc1, 0xc6, 0x81, 0x10,
	0x58, 0x3a, 0x54, 0x0b, 0xf9, 0x30, 0x57, 0x9a, 0x3c, 0x80, 0x6e, 0xba, 0x54, 0xa9, 0x9e, 0xb7,
	0xed, 0xef, 0x74, 0xf6, 0x6e, 0x15, 0x65, 0x72, 0xc1, 0xb8, 0x2a, 0x27, 0x17, 0x96, 0x6d, 0x3e,
	0x85, 0x4e, 0x05, 0x24, 0x77, 0x20, 0x60, 0x3c, 0x9b, 0x8b, 0x9c, 0x6b, 0x13, 0x7b, 0xb9, 0x25,
	0x0f, 0x9c, 0x36, 0x29, 0x71, 0xa4, 0x52, 0xae, 0x86, 0x33, 0xaa, 0x34, 0x93, 0xa6, 0x4a, 0x83,
	0x24, 0xc8, 0xd5, 0x91, 0x91, 0xe3, 0xbf, 0x7a, 0x00, 0xcb, 0x3a, 0x23, 0xb7, 0x61, 0x3d, 0x57,
	0xc3, 0xca, 0x9b, 0x5d, 0x33, 0x59, 0xcb, 0x55, 0xf5, 0xf5, 0xb7, 0xa0, 0x6b, 0xcc, 0x90, 0x46,
	0x4b, 0xaf, 0x1d, 0x34, 0x72, 0x2a, 0x72, 0x17, 0x48, 0xa5, 0xde, 0xce, 0x98, 0x54, 0xb9, 0x2b,
	0xfe, 0x46, 0xf2, 0xc1, 0x12, 0x79, 0x6a, 0x01, 0xf4, 0x68, 0x37, 0x74, 0xc2, 0xf2, 0xf1, 0x44,
	0x1b, 0x22, 0x34, 0x92, 0x8e, 0xd1, 0x0d, 0x8c, 0x2a, 0xfe, 0x3d, 0x84, 0x65, 0x35, 0x7c, 0x87,
	0x7b, 0xef, 0x7d, 0xdd, 0xd7, 0x57, 0xdd, 0x3f, 0x83, 0x70, 0x40, 0x79, 0xa6, 0x26, 0xf4, 0x39,
	0xc3, 0x9c, 0x69, 0x2a, 0xc7, 0x4c, 0x0f, 0xcb, 0xe2, 0x08, 0xac, 0xe2, 0x30, 0x23, 0xf7, 0x2e,
	0xd0, 0xaf, 0x7e, 0x35, 0xfd, 0xaa, 0xe4, 0x8b, 0x0f, 0x21, 0x28, 0xb8, 0x82, 0x9d, 0xc0, 0x05,
	0x61, 0xa3, 0x75, 0x12, 0xb9, 0x5d, 0x72, 0xac, 0x6e, 0x4a, 0x64, 0x6d, 0xd7, 0xf6, 0x7d, 0x57,
	0xd1, 0x0e, 0x8c, 0x3f, 0x82, 0x6e, 0xb5, 0xc4, 0xc9, 0x35, 0x68, 0x9e, 0xb2, 0x71, 0x5e, 0x7c,
	0xbb, 0x15, 0x62, 0x0e, 0xd1, 0x65, 0xc2, 0xd9, 0x16, 0xf4, 0x07, 0x96, 0x6a, 0xb7, 0xa7, 0x4e,
	0xc2, 0xdc, 0xcc, 0xa8, 0x4e, 0x27, 0x97, 0x72, 0x63, 0x74, 0x36, 0x37, 0xe4, 0x26, 0x74, 0xa6,
	0x54, 0xe9, 0xc2, 0xc2, 0xee, 0x22, 0xa0, 0xca, 0x25, 0xef, 0x2f, 0x1e, 0xc0, 0xf2, 0xdb, 0xc9,
	0x36, 0x34, 0xb1, 0x71, 0x17, 0xd5, 0x0e, 0x36, 0x39, 0xd8, 0xbb, 0x13, 0x0b, 0x60, 0x30, 0xae,
	0x22, 0x7d, 0xdb, 0xf7, 0xad, 0x44, 0x7a, 0xd0, 0x2e, 0x36, 0xd3, 0xc6, 0x51, 0x88, 0x84, 0x40,
	0x43, 0xb1, 0xe9, 0xc8, 0x54, 0x46, 0x33, 0x31, 0xcf, 0x64, 0x07, 0xda, 0xd3, 0x9c, 0x3f, 0x67,
	0x52, 0xf5, 0x9a, 0xe6, 0x4d, 0x97, 0x59, 0x50, 0xc0, 0xf1, 0xab, 0x3a, 0x34, 0xcc, 0xec, 0xb8,
	0xcc, 0xf7, 0x2a, 0x93, 0xea, 0xef, 0x60, 0x52, 0xb5, 0x37, 0xf8, 0xdf, 0xdb, 0x1b, 0x1a, 0x97,
	0x7b, 0x03, 0xf9, 0x18, 0x9a, 0x4a, 0xe3, 0x74, 0x6e, 0x56, 0xe7, 0x04, 0x86, 0xb4, 0x7b, 0x82,
	0xfa, 0xc4, 0xc2, 0x57, 0x30, 0xb0, 0xf5, 0x3e, 0x0c, 0x6c, 0xaf, 0x30, 0x30, 0xbe, 0x0b, 0x4d,
	0xe3, 0x99, 0x84, 0xd0, 0xbc, 0x3f, 0xcd, 0xcf, 0x58, 0x54, 0xc3, 0xe1, 0x77, 0xb2, 0x50, 0x73,
	0x96, 0x6a, 0x96, 0x45, 0x1e, 0x01, 0x68, 0x7d, 0x49, 0x17, 0x53, 0x7d, 0x1e, 0xd5, 0xe3, 0xdf,
	0x42, 0xf0, 0x78, 0x9e, 0x30, 0xb5, 0x98, 0x6a, 0xb2, 0x0d, 0x0d, 0x33, 0x78, 0x6d, 0x6b, 0xa9,
	0x6c, 0x1f, 0x4e, 0x79, 0x44, 0xc8, 0x75, 0x68, 0x32, 0x29, 0x85, 0xa5, 0x7e, 0x38, 0xa8, 0x25,
	0x56, 0xdc, 0x6f, 0x82, 0x2f, 0x99, 0x8a, 0xbf, 0xc6, 0xb6, 0x62, 0x3e, 0xfc, 0xff, 0x4e, 0xfa,
	0x6a, 0x42, 0xfc, 0xf7, 0x49, 0x48, 0x63, 0x35, 0x21, 0xaf, 0xea, 0x10, 0xda, 0x22, 0x3d, 0xa2,
	0x38, 0x10, 0x21, 0xcf, 0x86, 0x5a, 0x0c, 0xdd, 0x97, 0x62, 0xf9, 0xdc, 0xa8, 0xb2, 0xf8, 0x88,
	0xce, 0x77, 0x0f, 0xb3, 0x27, 0x02, 0xbf, 0xe0, 0x01, 0xd7, 0xf2, 0x3c, 0x09, 0x72, 0x27, 0x92,
	0xfb, 0xd0, 0xe5, 0x74, 0xc6, 0xca, 0xe5, 0x96, 0xb2, 0x37, 0x2f, 0x2f, 0x7f, 0x44, 0x67, 0xac,
	0xea, 0x00, 0x78, 0xa9, 0xd8, 0xfc, 0x35, 0xac, 0x5d, 0xf0, 0x4e, 0x22, 0xf0, 0x9f, 0xb3, 0x73,
	0x97, 0x25, 0x7c, 0x44, 0x1a, 0x9d, 0xd1, 0xe9, 0x82, 0xb9, 0x1c, 0x5d, 0xa0, 0x91, 0x01, 0x7e,
	0x59, 0xff, 0xdc, 0xdb, 0x3c, 0x84, 0x8d, 0x4b, 0xef, 0xa9, 0xba, 0x0a, 0xff, 0x07, 0x57, 0xf1,
	0x9f, 0xea, 0x05, 0x8d, 0xcd, 0xd8, 0xff, 0x29, 0x84, 0x34, 0xcb, 0x86, 0xdf, 0x45, 0xe5, 0x80,
	0x66, 0xd9, 0x23, 0xc3, 0xe6, 0xbb, 0xd0, 0x95, 0x6c, 0x26, 0xce, 0x98, 0xb3, 0xad, 0xaf, 0xd8,
	0x76, 0x2c, 0x5e, 0x9a, 0x2f, 0xe6, 0x19, 0xd5, 0x85, 0xb9, 0xbf, 0x6a, 0x6e, 0x71, 0x6b, 0x7e,
	0x0b, 0xba, 0xe6, 0x2c, 0x58, 0x34, 0x06, 0x37, 0x1b, 0x50, 0x57, 0xf4, 0xf7, 0x1b, 0x00, 0x5a,
	0x94, 0x06, 0x4d, 0x63, 0x10, 0x6a, 0x51, 0xc0, 0xcb, 0x6e, 0xd3, 0xba, 0xd0, 0x6d, 0x2a, 0xfd,
	0xa3, 0xfd, 0xfd, 0xfd, 0x63, 0x07, 0xfc, 0xfb, 0xe9, 0xf3, 0x95, 0x39, 0xe2, 0xad, 0xce, 0x91,
	0x57, 0xe6, 0x5c, 0xee, 0x8a, 0x97, 0x40, 0x83, 0x66, 0x99, 0x34, 0x11, 0x85, 0x89, 0x79, 0x46,
	0xdd, 0x44, 0x28, 0xed, 0x76, 0xc7, 0x3c, 0xe3, 0xbc, 0x91, 0x4c, 0xe9, 0xe1, 0x5c, 0x48, 0xcb,
	0x88, 0x35, 0x73, 0x3a, 0xd2, 0xc7, 0x42, 0x6a, 0x3c, 0x3f, 0xcb, 0x79, 0x6a, 0x31, 0xdf, 0x60,
	0x6d, 0x39, 0x4f, 0x4b, 0x88, 0xbd, 0xb0, 0x50, 0xdb, 0x41, 0xec, 0x85, 0x81, 0x2a, 0x9d, 0xb4,
	0x61, 0x0f, 0xdd, 0x4e, 0x8c, 0xbf, 0xf6, 0xa1, 0x75, 0x20, 0xf8, 0x28, 0x1f, 0xbf, 0xe3, 0x68,
	0x8e, 0xbb, 0x53, 0x1c, 0xcd, 0xc3, 0xa4, 0x85, 0xe2, 0xe1, 0x45, 0xf2, 0xfa, 0xef, 0x20, 0x6f,
	0x5c, 0x69, 0xda, 0xab, 0x76, 0xb6, 0x89, 0xaf, 0x12, 0xbc, 0xf9, 0x3e, 0x04, 0x6f, 0x5d, 0x75,
	0xe6, 0x00, 0xc5, 0x58, 0x51, 0xb0, 0x57, 0xef, 0x68, 0x88, 0x16, 0xb6, 0xae, 0x3e, 0x81, 0xae,
	0xdd, 0x5e, 0xb7, 0x20, 0xb8, 0x72, 0x41, 0xc7, 0xda, 0xd8, 0x25, 0xdb, 0xd0, 0xc0, 0x63, 0xbf,
	0x3b, 0xa3, 0x76, 0x8b, 0x11, 0xfd, 0x4c, 0x70, 0x96, 0x18, 0x84, 0x7c, 0x08, 0xbe, 0x90, 0x63,
	0x77, 0x26, 0x75, 0xb7, 0xa8, 0xc7, 0x72, 0x9c, 0xa0, 0xd6, 0x6e, 0x97, 0xd2, 0x43, 0x3d, 0x55,
	0xbd, 0x8e, 0x89, 0xbf, 0x8d, 0xf2, 0x93, 0xa9, 0x8a, 0x7f, 0x01, 0xfe, 0x63, 0x39, 0xc6, 0xe2,
	0xc0, 0x1e, 0x51, 0x14, 0x07, 0x3e, 0xe3, 0x68, 0x99, 0xe3, 0x5d, 0x4e, 0x95, 0x63, 0xb1, 0x9b,
	0x54, 0x34, 0xf1, 0x7f, 0x3c, 0xe8, 0x5a, 0xd6, 0x1e, 0x4c, 0x28, 0x1f, 0xe3, 0x7d, 0xcf, 0xa7,
	0x59, 0xe6, 0xba, 0x77, 0x71, 0x99, 0x28, 0xbb, 0x31, 0x5e, 0xe8, 0x68, 0x96, 0x91, 0x3e, 0x10,
	0x47, 0xda, 0x6a, 0xee, 0xcd, 0x35, 0x6c, 0x50, 0x4b, 0x3e, 0xb0, 0xd8, 0xc5, 0x1d, 0x70, 0x2c,
	0x1e, 0xce, 0x59, 0x31, 0xb8, 0xf1, 0x96, 0x61, 0x95, 0xc7, 0x8c, 0x49, 0x72, 0x1b, 0xd6, 0x52,
	0x13, 0x43, 0x71, 0xde, 0x6c, 0x38, 0xa3, 0xae, 0x55, 0xdb, 0x53, 0x27, 0xe9, 0x03, 0x60, 0x63,
	0xb1, 0x99, 0x75, 0x17, 0x98, 0x4b, 0x79, 0xc7, 0xf3, 0x3e, 0xcd, 0xb2, 0x87, 0xc6, 0x64, 0xbf,
	0x01, 0x75, 0x31, 0xbf, 0xf3, 0x37, 0x73, 0xbe, 0x2e, 0x6e, 0x56, 0x76, 0xb8, 0x75, 0x21, 0xc0,
	0x37, 0x1f, 0xf2, 0x5c, 0x47, 0x35, 0xb2, 0x0e, 0x80, 0xd2, 0xfd, 0x54, 0xe3, 0xbc, 0xf3, 0x08,
	0x81, 0x75, 0x94, 0x8b, 0x45, 0x78, 0xa3, 0xc3, 0x19, 0x88, 0xba, 0x84, 0xd1, 0xec, 0x3c, 0xf2,
	0x4b, 0x07, 0xd9, 0x94, 0x45, 0x8d, 0xc2, 0x81, 0x9b, 0x8a, 0x4d, 0x72, 0x0d, 0x22, 0x94, 0xbf,
	0xc8, 0x55, 0x6a, 0x7d, 0xb0, 0x2c, 0x6a, 0xe1, 0xa5, 0xd1, 0xba, 0x98, 0x89, 0x33, 0x74, 0xda,
	0x26, 0x1b, 0xd0, 0x29, 0x35, 0x2c, 0x8b, 0x82, 0x3b, 0x3f, 0x07, 0x58, 0x86, 0x8a, 0xef, 0x7c,
	0xa0, 0x34, 0x3d, 0x9d, 0xe6, 0x6a, 0x12, 0xd5, 0x48, 0x07, 0xda, 0xc7, 0x52, 0xa4, 0x4c, 0xa9,
	0xc8, 0x43, 0xec, 0x49, 0x71, 0x55, 0x8f, 0xea, 0x77, 0x7e, 0x02, 0xf5, 0xc7, 0x73, 0x12, 0x40,
	0xe3, 0x37, 0x22, 0xe7, 0x51, 0x0d, 0xa7, 0xf7, 0x43, 0x46, 0xcd, 0xd7, 0x04, 0xd0, 0xf8, 0x92,
	0xe6, 0xd3, 0xa8, 0xbe, 0xf7, 0x19, 0xf8, 0xc7, 0x7b, 0xc7, 0xa4, 0x0f, 0x6d, 0xdc, 0x72, 0xce,
	0xa6, 0xa4, 0x4c, 0x9f, 0xfd, 0x47, 0x60, 0xf3, 0x92, 0x1c, 0xd7, 0x76, 0xbc, 0x7b, 0xde, 0xfe,
	0xef, 0xbe, 0xf9, 0x76, 0xab, 0xf6, 0xfa, 0xdb, 0xad, 0xda, 0x37, 0x6f, 0xb6, 0xbc, 0xd7, 0x6f,
	0xb6, 0xbc, 0x7f, 0xbf, 0xd9, 0xf2, 0xfe, 0xf8, 0x76, 0xab, 0xf6, 0xfa, 0xed, 0x56, 0xed, 0x5f,
	0x6f, 0xb7, 0x6a, 0xcf, 0x3e, 0x1b, 0xe7, 0x7a, 0x77, 0xb2, 0xa0, 0x2f, 0x59, 0x8e, 0xd5, 0xdd,
	0x9f, 0x8b, 0x5c, 0x29, 0x64, 0x18, 0x95, 0xe9, 0xa4, 0xff, 0x32, 0x67, 0x9c, 0x49, 0xd3, 0x22,
	0xfa, 0xf6, 0xdf, 0x0d, 0xf3, 0xf7, 0xc7, 0xfc, 0xf4, 0xb4, 0x65, 0xc4, 0x4f, 0xff, 0x1b, 0x00,
	0x00, 0xff, 0xff, 0x85, 0xe0, 0xb6, 0xd3, 0x10, 0x11, 0x00, 0x00,
}

// Reference imports to suppress errors if they are not otherwise used.
var _ context.Context
var _ grpc.ClientConn

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
const _ = grpc.SupportPackageIsVersion4

// P2PClient is the client API for P2P service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://godoc.org/google.golang.org/grpc#ClientConn.NewStream.
type P2PClient interface {
	// Channel is the gRPC stream used for sending and receiving messages
	Channel(ctx context.Context, opts ...grpc.CallOption) (P2P_ChannelClient, error)
}

type p2PClient struct {
	cc *grpc.ClientConn
}

func NewP2PClient(cc *grpc.ClientConn) P2PClient {
	return &p2PClient{cc}
}

func (c *p2PClient) Channel(ctx context.Context, opts ...grpc.CallOption) (P2P_ChannelClient, error) {
	stream, err := c.cc.NewStream(ctx, &_P2P_serviceDesc.Streams[0], "/sync.P2P/Channel", opts...)
	if err != nil {
		return nil, err
	}
	x := &p2PChannelClient{stream}
	return x, nil
}

type P2P_ChannelClient interface {
	Send(*Envelope) error
	Recv() (*Envelope, error)
	grpc.ClientStream
}

type p2PChannelClient struct {
	grpc.ClientStream
}

func (x *p2PChannelClient) Send(m *Envelope) error {
	return x.ClientStream.SendMsg(m)
}

func (x *p2PChannelClient) Recv() (*Envelope, error) {
	m := new(Envelope)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

// P2PServer is the server API for P2P service.
type P2PServer interface {
	// Channel is the gRPC stream used for sending and receiving messages
	Channel(P2P_ChannelServer) error
}

// UnimplementedP2PServer can be embedded to have forward compatible implementations.
type UnimplementedP2PServer struct {
}

func (*UnimplementedP2PServer) Channel(srv P2P_ChannelServer) error {
	return status.Errorf(codes.Unimplemented, "method Channel not implemented")
}

func RegisterP2PServer(s *grpc.Server, srv P2PServer) {
	s.RegisterService(&_P2P_serviceDesc, srv)
}

func _P2P_Channel_Handler(srv interface{}, stream grpc.ServerStream) error {
	return srv.(P2PServer).Channel(&p2PChannelServer{stream})
}

type P2P_ChannelServer interface {
	Send(*Envelope) error
	Recv() (*Envelope, error)
	grpc.ServerStream
}

type p2PChannelServer struct {
	grpc.ServerStream
}

func (x *p2PChannelServer) Send(m *Envelope) error {
	return x.ServerStream.SendMsg(m)
}

func (x *p2PChannelServer) Recv() (*Envelope, error) {
	m := new(Envelope)
	if err := x.ServerStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

var _P2P_serviceDesc = grpc.ServiceDesc{
	ServiceName: "sync.P2P",
	HandlerType: (*P2PServer)(nil),
	Methods:     []grpc.MethodDesc{},
	Streams: []grpc.StreamDesc{
		{
			StreamName:    "Channel",
			Handler:       _P2P_Channel_Handler,
			ServerStreams: true,
			ClientStreams: true,
		},
	},
	Metadata: "sync/sync.proto",
}

func (m *Envelope) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Envelope) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Envelope) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.M != nil {
		{
			size := m.M.Size()
			i -= size
			if _, err := m.M.MarshalTo(dAtA[i:]); err != nil {
				return 0, err
			}
		}
	}
	if m.Terminate {
		i--
		if m.Terminate {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *Envelope_Meta) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Envelope_Meta) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.Meta != nil {
		{
			size, err := m.Meta.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintSync(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	return len(dAtA) - i, nil
}
func (m *Envelope_Msg) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Envelope_Msg) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.Msg != nil {
		{
			size, err := m.Msg.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintSync(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1a
	}
	return len(dAtA) - i, nil
}
func (m *Envelope_Cons) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Envelope_Cons) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.Cons != nil {
		{
			size, err := m.Cons.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintSync(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x22
	}
	return len(dAtA) - i, nil
}
func (m *Metadata) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Metadata) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Metadata) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Service != 0 {
		i = encodeVarintSync(dAtA, i, uint64(m.Service))
		i--
		dAtA[i] = 0x20
	}
	if len(m.FromNode) > 0 {
		i -= len(m.FromNode)
		copy(dAtA[i:], m.FromNode)
		i = encodeVarintSync(dAtA, i, uint64(len(m.FromNode)))
		i--
		dAtA[i] = 0x1a
	}
	if m.FromId != 0 {
		i = encodeVarintSync(dAtA, i, uint64(m.FromId))
		i--
		dAtA[i] = 0x10
	}
	if len(m.ChainId) > 0 {
		i -= len(m.ChainId)
		copy(dAtA[i:], m.ChainId)
		i = encodeVarintSync(dAtA, i, uint64(len(m.ChainId)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *Msg) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Msg) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Msg) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Payload != nil {
		{
			size := m.Payload.Size()
			i -= size
			if _, err := m.Payload.MarshalTo(dAtA[i:]); err != nil {
				return 0, err
			}
		}
	}
	if len(m.Reason) > 0 {
		i -= len(m.Reason)
		copy(dAtA[i:], m.Reason)
		i = encodeVarintSync(dAtA, i, uint64(len(m.Reason)))
		i--
		dAtA[i] = 0x1a
	}
	if m.Conn != 0 {
		i = encodeVarintSync(dAtA, i, uint64(m.Conn))
		i--
		dAtA[i] = 0x10
	}
	if len(m.ZoneId) > 0 {
		i -= len(m.ZoneId)
		copy(dAtA[i:], m.ZoneId)
		i = encodeVarintSync(dAtA, i, uint64(len(m.ZoneId)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *Msg_SourceInfo) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Msg_SourceInfo) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.SourceInfo != nil {
		{
			size, err := m.SourceInfo.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintSync(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x22
	}
	return len(dAtA) - i, nil
}
func (m *Msg_Membership) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Msg_Membership) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.Membership != nil {
		{
			size, err := m.Membership.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintSync(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x2a
	}
	return len(dAtA) - i, nil
}
func (m *Msg_MembershipDiff) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Msg_MembershipDiff) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.MembershipDiff != nil {
		{
			size, err := m.MembershipDiff.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintSync(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x32
	}
	return len(dAtA) - i, nil
}
func (m *Msg_Blocks) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Msg_Blocks) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.Blocks != nil {
		{
			size, err := m.Blocks.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintSync(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x3a
	}
	return len(dAtA) - i, nil
}
func (m *Msg_Response) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Msg_Response) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.Response != nil {
		{
			size, err := m.Response.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintSync(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x42
	}
	return len(dAtA) - i, nil
}
func (m *Msg_Heartbeat) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Msg_Heartbeat) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.Heartbeat != nil {
		{
			size, err := m.Heartbeat.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintSync(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x4a
	}
	return len(dAtA) - i, nil
}
func (m *Msg_BlockReq) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Msg_BlockReq) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.BlockReq != nil {
		{
			size, err := m.BlockReq.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintSync(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x52
	}
	return len(dAtA) - i, nil
}
func (m *Location) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Location) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Location) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Downstream) > 0 {
		dAtA12 := make([]byte, len(m.Downstream)*10)
		var j11 int
		for _, num1 := range m.Downstream {
			num := uint64(num1)
			for num >= 1<<7 {
				dAtA12[j11] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j11++
			}
			dAtA12[j11] = uint8(num)
			j11++
		}
		i -= j11
		copy(dAtA[i:], dAtA12[:j11])
		i = encodeVarintSync(dAtA, i, uint64(j11))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.Upstream) > 0 {
		dAtA14 := make([]byte, len(m.Upstream)*10)
		var j13 int
		for _, num1 := range m.Upstream {
			num := uint64(num1)
			for num >= 1<<7 {
				dAtA14[j13] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j13++
			}
			dAtA14[j13] = uint8(num)
			j13++
		}
		i -= j13
		copy(dAtA[i:], dAtA14[:j13])
		i = encodeVarintSync(dAtA, i, uint64(j13))
		i--
		dAtA[i] = 0x12
	}
	if m.Id != 0 {
		i = encodeVarintSync(dAtA, i, uint64(m.Id))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *CoordinatorList) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CoordinatorList) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *CoordinatorList) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Coordinators) > 0 {
		for iNdEx := len(m.Coordinators) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Coordinators[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintSync(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *CoordinatorList_Coordinator) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CoordinatorList_Coordinator) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *CoordinatorList_Coordinator) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.IsMaster {
		i--
		if m.IsMaster {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x10
	}
	if m.Endpoint != nil {
		{
			size, err := m.Endpoint.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintSync(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *SourceInfo) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SourceInfo) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *SourceInfo) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.BlockHeight != 0 {
		i = encodeVarintSync(dAtA, i, uint64(m.BlockHeight))
		i--
		dAtA[i] = 0x20
	}
	if m.MembershipVersion != 0 {
		i = encodeVarintSync(dAtA, i, uint64(m.MembershipVersion))
		i--
		dAtA[i] = 0x18
	}
	if m.IsConsenter {
		i--
		if m.IsConsenter {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x10
	}
	if m.IsCoordinator {
		i--
		if m.IsCoordinator {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *Heartbeat) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Heartbeat) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Heartbeat) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.BlockHeight != 0 {
		i = encodeVarintSync(dAtA, i, uint64(m.BlockHeight))
		i--
		dAtA[i] = 0x10
	}
	if m.MembershipVersion != 0 {
		i = encodeVarintSync(dAtA, i, uint64(m.MembershipVersion))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *Handshake) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Handshake) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Handshake) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Membership != nil {
		{
			size, err := m.Membership.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintSync(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	if m.TargetId != 0 {
		i = encodeVarintSync(dAtA, i, uint64(m.TargetId))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *BlockSeq) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *BlockSeq) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *BlockSeq) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Blocks) > 0 {
		for iNdEx := len(m.Blocks) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Blocks[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintSync(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x12
		}
	}
	if m.Height != 0 {
		i = encodeVarintSync(dAtA, i, uint64(m.Height))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *BlockRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *BlockRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *BlockRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Begin != 0 {
		i = encodeVarintSync(dAtA, i, uint64(m.Begin))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *ProgressResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ProgressResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ProgressResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.LastHeight != 0 {
		i = encodeVarintSync(dAtA, i, uint64(m.LastHeight))
		i--
		dAtA[i] = 0x18
	}
	if m.MatchHeight != 0 {
		i = encodeVarintSync(dAtA, i, uint64(m.MatchHeight))
		i--
		dAtA[i] = 0x10
	}
	if m.Reject {
		i--
		if m.Reject {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *Membership) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Membership) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Membership) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Linkers) > 0 {
		for iNdEx := len(m.Linkers) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Linkers[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintSync(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x2a
		}
	}
	if m.Self != 0 {
		i = encodeVarintSync(dAtA, i, uint64(m.Self))
		i--
		dAtA[i] = 0x20
	}
	if m.Master != 0 {
		i = encodeVarintSync(dAtA, i, uint64(m.Master))
		i--
		dAtA[i] = 0x18
	}
	if m.Version != 0 {
		i = encodeVarintSync(dAtA, i, uint64(m.Version))
		i--
		dAtA[i] = 0x10
	}
	if len(m.Nodes) > 0 {
		for iNdEx := len(m.Nodes) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Nodes[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintSync(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *Node) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Node) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Node) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.IsConsenter {
		i--
		if m.IsConsenter {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x38
	}
	if m.IsCoordinator {
		i--
		if m.IsCoordinator {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x30
	}
	if m.State != 0 {
		i = encodeVarintSync(dAtA, i, uint64(m.State))
		i--
		dAtA[i] = 0x28
	}
	if len(m.Downstream) > 0 {
		dAtA18 := make([]byte, len(m.Downstream)*10)
		var j17 int
		for _, num1 := range m.Downstream {
			num := uint64(num1)
			for num >= 1<<7 {
				dAtA18[j17] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j17++
			}
			dAtA18[j17] = uint8(num)
			j17++
		}
		i -= j17
		copy(dAtA[i:], dAtA18[:j17])
		i = encodeVarintSync(dAtA, i, uint64(j17))
		i--
		dAtA[i] = 0x22
	}
	if len(m.Upstream) > 0 {
		dAtA20 := make([]byte, len(m.Upstream)*10)
		var j19 int
		for _, num1 := range m.Upstream {
			num := uint64(num1)
			for num >= 1<<7 {
				dAtA20[j19] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j19++
			}
			dAtA20[j19] = uint8(num)
			j19++
		}
		i -= j19
		copy(dAtA[i:], dAtA20[:j19])
		i = encodeVarintSync(dAtA, i, uint64(j19))
		i--
		dAtA[i] = 0x1a
	}
	if m.Endpoint != nil {
		{
			size, err := m.Endpoint.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintSync(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	if m.Id != 0 {
		i = encodeVarintSync(dAtA, i, uint64(m.Id))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *OpResult) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *OpResult) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *OpResult) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Res != nil {
		{
			size := m.Res.Size()
			i -= size
			if _, err := m.Res.MarshalTo(dAtA[i:]); err != nil {
				return 0, err
			}
		}
	}
	return len(dAtA) - i, nil
}

func (m *OpResult_Node) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *OpResult_Node) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.Node != nil {
		{
			size, err := m.Node.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintSync(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}
func (m *OpResult_Error) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *OpResult_Error) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	i -= len(m.Error)
	copy(dAtA[i:], m.Error)
	i = encodeVarintSync(dAtA, i, uint64(len(m.Error)))
	i--
	dAtA[i] = 0x12
	return len(dAtA) - i, nil
}
func (m *StreamNode) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *StreamNode) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *StreamNode) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.IsConsenter {
		i--
		if m.IsConsenter {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x20
	}
	if m.IsCoordinator {
		i--
		if m.IsCoordinator {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x18
	}
	if m.Endpoint != nil {
		{
			size, err := m.Endpoint.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintSync(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	if m.Id != 0 {
		i = encodeVarintSync(dAtA, i, uint64(m.Id))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *MemberMap) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MemberMap) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MemberMap) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.NameToNode) > 0 {
		for k := range m.NameToNode {
			v := m.NameToNode[k]
			baseI := i
			if v != nil {
				{
					size, err := v.MarshalToSizedBuffer(dAtA[:i])
					if err != nil {
						return 0, err
					}
					i -= size
					i = encodeVarintSync(dAtA, i, uint64(size))
				}
				i--
				dAtA[i] = 0x12
			}
			i -= len(k)
			copy(dAtA[i:], k)
			i = encodeVarintSync(dAtA, i, uint64(len(k)))
			i--
			dAtA[i] = 0xa
			i = encodeVarintSync(dAtA, i, uint64(baseI-i))
			i--
			dAtA[i] = 0x12
		}
	}
	if len(m.IdToNode) > 0 {
		for k := range m.IdToNode {
			v := m.IdToNode[k]
			baseI := i
			if v != nil {
				{
					size, err := v.MarshalToSizedBuffer(dAtA[:i])
					if err != nil {
						return 0, err
					}
					i -= size
					i = encodeVarintSync(dAtA, i, uint64(size))
				}
				i--
				dAtA[i] = 0x12
			}
			i = encodeVarintSync(dAtA, i, uint64(k))
			i--
			dAtA[i] = 0x8
			i = encodeVarintSync(dAtA, i, uint64(baseI-i))
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *MemberDiff) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MemberDiff) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MemberDiff) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Linkers) > 0 {
		for iNdEx := len(m.Linkers) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Linkers[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintSync(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x3a
		}
	}
	if m.Master != 0 {
		i = encodeVarintSync(dAtA, i, uint64(m.Master))
		i--
		dAtA[i] = 0x30
	}
	if m.ToVersion != 0 {
		i = encodeVarintSync(dAtA, i, uint64(m.ToVersion))
		i--
		dAtA[i] = 0x28
	}
	if m.FromVersion != 0 {
		i = encodeVarintSync(dAtA, i, uint64(m.FromVersion))
		i--
		dAtA[i] = 0x20
	}
	if len(m.UpdateNodes) > 0 {
		for iNdEx := len(m.UpdateNodes) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.UpdateNodes[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintSync(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x1a
		}
	}
	if len(m.RemoveNodes) > 0 {
		for iNdEx := len(m.RemoveNodes) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.RemoveNodes[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintSync(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x12
		}
	}
	if len(m.AddNodes) > 0 {
		for iNdEx := len(m.AddNodes) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.AddNodes[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintSync(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *Ack) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Ack) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Ack) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.BlockHeight != 0 {
		i = encodeVarintSync(dAtA, i, uint64(m.BlockHeight))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *Endpoint) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Endpoint) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Endpoint) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.ReqPort != 0 {
		i = encodeVarintSync(dAtA, i, uint64(m.ReqPort))
		i--
		dAtA[i] = 0x38
	}
	if len(m.Addr) > 0 {
		i -= len(m.Addr)
		copy(dAtA[i:], m.Addr)
		i = encodeVarintSync(dAtA, i, uint64(len(m.Addr)))
		i--
		dAtA[i] = 0x2a
	}
	if len(m.Version) > 0 {
		i -= len(m.Version)
		copy(dAtA[i:], m.Version)
		i = encodeVarintSync(dAtA, i, uint64(len(m.Version)))
		i--
		dAtA[i] = 0x22
	}
	if m.RpcPort != 0 {
		i = encodeVarintSync(dAtA, i, uint64(m.RpcPort))
		i--
		dAtA[i] = 0x18
	}
	if m.RestPort != 0 {
		i = encodeVarintSync(dAtA, i, uint64(m.RestPort))
		i--
		dAtA[i] = 0x10
	}
	if len(m.Host) > 0 {
		i -= len(m.Host)
		copy(dAtA[i:], m.Host)
		i = encodeVarintSync(dAtA, i, uint64(len(m.Host)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *Config) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Config) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Config) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.RestTls {
		i--
		if m.RestTls {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x58
	}
	if m.Org != nil {
		{
			size, err := m.Org.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintSync(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x52
	}
	if m.Zone != nil {
		{
			size, err := m.Zone.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintSync(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x4a
	}
	if len(m.LinkerNodes) > 0 {
		for iNdEx := len(m.LinkerNodes) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.LinkerNodes[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintSync(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x42
		}
	}
	if len(m.SeedNodes) > 0 {
		for iNdEx := len(m.SeedNodes) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.SeedNodes[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintSync(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x3a
		}
	}
	if m.IsConsenter {
		i--
		if m.IsConsenter {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x30
	}
	if m.IsCoordinator {
		i--
		if m.IsCoordinator {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x28
	}
	if m.Self != nil {
		{
			size, err := m.Self.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintSync(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x22
	}
	if m.Endpoint != nil {
		{
			size, err := m.Endpoint.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintSync(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1a
	}
	if len(m.NodeId) > 0 {
		i -= len(m.NodeId)
		copy(dAtA[i:], m.NodeId)
		i = encodeVarintSync(dAtA, i, uint64(len(m.NodeId)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.ChainId) > 0 {
		i -= len(m.ChainId)
		copy(dAtA[i:], m.ChainId)
		i = encodeVarintSync(dAtA, i, uint64(len(m.ChainId)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *Org) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Org) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Org) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Permission) > 0 {
		i -= len(m.Permission)
		copy(dAtA[i:], m.Permission)
		i = encodeVarintSync(dAtA, i, uint64(len(m.Permission)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Name) > 0 {
		i -= len(m.Name)
		copy(dAtA[i:], m.Name)
		i = encodeVarintSync(dAtA, i, uint64(len(m.Name)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *MemberChange) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MemberChange) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MemberChange) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Op != nil {
		{
			size := m.Op.Size()
			i -= size
			if _, err := m.Op.MarshalTo(dAtA[i:]); err != nil {
				return 0, err
			}
		}
	}
	return len(dAtA) - i, nil
}

func (m *MemberChange_Add) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MemberChange_Add) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.Add != nil {
		{
			size, err := m.Add.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintSync(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}
func (m *MemberChange_RemoveCoordinator) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MemberChange_RemoveCoordinator) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	i = encodeVarintSync(dAtA, i, uint64(m.RemoveCoordinator))
	i--
	dAtA[i] = 0x10
	return len(dAtA) - i, nil
}
func (m *MemberChange_RemovePeer) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MemberChange_RemovePeer) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	i = encodeVarintSync(dAtA, i, uint64(m.RemovePeer))
	i--
	dAtA[i] = 0x18
	return len(dAtA) - i, nil
}
func (m *MemberChange_ChangeMaster) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MemberChange_ChangeMaster) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	i = encodeVarintSync(dAtA, i, uint64(m.ChangeMaster))
	i--
	dAtA[i] = 0x20
	return len(dAtA) - i, nil
}
func (m *MemberChange_AddLinker) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MemberChange_AddLinker) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.AddLinker != nil {
		{
			size, err := m.AddLinker.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintSync(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x2a
	}
	return len(dAtA) - i, nil
}
func encodeVarintSync(dAtA []byte, offset int, v uint64) int {
	offset -= sovSync(v)
	base := offset
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return base
}
func (m *Envelope) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Terminate {
		n += 2
	}
	if m.M != nil {
		n += m.M.Size()
	}
	return n
}

func (m *Envelope_Meta) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Meta != nil {
		l = m.Meta.Size()
		n += 1 + l + sovSync(uint64(l))
	}
	return n
}
func (m *Envelope_Msg) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Msg != nil {
		l = m.Msg.Size()
		n += 1 + l + sovSync(uint64(l))
	}
	return n
}
func (m *Envelope_Cons) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Cons != nil {
		l = m.Cons.Size()
		n += 1 + l + sovSync(uint64(l))
	}
	return n
}
func (m *Metadata) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.ChainId)
	if l > 0 {
		n += 1 + l + sovSync(uint64(l))
	}
	if m.FromId != 0 {
		n += 1 + sovSync(uint64(m.FromId))
	}
	l = len(m.FromNode)
	if l > 0 {
		n += 1 + l + sovSync(uint64(l))
	}
	if m.Service != 0 {
		n += 1 + sovSync(uint64(m.Service))
	}
	return n
}

func (m *Msg) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.ZoneId)
	if l > 0 {
		n += 1 + l + sovSync(uint64(l))
	}
	if m.Conn != 0 {
		n += 1 + sovSync(uint64(m.Conn))
	}
	l = len(m.Reason)
	if l > 0 {
		n += 1 + l + sovSync(uint64(l))
	}
	if m.Payload != nil {
		n += m.Payload.Size()
	}
	return n
}

func (m *Msg_SourceInfo) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.SourceInfo != nil {
		l = m.SourceInfo.Size()
		n += 1 + l + sovSync(uint64(l))
	}
	return n
}
func (m *Msg_Membership) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Membership != nil {
		l = m.Membership.Size()
		n += 1 + l + sovSync(uint64(l))
	}
	return n
}
func (m *Msg_MembershipDiff) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.MembershipDiff != nil {
		l = m.MembershipDiff.Size()
		n += 1 + l + sovSync(uint64(l))
	}
	return n
}
func (m *Msg_Blocks) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Blocks != nil {
		l = m.Blocks.Size()
		n += 1 + l + sovSync(uint64(l))
	}
	return n
}
func (m *Msg_Response) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Response != nil {
		l = m.Response.Size()
		n += 1 + l + sovSync(uint64(l))
	}
	return n
}
func (m *Msg_Heartbeat) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Heartbeat != nil {
		l = m.Heartbeat.Size()
		n += 1 + l + sovSync(uint64(l))
	}
	return n
}
func (m *Msg_BlockReq) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.BlockReq != nil {
		l = m.BlockReq.Size()
		n += 1 + l + sovSync(uint64(l))
	}
	return n
}
func (m *Location) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Id != 0 {
		n += 1 + sovSync(uint64(m.Id))
	}
	if len(m.Upstream) > 0 {
		l = 0
		for _, e := range m.Upstream {
			l += sovSync(uint64(e))
		}
		n += 1 + sovSync(uint64(l)) + l
	}
	if len(m.Downstream) > 0 {
		l = 0
		for _, e := range m.Downstream {
			l += sovSync(uint64(e))
		}
		n += 1 + sovSync(uint64(l)) + l
	}
	return n
}

func (m *CoordinatorList) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Coordinators) > 0 {
		for _, e := range m.Coordinators {
			l = e.Size()
			n += 1 + l + sovSync(uint64(l))
		}
	}
	return n
}

func (m *CoordinatorList_Coordinator) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Endpoint != nil {
		l = m.Endpoint.Size()
		n += 1 + l + sovSync(uint64(l))
	}
	if m.IsMaster {
		n += 2
	}
	return n
}

func (m *SourceInfo) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.IsCoordinator {
		n += 2
	}
	if m.IsConsenter {
		n += 2
	}
	if m.MembershipVersion != 0 {
		n += 1 + sovSync(uint64(m.MembershipVersion))
	}
	if m.BlockHeight != 0 {
		n += 1 + sovSync(uint64(m.BlockHeight))
	}
	return n
}

func (m *Heartbeat) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.MembershipVersion != 0 {
		n += 1 + sovSync(uint64(m.MembershipVersion))
	}
	if m.BlockHeight != 0 {
		n += 1 + sovSync(uint64(m.BlockHeight))
	}
	return n
}

func (m *Handshake) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.TargetId != 0 {
		n += 1 + sovSync(uint64(m.TargetId))
	}
	if m.Membership != nil {
		l = m.Membership.Size()
		n += 1 + l + sovSync(uint64(l))
	}
	return n
}

func (m *BlockSeq) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Height != 0 {
		n += 1 + sovSync(uint64(m.Height))
	}
	if len(m.Blocks) > 0 {
		for _, e := range m.Blocks {
			l = e.Size()
			n += 1 + l + sovSync(uint64(l))
		}
	}
	return n
}

func (m *BlockRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Begin != 0 {
		n += 1 + sovSync(uint64(m.Begin))
	}
	return n
}

func (m *ProgressResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Reject {
		n += 2
	}
	if m.MatchHeight != 0 {
		n += 1 + sovSync(uint64(m.MatchHeight))
	}
	if m.LastHeight != 0 {
		n += 1 + sovSync(uint64(m.LastHeight))
	}
	return n
}

func (m *Membership) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Nodes) > 0 {
		for _, e := range m.Nodes {
			l = e.Size()
			n += 1 + l + sovSync(uint64(l))
		}
	}
	if m.Version != 0 {
		n += 1 + sovSync(uint64(m.Version))
	}
	if m.Master != 0 {
		n += 1 + sovSync(uint64(m.Master))
	}
	if m.Self != 0 {
		n += 1 + sovSync(uint64(m.Self))
	}
	if len(m.Linkers) > 0 {
		for _, e := range m.Linkers {
			l = e.Size()
			n += 1 + l + sovSync(uint64(l))
		}
	}
	return n
}

func (m *Node) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Id != 0 {
		n += 1 + sovSync(uint64(m.Id))
	}
	if m.Endpoint != nil {
		l = m.Endpoint.Size()
		n += 1 + l + sovSync(uint64(l))
	}
	if len(m.Upstream) > 0 {
		l = 0
		for _, e := range m.Upstream {
			l += sovSync(uint64(e))
		}
		n += 1 + sovSync(uint64(l)) + l
	}
	if len(m.Downstream) > 0 {
		l = 0
		for _, e := range m.Downstream {
			l += sovSync(uint64(e))
		}
		n += 1 + sovSync(uint64(l)) + l
	}
	if m.State != 0 {
		n += 1 + sovSync(uint64(m.State))
	}
	if m.IsCoordinator {
		n += 2
	}
	if m.IsConsenter {
		n += 2
	}
	return n
}

func (m *OpResult) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Res != nil {
		n += m.Res.Size()
	}
	return n
}

func (m *OpResult_Node) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Node != nil {
		l = m.Node.Size()
		n += 1 + l + sovSync(uint64(l))
	}
	return n
}
func (m *OpResult_Error) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Error)
	n += 1 + l + sovSync(uint64(l))
	return n
}
func (m *StreamNode) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Id != 0 {
		n += 1 + sovSync(uint64(m.Id))
	}
	if m.Endpoint != nil {
		l = m.Endpoint.Size()
		n += 1 + l + sovSync(uint64(l))
	}
	if m.IsCoordinator {
		n += 2
	}
	if m.IsConsenter {
		n += 2
	}
	return n
}

func (m *MemberMap) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.IdToNode) > 0 {
		for k, v := range m.IdToNode {
			_ = k
			_ = v
			l = 0
			if v != nil {
				l = v.Size()
				l += 1 + sovSync(uint64(l))
			}
			mapEntrySize := 1 + sovSync(uint64(k)) + l
			n += mapEntrySize + 1 + sovSync(uint64(mapEntrySize))
		}
	}
	if len(m.NameToNode) > 0 {
		for k, v := range m.NameToNode {
			_ = k
			_ = v
			l = 0
			if v != nil {
				l = v.Size()
				l += 1 + sovSync(uint64(l))
			}
			mapEntrySize := 1 + len(k) + sovSync(uint64(len(k))) + l
			n += mapEntrySize + 1 + sovSync(uint64(mapEntrySize))
		}
	}
	return n
}

func (m *MemberDiff) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.AddNodes) > 0 {
		for _, e := range m.AddNodes {
			l = e.Size()
			n += 1 + l + sovSync(uint64(l))
		}
	}
	if len(m.RemoveNodes) > 0 {
		for _, e := range m.RemoveNodes {
			l = e.Size()
			n += 1 + l + sovSync(uint64(l))
		}
	}
	if len(m.UpdateNodes) > 0 {
		for _, e := range m.UpdateNodes {
			l = e.Size()
			n += 1 + l + sovSync(uint64(l))
		}
	}
	if m.FromVersion != 0 {
		n += 1 + sovSync(uint64(m.FromVersion))
	}
	if m.ToVersion != 0 {
		n += 1 + sovSync(uint64(m.ToVersion))
	}
	if m.Master != 0 {
		n += 1 + sovSync(uint64(m.Master))
	}
	if len(m.Linkers) > 0 {
		for _, e := range m.Linkers {
			l = e.Size()
			n += 1 + l + sovSync(uint64(l))
		}
	}
	return n
}

func (m *Ack) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.BlockHeight != 0 {
		n += 1 + sovSync(uint64(m.BlockHeight))
	}
	return n
}

func (m *Endpoint) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Host)
	if l > 0 {
		n += 1 + l + sovSync(uint64(l))
	}
	if m.RestPort != 0 {
		n += 1 + sovSync(uint64(m.RestPort))
	}
	if m.RpcPort != 0 {
		n += 1 + sovSync(uint64(m.RpcPort))
	}
	l = len(m.Version)
	if l > 0 {
		n += 1 + l + sovSync(uint64(l))
	}
	l = len(m.Addr)
	if l > 0 {
		n += 1 + l + sovSync(uint64(l))
	}
	if m.ReqPort != 0 {
		n += 1 + sovSync(uint64(m.ReqPort))
	}
	return n
}

func (m *Config) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.ChainId)
	if l > 0 {
		n += 1 + l + sovSync(uint64(l))
	}
	l = len(m.NodeId)
	if l > 0 {
		n += 1 + l + sovSync(uint64(l))
	}
	if m.Endpoint != nil {
		l = m.Endpoint.Size()
		n += 1 + l + sovSync(uint64(l))
	}
	if m.Self != nil {
		l = m.Self.Size()
		n += 1 + l + sovSync(uint64(l))
	}
	if m.IsCoordinator {
		n += 2
	}
	if m.IsConsenter {
		n += 2
	}
	if len(m.SeedNodes) > 0 {
		for _, e := range m.SeedNodes {
			l = e.Size()
			n += 1 + l + sovSync(uint64(l))
		}
	}
	if len(m.LinkerNodes) > 0 {
		for _, e := range m.LinkerNodes {
			l = e.Size()
			n += 1 + l + sovSync(uint64(l))
		}
	}
	if m.Zone != nil {
		l = m.Zone.Size()
		n += 1 + l + sovSync(uint64(l))
	}
	if m.Org != nil {
		l = m.Org.Size()
		n += 1 + l + sovSync(uint64(l))
	}
	if m.RestTls {
		n += 2
	}
	return n
}

func (m *Org) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovSync(uint64(l))
	}
	l = len(m.Permission)
	if l > 0 {
		n += 1 + l + sovSync(uint64(l))
	}
	return n
}

func (m *MemberChange) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Op != nil {
		n += m.Op.Size()
	}
	return n
}

func (m *MemberChange_Add) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Add != nil {
		l = m.Add.Size()
		n += 1 + l + sovSync(uint64(l))
	}
	return n
}
func (m *MemberChange_RemoveCoordinator) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	n += 1 + sovSync(uint64(m.RemoveCoordinator))
	return n
}
func (m *MemberChange_RemovePeer) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	n += 1 + sovSync(uint64(m.RemovePeer))
	return n
}
func (m *MemberChange_ChangeMaster) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	n += 1 + sovSync(uint64(m.ChangeMaster))
	return n
}
func (m *MemberChange_AddLinker) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.AddLinker != nil {
		l = m.AddLinker.Size()
		n += 1 + l + sovSync(uint64(l))
	}
	return n
}

func sovSync(x uint64) (n int) {
	return (math_bits.Len64(x|1) + 6) / 7
}
func sozSync(x uint64) (n int) {
	return sovSync(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (m *Envelope) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowSync
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Envelope: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Envelope: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Terminate", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSync
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Terminate = bool(v != 0)
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Meta", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSync
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthSync
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthSync
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &Metadata{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.M = &Envelope_Meta{v}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Msg", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSync
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthSync
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthSync
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &Msg{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.M = &Envelope_Msg{v}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Cons", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSync
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthSync
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthSync
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &pb.Cons{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.M = &Envelope_Cons{v}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipSync(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthSync
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Metadata) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowSync
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Metadata: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Metadata: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ChainId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSync
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthSync
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthSync
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ChainId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field FromId", wireType)
			}
			m.FromId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSync
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.FromId |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field FromNode", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSync
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthSync
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthSync
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.FromNode = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Service", wireType)
			}
			m.Service = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSync
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Service |= Metadata_Service(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipSync(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthSync
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Msg) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowSync
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Msg: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Msg: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ZoneId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSync
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthSync
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthSync
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ZoneId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Conn", wireType)
			}
			m.Conn = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSync
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Conn |= Connection(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Reason", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSync
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthSync
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthSync
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Reason = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SourceInfo", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSync
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthSync
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthSync
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &SourceInfo{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Payload = &Msg_SourceInfo{v}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Membership", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSync
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthSync
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthSync
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &Membership{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Payload = &Msg_Membership{v}
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MembershipDiff", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSync
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthSync
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthSync
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &MemberDiff{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Payload = &Msg_MembershipDiff{v}
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Blocks", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSync
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthSync
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthSync
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &BlockSeq{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Payload = &Msg_Blocks{v}
			iNdEx = postIndex
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Response", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSync
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthSync
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthSync
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &ProgressResponse{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Payload = &Msg_Response{v}
			iNdEx = postIndex
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Heartbeat", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSync
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthSync
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthSync
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &Heartbeat{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Payload = &Msg_Heartbeat{v}
			iNdEx = postIndex
		case 10:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field BlockReq", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSync
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthSync
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthSync
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &BlockRequest{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Payload = &Msg_BlockReq{v}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipSync(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthSync
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Location) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowSync
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Location: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Location: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			m.Id = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSync
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Id |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType == 0 {
				var v int32
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowSync
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= int32(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.Upstream = append(m.Upstream, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowSync
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthSync
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLengthSync
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				var count int
				for _, integer := range dAtA[iNdEx:postIndex] {
					if integer < 128 {
						count++
					}
				}
				elementCount = count
				if elementCount != 0 && len(m.Upstream) == 0 {
					m.Upstream = make([]int32, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v int32
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowSync
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= int32(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.Upstream = append(m.Upstream, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field Upstream", wireType)
			}
		case 3:
			if wireType == 0 {
				var v int32
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowSync
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= int32(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.Downstream = append(m.Downstream, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowSync
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthSync
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLengthSync
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				var count int
				for _, integer := range dAtA[iNdEx:postIndex] {
					if integer < 128 {
						count++
					}
				}
				elementCount = count
				if elementCount != 0 && len(m.Downstream) == 0 {
					m.Downstream = make([]int32, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v int32
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowSync
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= int32(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.Downstream = append(m.Downstream, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field Downstream", wireType)
			}
		default:
			iNdEx = preIndex
			skippy, err := skipSync(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthSync
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CoordinatorList) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowSync
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CoordinatorList: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CoordinatorList: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Coordinators", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSync
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthSync
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthSync
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Coordinators = append(m.Coordinators, &CoordinatorList_Coordinator{})
			if err := m.Coordinators[len(m.Coordinators)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipSync(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthSync
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CoordinatorList_Coordinator) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowSync
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Coordinator: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Coordinator: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Endpoint", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSync
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthSync
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthSync
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Endpoint == nil {
				m.Endpoint = &Endpoint{}
			}
			if err := m.Endpoint.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IsMaster", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSync
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.IsMaster = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipSync(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthSync
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SourceInfo) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowSync
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SourceInfo: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SourceInfo: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IsCoordinator", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSync
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.IsCoordinator = bool(v != 0)
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IsConsenter", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSync
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.IsConsenter = bool(v != 0)
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MembershipVersion", wireType)
			}
			m.MembershipVersion = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSync
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MembershipVersion |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field BlockHeight", wireType)
			}
			m.BlockHeight = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSync
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.BlockHeight |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipSync(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthSync
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Heartbeat) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowSync
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Heartbeat: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Heartbeat: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MembershipVersion", wireType)
			}
			m.MembershipVersion = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSync
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MembershipVersion |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field BlockHeight", wireType)
			}
			m.BlockHeight = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSync
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.BlockHeight |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipSync(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthSync
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Handshake) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowSync
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Handshake: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Handshake: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TargetId", wireType)
			}
			m.TargetId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSync
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TargetId |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Membership", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSync
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthSync
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthSync
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Membership == nil {
				m.Membership = &Membership{}
			}
			if err := m.Membership.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipSync(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthSync
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *BlockSeq) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowSync
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: BlockSeq: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: BlockSeq: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Height", wireType)
			}
			m.Height = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSync
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Height |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Blocks", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSync
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthSync
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthSync
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Blocks = append(m.Blocks, &common.Block{})
			if err := m.Blocks[len(m.Blocks)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipSync(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthSync
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *BlockRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowSync
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: BlockRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: BlockRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Begin", wireType)
			}
			m.Begin = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSync
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Begin |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipSync(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthSync
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ProgressResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowSync
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ProgressResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ProgressResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Reject", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSync
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Reject = bool(v != 0)
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MatchHeight", wireType)
			}
			m.MatchHeight = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSync
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MatchHeight |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field LastHeight", wireType)
			}
			m.LastHeight = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSync
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.LastHeight |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipSync(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthSync
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Membership) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowSync
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Membership: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Membership: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Nodes", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSync
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthSync
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthSync
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Nodes = append(m.Nodes, &Node{})
			if err := m.Nodes[len(m.Nodes)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Version", wireType)
			}
			m.Version = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSync
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Version |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Master", wireType)
			}
			m.Master = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSync
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Master |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Self", wireType)
			}
			m.Self = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSync
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Self |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Linkers", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSync
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthSync
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthSync
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Linkers = append(m.Linkers, &Endpoint{})
			if err := m.Linkers[len(m.Linkers)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipSync(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthSync
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Node) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowSync
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Node: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Node: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			m.Id = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSync
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Id |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Endpoint", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSync
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthSync
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthSync
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Endpoint == nil {
				m.Endpoint = &Endpoint{}
			}
			if err := m.Endpoint.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType == 0 {
				var v int32
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowSync
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= int32(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.Upstream = append(m.Upstream, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowSync
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthSync
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLengthSync
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				var count int
				for _, integer := range dAtA[iNdEx:postIndex] {
					if integer < 128 {
						count++
					}
				}
				elementCount = count
				if elementCount != 0 && len(m.Upstream) == 0 {
					m.Upstream = make([]int32, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v int32
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowSync
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= int32(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.Upstream = append(m.Upstream, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field Upstream", wireType)
			}
		case 4:
			if wireType == 0 {
				var v int32
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowSync
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= int32(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.Downstream = append(m.Downstream, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowSync
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthSync
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLengthSync
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				var count int
				for _, integer := range dAtA[iNdEx:postIndex] {
					if integer < 128 {
						count++
					}
				}
				elementCount = count
				if elementCount != 0 && len(m.Downstream) == 0 {
					m.Downstream = make([]int32, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v int32
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowSync
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= int32(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.Downstream = append(m.Downstream, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field Downstream", wireType)
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field State", wireType)
			}
			m.State = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSync
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.State |= Node_State(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IsCoordinator", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSync
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.IsCoordinator = bool(v != 0)
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IsConsenter", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSync
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.IsConsenter = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipSync(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthSync
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *OpResult) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowSync
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: OpResult: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: OpResult: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Node", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSync
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthSync
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthSync
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &Node{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Res = &OpResult_Node{v}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Error", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSync
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthSync
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthSync
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Res = &OpResult_Error{string(dAtA[iNdEx:postIndex])}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipSync(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthSync
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *StreamNode) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowSync
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: StreamNode: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: StreamNode: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			m.Id = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSync
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Id |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Endpoint", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSync
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthSync
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthSync
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Endpoint == nil {
				m.Endpoint = &Endpoint{}
			}
			if err := m.Endpoint.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IsCoordinator", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSync
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.IsCoordinator = bool(v != 0)
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IsConsenter", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSync
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.IsConsenter = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipSync(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthSync
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MemberMap) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowSync
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MemberMap: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MemberMap: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field IdToNode", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSync
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthSync
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthSync
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.IdToNode == nil {
				m.IdToNode = make(map[int32]*Node)
			}
			var mapkey int32
			var mapvalue *Node
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowSync
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowSync
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapkey |= int32(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
				} else if fieldNum == 2 {
					var mapmsglen int
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowSync
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapmsglen |= int(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					if mapmsglen < 0 {
						return ErrInvalidLengthSync
					}
					postmsgIndex := iNdEx + mapmsglen
					if postmsgIndex < 0 {
						return ErrInvalidLengthSync
					}
					if postmsgIndex > l {
						return io.ErrUnexpectedEOF
					}
					mapvalue = &Node{}
					if err := mapvalue.Unmarshal(dAtA[iNdEx:postmsgIndex]); err != nil {
						return err
					}
					iNdEx = postmsgIndex
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipSync(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if (skippy < 0) || (iNdEx+skippy) < 0 {
						return ErrInvalidLengthSync
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.IdToNode[mapkey] = mapvalue
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field NameToNode", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSync
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthSync
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthSync
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.NameToNode == nil {
				m.NameToNode = make(map[string]*Node)
			}
			var mapkey string
			var mapvalue *Node
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowSync
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					var stringLenmapkey uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowSync
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapkey |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapkey := int(stringLenmapkey)
					if intStringLenmapkey < 0 {
						return ErrInvalidLengthSync
					}
					postStringIndexmapkey := iNdEx + intStringLenmapkey
					if postStringIndexmapkey < 0 {
						return ErrInvalidLengthSync
					}
					if postStringIndexmapkey > l {
						return io.ErrUnexpectedEOF
					}
					mapkey = string(dAtA[iNdEx:postStringIndexmapkey])
					iNdEx = postStringIndexmapkey
				} else if fieldNum == 2 {
					var mapmsglen int
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowSync
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapmsglen |= int(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					if mapmsglen < 0 {
						return ErrInvalidLengthSync
					}
					postmsgIndex := iNdEx + mapmsglen
					if postmsgIndex < 0 {
						return ErrInvalidLengthSync
					}
					if postmsgIndex > l {
						return io.ErrUnexpectedEOF
					}
					mapvalue = &Node{}
					if err := mapvalue.Unmarshal(dAtA[iNdEx:postmsgIndex]); err != nil {
						return err
					}
					iNdEx = postmsgIndex
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipSync(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if (skippy < 0) || (iNdEx+skippy) < 0 {
						return ErrInvalidLengthSync
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.NameToNode[mapkey] = mapvalue
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipSync(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthSync
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MemberDiff) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowSync
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MemberDiff: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MemberDiff: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AddNodes", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSync
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthSync
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthSync
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.AddNodes = append(m.AddNodes, &Node{})
			if err := m.AddNodes[len(m.AddNodes)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RemoveNodes", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSync
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthSync
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthSync
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.RemoveNodes = append(m.RemoveNodes, &Node{})
			if err := m.RemoveNodes[len(m.RemoveNodes)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field UpdateNodes", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSync
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthSync
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthSync
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.UpdateNodes = append(m.UpdateNodes, &Node{})
			if err := m.UpdateNodes[len(m.UpdateNodes)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field FromVersion", wireType)
			}
			m.FromVersion = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSync
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.FromVersion |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ToVersion", wireType)
			}
			m.ToVersion = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSync
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ToVersion |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Master", wireType)
			}
			m.Master = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSync
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Master |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Linkers", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSync
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthSync
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthSync
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Linkers = append(m.Linkers, &Endpoint{})
			if err := m.Linkers[len(m.Linkers)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipSync(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthSync
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Ack) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowSync
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Ack: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Ack: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field BlockHeight", wireType)
			}
			m.BlockHeight = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSync
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.BlockHeight |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipSync(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthSync
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Endpoint) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowSync
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Endpoint: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Endpoint: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Host", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSync
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthSync
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthSync
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Host = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RestPort", wireType)
			}
			m.RestPort = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSync
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.RestPort |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RpcPort", wireType)
			}
			m.RpcPort = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSync
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.RpcPort |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Version", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSync
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthSync
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthSync
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Version = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Addr", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSync
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthSync
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthSync
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Addr = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ReqPort", wireType)
			}
			m.ReqPort = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSync
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ReqPort |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipSync(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthSync
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Config) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowSync
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Config: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Config: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ChainId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSync
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthSync
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthSync
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ChainId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field NodeId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSync
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthSync
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthSync
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.NodeId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Endpoint", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSync
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthSync
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthSync
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Endpoint == nil {
				m.Endpoint = &Endpoint{}
			}
			if err := m.Endpoint.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Self", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSync
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthSync
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthSync
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Self == nil {
				m.Self = &Endpoint{}
			}
			if err := m.Self.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IsCoordinator", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSync
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.IsCoordinator = bool(v != 0)
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IsConsenter", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSync
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.IsConsenter = bool(v != 0)
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SeedNodes", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSync
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthSync
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthSync
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.SeedNodes = append(m.SeedNodes, &Endpoint{})
			if err := m.SeedNodes[len(m.SeedNodes)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field LinkerNodes", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSync
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthSync
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthSync
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.LinkerNodes = append(m.LinkerNodes, &Endpoint{})
			if err := m.LinkerNodes[len(m.LinkerNodes)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Zone", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSync
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthSync
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthSync
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Zone == nil {
				m.Zone = &common.Zone{}
			}
			if err := m.Zone.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 10:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Org", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSync
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthSync
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthSync
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Org == nil {
				m.Org = &Org{}
			}
			if err := m.Org.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 11:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RestTls", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSync
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.RestTls = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipSync(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthSync
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Org) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowSync
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Org: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Org: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSync
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthSync
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthSync
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Permission", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSync
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthSync
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthSync
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Permission = append(m.Permission[:0], dAtA[iNdEx:postIndex]...)
			if m.Permission == nil {
				m.Permission = []byte{}
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipSync(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthSync
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MemberChange) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowSync
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MemberChange: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MemberChange: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Add", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSync
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthSync
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthSync
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &StreamNode{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Op = &MemberChange_Add{v}
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RemoveCoordinator", wireType)
			}
			var v int32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSync
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Op = &MemberChange_RemoveCoordinator{v}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RemovePeer", wireType)
			}
			var v int32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSync
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Op = &MemberChange_RemovePeer{v}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ChangeMaster", wireType)
			}
			var v int32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSync
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Op = &MemberChange_ChangeMaster{v}
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AddLinker", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSync
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthSync
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthSync
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &Endpoint{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Op = &MemberChange_AddLinker{v}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipSync(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthSync
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipSync(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	depth := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowSync
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowSync
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
		case 1:
			iNdEx += 8
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowSync
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if length < 0 {
				return 0, ErrInvalidLengthSync
			}
			iNdEx += length
		case 3:
			depth++
		case 4:
			if depth == 0 {
				return 0, ErrUnexpectedEndOfGroupSync
			}
			depth--
		case 5:
			iNdEx += 4
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
		if iNdEx < 0 {
			return 0, ErrInvalidLengthSync
		}
		if depth == 0 {
			return iNdEx, nil
		}
	}
	return 0, io.ErrUnexpectedEOF
}

var (
	ErrInvalidLengthSync        = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowSync          = fmt.Errorf("proto: integer overflow")
	ErrUnexpectedEndOfGroupSync = fmt.Errorf("proto: unexpected end of group")
)
