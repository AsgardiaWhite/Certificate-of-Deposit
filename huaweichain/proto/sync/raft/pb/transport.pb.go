// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: sync/transport.proto

package pb

import (
	context "context"
	fmt "fmt"
	_ "github.com/gogo/protobuf/gogoproto"
	proto "github.com/gogo/protobuf/proto"
	grpc "google.golang.org/grpc"
	codes "google.golang.org/grpc/codes"
	status "google.golang.org/grpc/status"
	io "io"
	math "math"
	math_bits "math/bits"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.GoGoProtoPackageIsVersion3 // please upgrade the proto package

type Log_LogType int32

const (
	LOG_COMMAND                Log_LogType = 0
	LOG_NOOP                   Log_LogType = 1
	LOG_ADD_PEER_DEPRECATED    Log_LogType = 2
	LOG_REMOVE_PEER_DEPRECATED Log_LogType = 3
	LOG_BARRIER                Log_LogType = 4
	LOG_CONFIGURATION          Log_LogType = 5
)

var Log_LogType_name = map[int32]string{
	0: "LOG_COMMAND",
	1: "LOG_NOOP",
	2: "LOG_ADD_PEER_DEPRECATED",
	3: "LOG_REMOVE_PEER_DEPRECATED",
	4: "LOG_BARRIER",
	5: "LOG_CONFIGURATION",
}

var Log_LogType_value = map[string]int32{
	"LOG_COMMAND":                0,
	"LOG_NOOP":                   1,
	"LOG_ADD_PEER_DEPRECATED":    2,
	"LOG_REMOVE_PEER_DEPRECATED": 3,
	"LOG_BARRIER":                4,
	"LOG_CONFIGURATION":          5,
}

func (x Log_LogType) String() string {
	return proto.EnumName(Log_LogType_name, int32(x))
}

func (Log_LogType) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_17f97e1b1c2c4ed7, []int{1, 0}
}

type RPCHeader struct {
	ProtocolVersion int64  `protobuf:"varint,1,opt,name=protocol_version,json=protocolVersion,proto3" json:"protocol_version,omitempty"`
	GroupId         string `protobuf:"bytes,2,opt,name=group_id,json=groupId,proto3" json:"group_id,omitempty"`
}

func (m *RPCHeader) Reset()         { *m = RPCHeader{} }
func (m *RPCHeader) String() string { return proto.CompactTextString(m) }
func (*RPCHeader) ProtoMessage()    {}
func (*RPCHeader) Descriptor() ([]byte, []int) {
	return fileDescriptor_17f97e1b1c2c4ed7, []int{0}
}
func (m *RPCHeader) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *RPCHeader) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_RPCHeader.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *RPCHeader) XXX_Merge(src proto.Message) {
	xxx_messageInfo_RPCHeader.Merge(m, src)
}
func (m *RPCHeader) XXX_Size() int {
	return m.Size()
}
func (m *RPCHeader) XXX_DiscardUnknown() {
	xxx_messageInfo_RPCHeader.DiscardUnknown(m)
}

var xxx_messageInfo_RPCHeader proto.InternalMessageInfo

type Log struct {
	Index      uint64      `protobuf:"varint,1,opt,name=index,proto3" json:"index,omitempty"`
	Term       uint64      `protobuf:"varint,2,opt,name=term,proto3" json:"term,omitempty"`
	Type       Log_LogType `protobuf:"varint,3,opt,name=type,proto3,enum=sync.Log_LogType" json:"type,omitempty"`
	Data       []byte      `protobuf:"bytes,4,opt,name=data,proto3" json:"data,omitempty"`
	Extensions []byte      `protobuf:"bytes,5,opt,name=extensions,proto3" json:"extensions,omitempty"`
}

func (m *Log) Reset()         { *m = Log{} }
func (m *Log) String() string { return proto.CompactTextString(m) }
func (*Log) ProtoMessage()    {}
func (*Log) Descriptor() ([]byte, []int) {
	return fileDescriptor_17f97e1b1c2c4ed7, []int{1}
}
func (m *Log) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Log) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Log.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Log) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Log.Merge(m, src)
}
func (m *Log) XXX_Size() int {
	return m.Size()
}
func (m *Log) XXX_DiscardUnknown() {
	xxx_messageInfo_Log.DiscardUnknown(m)
}

var xxx_messageInfo_Log proto.InternalMessageInfo

type AppendEntriesRequest struct {
	RpcHeader         *RPCHeader `protobuf:"bytes,1,opt,name=rpc_header,json=rpcHeader,proto3" json:"rpc_header,omitempty"`
	Term              uint64     `protobuf:"varint,2,opt,name=term,proto3" json:"term,omitempty"`
	Leader            []byte     `protobuf:"bytes,3,opt,name=leader,proto3" json:"leader,omitempty"`
	PrevLogEntry      uint64     `protobuf:"varint,4,opt,name=prev_log_entry,json=prevLogEntry,proto3" json:"prev_log_entry,omitempty"`
	PrevLogTerm       uint64     `protobuf:"varint,5,opt,name=prev_log_term,json=prevLogTerm,proto3" json:"prev_log_term,omitempty"`
	Entries           []*Log     `protobuf:"bytes,6,rep,name=entries,proto3" json:"entries,omitempty"`
	LeaderCommitIndex uint64     `protobuf:"varint,7,opt,name=leader_commit_index,json=leaderCommitIndex,proto3" json:"leader_commit_index,omitempty"`
}

func (m *AppendEntriesRequest) Reset()         { *m = AppendEntriesRequest{} }
func (m *AppendEntriesRequest) String() string { return proto.CompactTextString(m) }
func (*AppendEntriesRequest) ProtoMessage()    {}
func (*AppendEntriesRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_17f97e1b1c2c4ed7, []int{2}
}
func (m *AppendEntriesRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *AppendEntriesRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_AppendEntriesRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *AppendEntriesRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_AppendEntriesRequest.Merge(m, src)
}
func (m *AppendEntriesRequest) XXX_Size() int {
	return m.Size()
}
func (m *AppendEntriesRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_AppendEntriesRequest.DiscardUnknown(m)
}

var xxx_messageInfo_AppendEntriesRequest proto.InternalMessageInfo

type AppendEntriesResponse struct {
	RpcHeader      *RPCHeader `protobuf:"bytes,1,opt,name=rpc_header,json=rpcHeader,proto3" json:"rpc_header,omitempty"`
	Term           uint64     `protobuf:"varint,2,opt,name=term,proto3" json:"term,omitempty"`
	LastLog        uint64     `protobuf:"varint,3,opt,name=last_log,json=lastLog,proto3" json:"last_log,omitempty"`
	Success        bool       `protobuf:"varint,4,opt,name=success,proto3" json:"success,omitempty"`
	NoRetryBackoff bool       `protobuf:"varint,5,opt,name=no_retry_backoff,json=noRetryBackoff,proto3" json:"no_retry_backoff,omitempty"`
}

func (m *AppendEntriesResponse) Reset()         { *m = AppendEntriesResponse{} }
func (m *AppendEntriesResponse) String() string { return proto.CompactTextString(m) }
func (*AppendEntriesResponse) ProtoMessage()    {}
func (*AppendEntriesResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_17f97e1b1c2c4ed7, []int{3}
}
func (m *AppendEntriesResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *AppendEntriesResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_AppendEntriesResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *AppendEntriesResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_AppendEntriesResponse.Merge(m, src)
}
func (m *AppendEntriesResponse) XXX_Size() int {
	return m.Size()
}
func (m *AppendEntriesResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_AppendEntriesResponse.DiscardUnknown(m)
}

var xxx_messageInfo_AppendEntriesResponse proto.InternalMessageInfo

type RequestVoteRequest struct {
	RpcHeader          *RPCHeader `protobuf:"bytes,1,opt,name=rpc_header,json=rpcHeader,proto3" json:"rpc_header,omitempty"`
	Term               uint64     `protobuf:"varint,2,opt,name=term,proto3" json:"term,omitempty"`
	Candidate          []byte     `protobuf:"bytes,3,opt,name=candidate,proto3" json:"candidate,omitempty"`
	LastLogIndex       uint64     `protobuf:"varint,4,opt,name=last_log_index,json=lastLogIndex,proto3" json:"last_log_index,omitempty"`
	LastLogTerm        uint64     `protobuf:"varint,5,opt,name=last_log_term,json=lastLogTerm,proto3" json:"last_log_term,omitempty"`
	LeadershipTransfer bool       `protobuf:"varint,6,opt,name=leadership_transfer,json=leadershipTransfer,proto3" json:"leadership_transfer,omitempty"`
}

func (m *RequestVoteRequest) Reset()         { *m = RequestVoteRequest{} }
func (m *RequestVoteRequest) String() string { return proto.CompactTextString(m) }
func (*RequestVoteRequest) ProtoMessage()    {}
func (*RequestVoteRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_17f97e1b1c2c4ed7, []int{4}
}
func (m *RequestVoteRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *RequestVoteRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_RequestVoteRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *RequestVoteRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_RequestVoteRequest.Merge(m, src)
}
func (m *RequestVoteRequest) XXX_Size() int {
	return m.Size()
}
func (m *RequestVoteRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_RequestVoteRequest.DiscardUnknown(m)
}

var xxx_messageInfo_RequestVoteRequest proto.InternalMessageInfo

type RequestVoteResponse struct {
	RpcHeader *RPCHeader `protobuf:"bytes,1,opt,name=rpc_header,json=rpcHeader,proto3" json:"rpc_header,omitempty"`
	Term      uint64     `protobuf:"varint,2,opt,name=term,proto3" json:"term,omitempty"`
	Peers     []byte     `protobuf:"bytes,3,opt,name=peers,proto3" json:"peers,omitempty"`
	Granted   bool       `protobuf:"varint,4,opt,name=granted,proto3" json:"granted,omitempty"`
}

func (m *RequestVoteResponse) Reset()         { *m = RequestVoteResponse{} }
func (m *RequestVoteResponse) String() string { return proto.CompactTextString(m) }
func (*RequestVoteResponse) ProtoMessage()    {}
func (*RequestVoteResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_17f97e1b1c2c4ed7, []int{5}
}
func (m *RequestVoteResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *RequestVoteResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_RequestVoteResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *RequestVoteResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_RequestVoteResponse.Merge(m, src)
}
func (m *RequestVoteResponse) XXX_Size() int {
	return m.Size()
}
func (m *RequestVoteResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_RequestVoteResponse.DiscardUnknown(m)
}

var xxx_messageInfo_RequestVoteResponse proto.InternalMessageInfo

type TimeoutNowRequest struct {
	RpcHeader *RPCHeader `protobuf:"bytes,1,opt,name=rpc_header,json=rpcHeader,proto3" json:"rpc_header,omitempty"`
}

func (m *TimeoutNowRequest) Reset()         { *m = TimeoutNowRequest{} }
func (m *TimeoutNowRequest) String() string { return proto.CompactTextString(m) }
func (*TimeoutNowRequest) ProtoMessage()    {}
func (*TimeoutNowRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_17f97e1b1c2c4ed7, []int{6}
}
func (m *TimeoutNowRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *TimeoutNowRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_TimeoutNowRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *TimeoutNowRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_TimeoutNowRequest.Merge(m, src)
}
func (m *TimeoutNowRequest) XXX_Size() int {
	return m.Size()
}
func (m *TimeoutNowRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_TimeoutNowRequest.DiscardUnknown(m)
}

var xxx_messageInfo_TimeoutNowRequest proto.InternalMessageInfo

type TimeoutNowResponse struct {
	RpcHeader *RPCHeader `protobuf:"bytes,1,opt,name=rpc_header,json=rpcHeader,proto3" json:"rpc_header,omitempty"`
}

func (m *TimeoutNowResponse) Reset()         { *m = TimeoutNowResponse{} }
func (m *TimeoutNowResponse) String() string { return proto.CompactTextString(m) }
func (*TimeoutNowResponse) ProtoMessage()    {}
func (*TimeoutNowResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_17f97e1b1c2c4ed7, []int{7}
}
func (m *TimeoutNowResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *TimeoutNowResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_TimeoutNowResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *TimeoutNowResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_TimeoutNowResponse.Merge(m, src)
}
func (m *TimeoutNowResponse) XXX_Size() int {
	return m.Size()
}
func (m *TimeoutNowResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_TimeoutNowResponse.DiscardUnknown(m)
}

var xxx_messageInfo_TimeoutNowResponse proto.InternalMessageInfo

// The first InstallSnapshotRequest on the stream contains all the metadata.
// All further messages contain only data.
type InstallSnapshotRequest struct {
	RpcHeader          *RPCHeader `protobuf:"bytes,1,opt,name=rpc_header,json=rpcHeader,proto3" json:"rpc_header,omitempty"`
	SnapshotVersion    int64      `protobuf:"varint,11,opt,name=snapshot_version,json=snapshotVersion,proto3" json:"snapshot_version,omitempty"`
	Term               uint64     `protobuf:"varint,2,opt,name=term,proto3" json:"term,omitempty"`
	Leader             []byte     `protobuf:"bytes,3,opt,name=leader,proto3" json:"leader,omitempty"`
	LastLogIndex       uint64     `protobuf:"varint,4,opt,name=last_log_index,json=lastLogIndex,proto3" json:"last_log_index,omitempty"`
	LastLogTerm        uint64     `protobuf:"varint,5,opt,name=last_log_term,json=lastLogTerm,proto3" json:"last_log_term,omitempty"`
	Peers              []byte     `protobuf:"bytes,6,opt,name=peers,proto3" json:"peers,omitempty"`
	Configuration      []byte     `protobuf:"bytes,7,opt,name=configuration,proto3" json:"configuration,omitempty"`
	ConfigurationIndex uint64     `protobuf:"varint,8,opt,name=configuration_index,json=configurationIndex,proto3" json:"configuration_index,omitempty"`
	Size_              int64      `protobuf:"varint,9,opt,name=size,proto3" json:"size,omitempty"`
	Data               []byte     `protobuf:"bytes,10,opt,name=data,proto3" json:"data,omitempty"`
}

func (m *InstallSnapshotRequest) Reset()         { *m = InstallSnapshotRequest{} }
func (m *InstallSnapshotRequest) String() string { return proto.CompactTextString(m) }
func (*InstallSnapshotRequest) ProtoMessage()    {}
func (*InstallSnapshotRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_17f97e1b1c2c4ed7, []int{8}
}
func (m *InstallSnapshotRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *InstallSnapshotRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_InstallSnapshotRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *InstallSnapshotRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_InstallSnapshotRequest.Merge(m, src)
}
func (m *InstallSnapshotRequest) XXX_Size() int {
	return m.Size()
}
func (m *InstallSnapshotRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_InstallSnapshotRequest.DiscardUnknown(m)
}

var xxx_messageInfo_InstallSnapshotRequest proto.InternalMessageInfo

type InstallSnapshotResponse struct {
	RpcHeader *RPCHeader `protobuf:"bytes,1,opt,name=rpc_header,json=rpcHeader,proto3" json:"rpc_header,omitempty"`
	Term      uint64     `protobuf:"varint,2,opt,name=term,proto3" json:"term,omitempty"`
	Success   bool       `protobuf:"varint,3,opt,name=success,proto3" json:"success,omitempty"`
}

func (m *InstallSnapshotResponse) Reset()         { *m = InstallSnapshotResponse{} }
func (m *InstallSnapshotResponse) String() string { return proto.CompactTextString(m) }
func (*InstallSnapshotResponse) ProtoMessage()    {}
func (*InstallSnapshotResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_17f97e1b1c2c4ed7, []int{9}
}
func (m *InstallSnapshotResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *InstallSnapshotResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_InstallSnapshotResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *InstallSnapshotResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_InstallSnapshotResponse.Merge(m, src)
}
func (m *InstallSnapshotResponse) XXX_Size() int {
	return m.Size()
}
func (m *InstallSnapshotResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_InstallSnapshotResponse.DiscardUnknown(m)
}

var xxx_messageInfo_InstallSnapshotResponse proto.InternalMessageInfo

func init() {
	proto.RegisterEnum("sync.Log_LogType", Log_LogType_name, Log_LogType_value)
	proto.RegisterType((*RPCHeader)(nil), "sync.RPCHeader")
	proto.RegisterType((*Log)(nil), "sync.Log")
	proto.RegisterType((*AppendEntriesRequest)(nil), "sync.AppendEntriesRequest")
	proto.RegisterType((*AppendEntriesResponse)(nil), "sync.AppendEntriesResponse")
	proto.RegisterType((*RequestVoteRequest)(nil), "sync.RequestVoteRequest")
	proto.RegisterType((*RequestVoteResponse)(nil), "sync.RequestVoteResponse")
	proto.RegisterType((*TimeoutNowRequest)(nil), "sync.TimeoutNowRequest")
	proto.RegisterType((*TimeoutNowResponse)(nil), "sync.TimeoutNowResponse")
	proto.RegisterType((*InstallSnapshotRequest)(nil), "sync.InstallSnapshotRequest")
	proto.RegisterType((*InstallSnapshotResponse)(nil), "sync.InstallSnapshotResponse")
}

func init() { proto.RegisterFile("sync/transport.proto", fileDescriptor_17f97e1b1c2c4ed7) }

var fileDescriptor_17f97e1b1c2c4ed7 = []byte{
	// 958 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xac, 0x56, 0xcb, 0x6e, 0x22, 0x47,
	0x14, 0xa5, 0xcd, 0xfb, 0xe2, 0x07, 0xae, 0x61, 0xc6, 0x6d, 0x66, 0xd2, 0x42, 0x9d, 0x89, 0xc4,
	0x6c, 0x20, 0x72, 0x96, 0x59, 0x61, 0x20, 0x13, 0x22, 0x1b, 0x48, 0x85, 0x78, 0x11, 0x29, 0x6a,
	0xb5, 0x9b, 0xa2, 0x69, 0x05, 0xba, 0x3a, 0x55, 0xc5, 0x78, 0xc8, 0x1f, 0x64, 0x11, 0x69, 0xb2,
	0xcd, 0xa7, 0xe4, 0x0b, 0x66, 0xe9, 0x65, 0x96, 0x19, 0xfb, 0x0b, 0xf2, 0x03, 0x51, 0x54, 0xd5,
	0xdd, 0x3c, 0x0c, 0x59, 0xc4, 0x61, 0x81, 0xd4, 0xf7, 0x9c, 0xaa, 0x5b, 0x75, 0xcf, 0xa9, 0xba,
	0x05, 0x94, 0xf8, 0xdc, 0x77, 0xea, 0x82, 0xd9, 0x3e, 0x0f, 0x28, 0x13, 0xb5, 0x80, 0x51, 0x41,
	0x51, 0x4a, 0xa2, 0xe5, 0x92, 0x4b, 0x5d, 0xaa, 0x80, 0xba, 0xfc, 0x0a, 0x39, 0xf3, 0x6b, 0xc8,
	0xe3, 0x7e, 0xf3, 0x4b, 0x62, 0x0f, 0x09, 0x43, 0xaf, 0xa0, 0xa8, 0x50, 0x87, 0x4e, 0xac, 0x37,
	0x84, 0x71, 0x8f, 0xfa, 0xba, 0x56, 0xd1, 0xaa, 0x49, 0x7c, 0x14, 0xe3, 0x57, 0x21, 0x8c, 0x4e,
	0x21, 0xe7, 0x32, 0x3a, 0x0b, 0x2c, 0x6f, 0xa8, 0xef, 0x55, 0xb4, 0x6a, 0x1e, 0x67, 0x55, 0xdc,
	0x19, 0x9a, 0xbf, 0xed, 0x41, 0xf2, 0x82, 0xba, 0xa8, 0x04, 0x69, 0xcf, 0x1f, 0x92, 0xb7, 0x2a,
	0x45, 0x0a, 0x87, 0x01, 0x42, 0x90, 0x12, 0x84, 0x4d, 0xd5, 0xa4, 0x14, 0x56, 0xdf, 0xe8, 0x13,
	0x48, 0x89, 0x79, 0x40, 0xf4, 0x64, 0x45, 0xab, 0x1e, 0x9e, 0x1d, 0xd7, 0xe4, 0x7e, 0x6b, 0x17,
	0xd4, 0x95, 0xbf, 0xc1, 0x3c, 0x20, 0x58, 0xd1, 0x72, 0xea, 0xd0, 0x16, 0xb6, 0x9e, 0xaa, 0x68,
	0xd5, 0x7d, 0xac, 0xbe, 0x91, 0x01, 0x40, 0xde, 0x0a, 0xe2, 0xcb, 0x4d, 0x71, 0x3d, 0xad, 0x98,
	0x15, 0xc4, 0xfc, 0x45, 0x83, 0x6c, 0x94, 0x05, 0x1d, 0x41, 0xe1, 0xa2, 0xf7, 0xda, 0x6a, 0xf6,
	0x2e, 0x2f, 0x1b, 0xdd, 0x56, 0x31, 0x81, 0xf6, 0x21, 0x27, 0x81, 0x6e, 0xaf, 0xd7, 0x2f, 0x6a,
	0xe8, 0x39, 0x9c, 0xc8, 0xa8, 0xd1, 0x6a, 0x59, 0xfd, 0x76, 0x1b, 0x5b, 0xad, 0x76, 0x1f, 0xb7,
	0x9b, 0x8d, 0x41, 0xbb, 0x55, 0xdc, 0x43, 0x06, 0x94, 0x25, 0x89, 0xdb, 0x97, 0xbd, 0xab, 0xf6,
	0x06, 0x9f, 0x8c, 0x73, 0x9f, 0x37, 0x30, 0xee, 0xb4, 0x71, 0x31, 0x85, 0x9e, 0xc2, 0x71, 0xb8,
	0x58, 0xf7, 0x8b, 0xce, 0xeb, 0x6f, 0x71, 0x63, 0xd0, 0xe9, 0x75, 0x8b, 0x69, 0xf3, 0xd7, 0x3d,
	0x28, 0x35, 0x82, 0x80, 0xf8, 0xc3, 0xb6, 0x2f, 0x98, 0x47, 0x38, 0x26, 0x3f, 0xce, 0x08, 0x17,
	0xa8, 0x06, 0xc0, 0x02, 0xc7, 0x1a, 0x2b, 0x27, 0x94, 0x64, 0x85, 0xb3, 0xa3, 0x50, 0x89, 0x85,
	0x41, 0x38, 0xcf, 0x02, 0x27, 0xf2, 0x6a, 0x9b, 0x8e, 0xcf, 0x20, 0x33, 0x09, 0xe7, 0x27, 0x95,
	0x10, 0x51, 0x84, 0x5e, 0xc2, 0x61, 0xc0, 0xc8, 0x1b, 0x6b, 0x42, 0x5d, 0x8b, 0xf8, 0x82, 0xcd,
	0x95, 0x84, 0x29, 0xbc, 0x2f, 0xd1, 0x0b, 0xea, 0xca, 0xad, 0xcc, 0x91, 0x09, 0x07, 0x8b, 0x51,
	0x2a, 0x75, 0x5a, 0x0d, 0x2a, 0x44, 0x83, 0x06, 0x72, 0x85, 0x8f, 0x21, 0x4b, 0xc2, 0x7d, 0xeb,
	0x99, 0x4a, 0xb2, 0x5a, 0x38, 0xcb, 0x2f, 0xcc, 0xc2, 0x31, 0x83, 0x6a, 0xf0, 0x24, 0x5c, 0xd8,
	0x72, 0xe8, 0x74, 0xea, 0x09, 0x2b, 0x3c, 0x06, 0x59, 0x95, 0xee, 0x38, 0xa4, 0x9a, 0x8a, 0xe9,
	0x48, 0xc2, 0xfc, 0x5d, 0x83, 0xa7, 0x0f, 0x34, 0xe1, 0x01, 0xf5, 0x39, 0xd9, 0x89, 0x28, 0xa7,
	0x90, 0x9b, 0xd8, 0x5c, 0xc8, 0xb2, 0x94, 0x2c, 0x29, 0x9c, 0x95, 0xb1, 0x3c, 0xa1, 0x3a, 0x64,
	0xf9, 0xcc, 0x71, 0x08, 0xe7, 0x4a, 0x90, 0x1c, 0x8e, 0x43, 0x54, 0x85, 0xa2, 0x4f, 0x2d, 0x46,
	0x04, 0x9b, 0x5b, 0xd7, 0xb6, 0xf3, 0x03, 0x1d, 0x8d, 0x94, 0x1c, 0x39, 0x7c, 0xe8, 0x53, 0x2c,
	0xe1, 0xf3, 0x10, 0x35, 0xff, 0xd2, 0x00, 0x45, 0x1e, 0x5e, 0x51, 0x41, 0x76, 0x69, 0xe7, 0x0b,
	0xc8, 0x3b, 0xb6, 0x3f, 0xf4, 0x86, 0xb6, 0x20, 0x91, 0xa3, 0x4b, 0x40, 0x9a, 0x1a, 0xd7, 0x15,
	0x09, 0x1c, 0x99, 0x1a, 0x55, 0xa7, 0xb4, 0x95, 0xa6, 0x2e, 0x46, 0xad, 0x9a, 0x1a, 0x0d, 0x52,
	0xa6, 0xd6, 0x63, 0xbf, 0xf8, 0xd8, 0x0b, 0x2c, 0xd5, 0x3d, 0x46, 0x84, 0xe9, 0x19, 0x55, 0x2f,
	0x5a, 0x52, 0x83, 0x88, 0x31, 0x7f, 0xd6, 0xe0, 0xc9, 0x5a, 0xcd, 0x3b, 0xb4, 0xab, 0x04, 0xe9,
	0x80, 0x10, 0xc6, 0xa3, 0x82, 0xc3, 0x40, 0x3a, 0xe5, 0x32, 0xdb, 0x17, 0x64, 0x18, 0x3b, 0x15,
	0x85, 0x66, 0x13, 0x8e, 0x07, 0xde, 0x94, 0xd0, 0x99, 0xe8, 0xd2, 0x9b, 0x47, 0xaa, 0x6f, 0xb6,
	0x00, 0xad, 0x26, 0x79, 0x5c, 0x39, 0xe6, 0xdf, 0x7b, 0xf0, 0xac, 0xe3, 0x73, 0x61, 0x4f, 0x26,
	0xdf, 0xf8, 0x76, 0xc0, 0xc7, 0x54, 0x3c, 0xf6, 0x38, 0xbc, 0x82, 0x22, 0x8f, 0x52, 0x2c, 0x3a,
	0x71, 0x21, 0xec, 0xc4, 0x31, 0x1e, 0x77, 0xe2, 0xff, 0xd8, 0x08, 0x76, 0x74, 0x66, 0x16, 0x36,
	0x65, 0x56, 0x6d, 0x7a, 0x09, 0x07, 0x0e, 0xf5, 0x47, 0x9e, 0x3b, 0x63, 0xb6, 0x90, 0x7b, 0xce,
	0x2a, 0x76, 0x1d, 0x94, 0xe7, 0x6d, 0x0d, 0x88, 0xb6, 0x92, 0x53, 0xab, 0xa0, 0x35, 0xaa, 0x13,
	0xbf, 0x19, 0xdc, 0xfb, 0x89, 0xe8, 0x79, 0xa5, 0x80, 0xfa, 0x5e, 0x3c, 0x06, 0xb0, 0x7c, 0x0c,
	0xcc, 0x1b, 0x38, 0xd9, 0xd0, 0x7f, 0x87, 0x47, 0x73, 0xa5, 0x5d, 0x24, 0xd7, 0xda, 0xc5, 0xd9,
	0xbb, 0x24, 0x1c, 0x60, 0x7b, 0x24, 0x06, 0xf1, 0xcb, 0x8b, 0xae, 0x1e, 0xb4, 0xb4, 0xbe, 0x17,
	0x90, 0x89, 0xe7, 0x13, 0x54, 0x0e, 0x17, 0xdd, 0xf6, 0x06, 0x94, 0x9f, 0x6f, 0xe5, 0xc2, 0x0a,
	0xcc, 0x44, 0x55, 0xfb, 0x54, 0x43, 0x5f, 0xc1, 0xc1, 0x1a, 0xfd, 0x3f, 0xf2, 0xa1, 0x16, 0x14,
	0x56, 0x6e, 0x31, 0xd2, 0x23, 0x39, 0x36, 0x9a, 0x59, 0xf9, 0x74, 0x0b, 0xb3, 0xc8, 0xd2, 0x00,
	0x58, 0xde, 0x1d, 0x74, 0x12, 0x0e, 0xdd, 0xb8, 0x92, 0x65, 0x7d, 0x93, 0x58, 0xa4, 0xc0, 0x70,
	0xf4, 0xc0, 0x37, 0xf4, 0x22, 0x1c, 0xbe, 0xfd, 0x3a, 0x95, 0x3f, 0xfa, 0x17, 0x76, 0x29, 0xd5,
	0xf9, 0xf7, 0xef, 0x3f, 0x18, 0x89, 0xdb, 0x0f, 0x46, 0xe2, 0xfd, 0x9d, 0xa1, 0xdd, 0xde, 0x19,
	0xda, 0x9f, 0x77, 0x86, 0xf6, 0xee, 0xde, 0x48, 0xdc, 0xde, 0x1b, 0x89, 0x3f, 0xee, 0x8d, 0xc4,
	0x77, 0x9f, 0xbb, 0x9e, 0xa8, 0x8d, 0x67, 0xf6, 0x0d, 0xf1, 0x6a, 0x0e, 0x9d, 0xd6, 0x03, 0xea,
	0x71, 0x2e, 0xe7, 0xdb, 0xcc, 0x19, 0xd7, 0x6f, 0x3c, 0xe2, 0x13, 0xe6, 0x8c, 0x6d, 0xcf, 0xaf,
	0x87, 0xff, 0x9a, 0xd4, 0x7f, 0x2b, 0x66, 0x8f, 0x44, 0x3d, 0xb8, 0xbe, 0xce, 0x28, 0xec, 0xb3,
	0x7f, 0x02, 0x00, 0x00, 0xff, 0xff, 0xa3, 0x83, 0x54, 0x85, 0x72, 0x09, 0x00, 0x00,
}

// Reference imports to suppress errors if they are not otherwise used.
var _ context.Context
var _ grpc.ClientConn

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
const _ = grpc.SupportPackageIsVersion4

// RaftTransportClient is the client API for RaftTransport service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://godoc.org/google.golang.org/grpc#ClientConn.NewStream.
type RaftTransportClient interface {
	// AppendEntriesPipeline opens an AppendEntries message stream.
	AppendEntriesPipeline(ctx context.Context, opts ...grpc.CallOption) (RaftTransport_AppendEntriesPipelineClient, error)
	// AppendEntries performs a single append entries request / response.
	AppendEntries(ctx context.Context, in *AppendEntriesRequest, opts ...grpc.CallOption) (*AppendEntriesResponse, error)
	// RequestVote is the command used by a candidate to ask a Raft peer for a vote in an election.
	RequestVote(ctx context.Context, in *RequestVoteRequest, opts ...grpc.CallOption) (*RequestVoteResponse, error)
	// TimeoutNow is used to start a leadership transfer to the target node.
	TimeoutNow(ctx context.Context, in *TimeoutNowRequest, opts ...grpc.CallOption) (*TimeoutNowResponse, error)
	// InstallSnapshot is the command sent to a Raft peer to bootstrap its log (and state machine) from a snapshot on another peer.
	InstallSnapshot(ctx context.Context, opts ...grpc.CallOption) (RaftTransport_InstallSnapshotClient, error)
}

type raftTransportClient struct {
	cc *grpc.ClientConn
}

func NewRaftTransportClient(cc *grpc.ClientConn) RaftTransportClient {
	return &raftTransportClient{cc}
}

func (c *raftTransportClient) AppendEntriesPipeline(ctx context.Context, opts ...grpc.CallOption) (RaftTransport_AppendEntriesPipelineClient, error) {
	stream, err := c.cc.NewStream(ctx, &_RaftTransport_serviceDesc.Streams[0], "/sync.RaftTransport/AppendEntriesPipeline", opts...)
	if err != nil {
		return nil, err
	}
	x := &raftTransportAppendEntriesPipelineClient{stream}
	return x, nil
}

type RaftTransport_AppendEntriesPipelineClient interface {
	Send(*AppendEntriesRequest) error
	Recv() (*AppendEntriesResponse, error)
	grpc.ClientStream
}

type raftTransportAppendEntriesPipelineClient struct {
	grpc.ClientStream
}

func (x *raftTransportAppendEntriesPipelineClient) Send(m *AppendEntriesRequest) error {
	return x.ClientStream.SendMsg(m)
}

func (x *raftTransportAppendEntriesPipelineClient) Recv() (*AppendEntriesResponse, error) {
	m := new(AppendEntriesResponse)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *raftTransportClient) AppendEntries(ctx context.Context, in *AppendEntriesRequest, opts ...grpc.CallOption) (*AppendEntriesResponse, error) {
	out := new(AppendEntriesResponse)
	err := c.cc.Invoke(ctx, "/sync.RaftTransport/AppendEntries", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *raftTransportClient) RequestVote(ctx context.Context, in *RequestVoteRequest, opts ...grpc.CallOption) (*RequestVoteResponse, error) {
	out := new(RequestVoteResponse)
	err := c.cc.Invoke(ctx, "/sync.RaftTransport/RequestVote", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *raftTransportClient) TimeoutNow(ctx context.Context, in *TimeoutNowRequest, opts ...grpc.CallOption) (*TimeoutNowResponse, error) {
	out := new(TimeoutNowResponse)
	err := c.cc.Invoke(ctx, "/sync.RaftTransport/TimeoutNow", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *raftTransportClient) InstallSnapshot(ctx context.Context, opts ...grpc.CallOption) (RaftTransport_InstallSnapshotClient, error) {
	stream, err := c.cc.NewStream(ctx, &_RaftTransport_serviceDesc.Streams[1], "/sync.RaftTransport/InstallSnapshot", opts...)
	if err != nil {
		return nil, err
	}
	x := &raftTransportInstallSnapshotClient{stream}
	return x, nil
}

type RaftTransport_InstallSnapshotClient interface {
	Send(*InstallSnapshotRequest) error
	CloseAndRecv() (*InstallSnapshotResponse, error)
	grpc.ClientStream
}

type raftTransportInstallSnapshotClient struct {
	grpc.ClientStream
}

func (x *raftTransportInstallSnapshotClient) Send(m *InstallSnapshotRequest) error {
	return x.ClientStream.SendMsg(m)
}

func (x *raftTransportInstallSnapshotClient) CloseAndRecv() (*InstallSnapshotResponse, error) {
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	m := new(InstallSnapshotResponse)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

// RaftTransportServer is the server API for RaftTransport service.
type RaftTransportServer interface {
	// AppendEntriesPipeline opens an AppendEntries message stream.
	AppendEntriesPipeline(RaftTransport_AppendEntriesPipelineServer) error
	// AppendEntries performs a single append entries request / response.
	AppendEntries(context.Context, *AppendEntriesRequest) (*AppendEntriesResponse, error)
	// RequestVote is the command used by a candidate to ask a Raft peer for a vote in an election.
	RequestVote(context.Context, *RequestVoteRequest) (*RequestVoteResponse, error)
	// TimeoutNow is used to start a leadership transfer to the target node.
	TimeoutNow(context.Context, *TimeoutNowRequest) (*TimeoutNowResponse, error)
	// InstallSnapshot is the command sent to a Raft peer to bootstrap its log (and state machine) from a snapshot on another peer.
	InstallSnapshot(RaftTransport_InstallSnapshotServer) error
}

// UnimplementedRaftTransportServer can be embedded to have forward compatible implementations.
type UnimplementedRaftTransportServer struct {
}

func (*UnimplementedRaftTransportServer) AppendEntriesPipeline(srv RaftTransport_AppendEntriesPipelineServer) error {
	return status.Errorf(codes.Unimplemented, "method AppendEntriesPipeline not implemented")
}
func (*UnimplementedRaftTransportServer) AppendEntries(ctx context.Context, req *AppendEntriesRequest) (*AppendEntriesResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method AppendEntries not implemented")
}
func (*UnimplementedRaftTransportServer) RequestVote(ctx context.Context, req *RequestVoteRequest) (*RequestVoteResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method RequestVote not implemented")
}
func (*UnimplementedRaftTransportServer) TimeoutNow(ctx context.Context, req *TimeoutNowRequest) (*TimeoutNowResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method TimeoutNow not implemented")
}
func (*UnimplementedRaftTransportServer) InstallSnapshot(srv RaftTransport_InstallSnapshotServer) error {
	return status.Errorf(codes.Unimplemented, "method InstallSnapshot not implemented")
}

func RegisterRaftTransportServer(s *grpc.Server, srv RaftTransportServer) {
	s.RegisterService(&_RaftTransport_serviceDesc, srv)
}

func _RaftTransport_AppendEntriesPipeline_Handler(srv interface{}, stream grpc.ServerStream) error {
	return srv.(RaftTransportServer).AppendEntriesPipeline(&raftTransportAppendEntriesPipelineServer{stream})
}

type RaftTransport_AppendEntriesPipelineServer interface {
	Send(*AppendEntriesResponse) error
	Recv() (*AppendEntriesRequest, error)
	grpc.ServerStream
}

type raftTransportAppendEntriesPipelineServer struct {
	grpc.ServerStream
}

func (x *raftTransportAppendEntriesPipelineServer) Send(m *AppendEntriesResponse) error {
	return x.ServerStream.SendMsg(m)
}

func (x *raftTransportAppendEntriesPipelineServer) Recv() (*AppendEntriesRequest, error) {
	m := new(AppendEntriesRequest)
	if err := x.ServerStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func _RaftTransport_AppendEntries_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(AppendEntriesRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(RaftTransportServer).AppendEntries(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/sync.RaftTransport/AppendEntries",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(RaftTransportServer).AppendEntries(ctx, req.(*AppendEntriesRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _RaftTransport_RequestVote_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(RequestVoteRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(RaftTransportServer).RequestVote(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/sync.RaftTransport/RequestVote",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(RaftTransportServer).RequestVote(ctx, req.(*RequestVoteRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _RaftTransport_TimeoutNow_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(TimeoutNowRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(RaftTransportServer).TimeoutNow(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/sync.RaftTransport/TimeoutNow",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(RaftTransportServer).TimeoutNow(ctx, req.(*TimeoutNowRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _RaftTransport_InstallSnapshot_Handler(srv interface{}, stream grpc.ServerStream) error {
	return srv.(RaftTransportServer).InstallSnapshot(&raftTransportInstallSnapshotServer{stream})
}

type RaftTransport_InstallSnapshotServer interface {
	SendAndClose(*InstallSnapshotResponse) error
	Recv() (*InstallSnapshotRequest, error)
	grpc.ServerStream
}

type raftTransportInstallSnapshotServer struct {
	grpc.ServerStream
}

func (x *raftTransportInstallSnapshotServer) SendAndClose(m *InstallSnapshotResponse) error {
	return x.ServerStream.SendMsg(m)
}

func (x *raftTransportInstallSnapshotServer) Recv() (*InstallSnapshotRequest, error) {
	m := new(InstallSnapshotRequest)
	if err := x.ServerStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

var _RaftTransport_serviceDesc = grpc.ServiceDesc{
	ServiceName: "sync.RaftTransport",
	HandlerType: (*RaftTransportServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "AppendEntries",
			Handler:    _RaftTransport_AppendEntries_Handler,
		},
		{
			MethodName: "RequestVote",
			Handler:    _RaftTransport_RequestVote_Handler,
		},
		{
			MethodName: "TimeoutNow",
			Handler:    _RaftTransport_TimeoutNow_Handler,
		},
	},
	Streams: []grpc.StreamDesc{
		{
			StreamName:    "AppendEntriesPipeline",
			Handler:       _RaftTransport_AppendEntriesPipeline_Handler,
			ServerStreams: true,
			ClientStreams: true,
		},
		{
			StreamName:    "InstallSnapshot",
			Handler:       _RaftTransport_InstallSnapshot_Handler,
			ClientStreams: true,
		},
	},
	Metadata: "sync/transport.proto",
}

func (m *RPCHeader) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *RPCHeader) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *RPCHeader) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.GroupId) > 0 {
		i -= len(m.GroupId)
		copy(dAtA[i:], m.GroupId)
		i = encodeVarintTransport(dAtA, i, uint64(len(m.GroupId)))
		i--
		dAtA[i] = 0x12
	}
	if m.ProtocolVersion != 0 {
		i = encodeVarintTransport(dAtA, i, uint64(m.ProtocolVersion))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *Log) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Log) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Log) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Extensions) > 0 {
		i -= len(m.Extensions)
		copy(dAtA[i:], m.Extensions)
		i = encodeVarintTransport(dAtA, i, uint64(len(m.Extensions)))
		i--
		dAtA[i] = 0x2a
	}
	if len(m.Data) > 0 {
		i -= len(m.Data)
		copy(dAtA[i:], m.Data)
		i = encodeVarintTransport(dAtA, i, uint64(len(m.Data)))
		i--
		dAtA[i] = 0x22
	}
	if m.Type != 0 {
		i = encodeVarintTransport(dAtA, i, uint64(m.Type))
		i--
		dAtA[i] = 0x18
	}
	if m.Term != 0 {
		i = encodeVarintTransport(dAtA, i, uint64(m.Term))
		i--
		dAtA[i] = 0x10
	}
	if m.Index != 0 {
		i = encodeVarintTransport(dAtA, i, uint64(m.Index))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *AppendEntriesRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *AppendEntriesRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *AppendEntriesRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.LeaderCommitIndex != 0 {
		i = encodeVarintTransport(dAtA, i, uint64(m.LeaderCommitIndex))
		i--
		dAtA[i] = 0x38
	}
	if len(m.Entries) > 0 {
		for iNdEx := len(m.Entries) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Entries[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintTransport(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x32
		}
	}
	if m.PrevLogTerm != 0 {
		i = encodeVarintTransport(dAtA, i, uint64(m.PrevLogTerm))
		i--
		dAtA[i] = 0x28
	}
	if m.PrevLogEntry != 0 {
		i = encodeVarintTransport(dAtA, i, uint64(m.PrevLogEntry))
		i--
		dAtA[i] = 0x20
	}
	if len(m.Leader) > 0 {
		i -= len(m.Leader)
		copy(dAtA[i:], m.Leader)
		i = encodeVarintTransport(dAtA, i, uint64(len(m.Leader)))
		i--
		dAtA[i] = 0x1a
	}
	if m.Term != 0 {
		i = encodeVarintTransport(dAtA, i, uint64(m.Term))
		i--
		dAtA[i] = 0x10
	}
	if m.RpcHeader != nil {
		{
			size, err := m.RpcHeader.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTransport(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *AppendEntriesResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *AppendEntriesResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *AppendEntriesResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.NoRetryBackoff {
		i--
		if m.NoRetryBackoff {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x28
	}
	if m.Success {
		i--
		if m.Success {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x20
	}
	if m.LastLog != 0 {
		i = encodeVarintTransport(dAtA, i, uint64(m.LastLog))
		i--
		dAtA[i] = 0x18
	}
	if m.Term != 0 {
		i = encodeVarintTransport(dAtA, i, uint64(m.Term))
		i--
		dAtA[i] = 0x10
	}
	if m.RpcHeader != nil {
		{
			size, err := m.RpcHeader.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTransport(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *RequestVoteRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *RequestVoteRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *RequestVoteRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.LeadershipTransfer {
		i--
		if m.LeadershipTransfer {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x30
	}
	if m.LastLogTerm != 0 {
		i = encodeVarintTransport(dAtA, i, uint64(m.LastLogTerm))
		i--
		dAtA[i] = 0x28
	}
	if m.LastLogIndex != 0 {
		i = encodeVarintTransport(dAtA, i, uint64(m.LastLogIndex))
		i--
		dAtA[i] = 0x20
	}
	if len(m.Candidate) > 0 {
		i -= len(m.Candidate)
		copy(dAtA[i:], m.Candidate)
		i = encodeVarintTransport(dAtA, i, uint64(len(m.Candidate)))
		i--
		dAtA[i] = 0x1a
	}
	if m.Term != 0 {
		i = encodeVarintTransport(dAtA, i, uint64(m.Term))
		i--
		dAtA[i] = 0x10
	}
	if m.RpcHeader != nil {
		{
			size, err := m.RpcHeader.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTransport(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *RequestVoteResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *RequestVoteResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *RequestVoteResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Granted {
		i--
		if m.Granted {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x20
	}
	if len(m.Peers) > 0 {
		i -= len(m.Peers)
		copy(dAtA[i:], m.Peers)
		i = encodeVarintTransport(dAtA, i, uint64(len(m.Peers)))
		i--
		dAtA[i] = 0x1a
	}
	if m.Term != 0 {
		i = encodeVarintTransport(dAtA, i, uint64(m.Term))
		i--
		dAtA[i] = 0x10
	}
	if m.RpcHeader != nil {
		{
			size, err := m.RpcHeader.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTransport(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *TimeoutNowRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *TimeoutNowRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *TimeoutNowRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.RpcHeader != nil {
		{
			size, err := m.RpcHeader.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTransport(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *TimeoutNowResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *TimeoutNowResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *TimeoutNowResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.RpcHeader != nil {
		{
			size, err := m.RpcHeader.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTransport(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *InstallSnapshotRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *InstallSnapshotRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *InstallSnapshotRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.SnapshotVersion != 0 {
		i = encodeVarintTransport(dAtA, i, uint64(m.SnapshotVersion))
		i--
		dAtA[i] = 0x58
	}
	if len(m.Data) > 0 {
		i -= len(m.Data)
		copy(dAtA[i:], m.Data)
		i = encodeVarintTransport(dAtA, i, uint64(len(m.Data)))
		i--
		dAtA[i] = 0x52
	}
	if m.Size_ != 0 {
		i = encodeVarintTransport(dAtA, i, uint64(m.Size_))
		i--
		dAtA[i] = 0x48
	}
	if m.ConfigurationIndex != 0 {
		i = encodeVarintTransport(dAtA, i, uint64(m.ConfigurationIndex))
		i--
		dAtA[i] = 0x40
	}
	if len(m.Configuration) > 0 {
		i -= len(m.Configuration)
		copy(dAtA[i:], m.Configuration)
		i = encodeVarintTransport(dAtA, i, uint64(len(m.Configuration)))
		i--
		dAtA[i] = 0x3a
	}
	if len(m.Peers) > 0 {
		i -= len(m.Peers)
		copy(dAtA[i:], m.Peers)
		i = encodeVarintTransport(dAtA, i, uint64(len(m.Peers)))
		i--
		dAtA[i] = 0x32
	}
	if m.LastLogTerm != 0 {
		i = encodeVarintTransport(dAtA, i, uint64(m.LastLogTerm))
		i--
		dAtA[i] = 0x28
	}
	if m.LastLogIndex != 0 {
		i = encodeVarintTransport(dAtA, i, uint64(m.LastLogIndex))
		i--
		dAtA[i] = 0x20
	}
	if len(m.Leader) > 0 {
		i -= len(m.Leader)
		copy(dAtA[i:], m.Leader)
		i = encodeVarintTransport(dAtA, i, uint64(len(m.Leader)))
		i--
		dAtA[i] = 0x1a
	}
	if m.Term != 0 {
		i = encodeVarintTransport(dAtA, i, uint64(m.Term))
		i--
		dAtA[i] = 0x10
	}
	if m.RpcHeader != nil {
		{
			size, err := m.RpcHeader.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTransport(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *InstallSnapshotResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *InstallSnapshotResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *InstallSnapshotResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Success {
		i--
		if m.Success {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x18
	}
	if m.Term != 0 {
		i = encodeVarintTransport(dAtA, i, uint64(m.Term))
		i--
		dAtA[i] = 0x10
	}
	if m.RpcHeader != nil {
		{
			size, err := m.RpcHeader.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTransport(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func encodeVarintTransport(dAtA []byte, offset int, v uint64) int {
	offset -= sovTransport(v)
	base := offset
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return base
}
func (m *RPCHeader) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.ProtocolVersion != 0 {
		n += 1 + sovTransport(uint64(m.ProtocolVersion))
	}
	l = len(m.GroupId)
	if l > 0 {
		n += 1 + l + sovTransport(uint64(l))
	}
	return n
}

func (m *Log) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Index != 0 {
		n += 1 + sovTransport(uint64(m.Index))
	}
	if m.Term != 0 {
		n += 1 + sovTransport(uint64(m.Term))
	}
	if m.Type != 0 {
		n += 1 + sovTransport(uint64(m.Type))
	}
	l = len(m.Data)
	if l > 0 {
		n += 1 + l + sovTransport(uint64(l))
	}
	l = len(m.Extensions)
	if l > 0 {
		n += 1 + l + sovTransport(uint64(l))
	}
	return n
}

func (m *AppendEntriesRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.RpcHeader != nil {
		l = m.RpcHeader.Size()
		n += 1 + l + sovTransport(uint64(l))
	}
	if m.Term != 0 {
		n += 1 + sovTransport(uint64(m.Term))
	}
	l = len(m.Leader)
	if l > 0 {
		n += 1 + l + sovTransport(uint64(l))
	}
	if m.PrevLogEntry != 0 {
		n += 1 + sovTransport(uint64(m.PrevLogEntry))
	}
	if m.PrevLogTerm != 0 {
		n += 1 + sovTransport(uint64(m.PrevLogTerm))
	}
	if len(m.Entries) > 0 {
		for _, e := range m.Entries {
			l = e.Size()
			n += 1 + l + sovTransport(uint64(l))
		}
	}
	if m.LeaderCommitIndex != 0 {
		n += 1 + sovTransport(uint64(m.LeaderCommitIndex))
	}
	return n
}

func (m *AppendEntriesResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.RpcHeader != nil {
		l = m.RpcHeader.Size()
		n += 1 + l + sovTransport(uint64(l))
	}
	if m.Term != 0 {
		n += 1 + sovTransport(uint64(m.Term))
	}
	if m.LastLog != 0 {
		n += 1 + sovTransport(uint64(m.LastLog))
	}
	if m.Success {
		n += 2
	}
	if m.NoRetryBackoff {
		n += 2
	}
	return n
}

func (m *RequestVoteRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.RpcHeader != nil {
		l = m.RpcHeader.Size()
		n += 1 + l + sovTransport(uint64(l))
	}
	if m.Term != 0 {
		n += 1 + sovTransport(uint64(m.Term))
	}
	l = len(m.Candidate)
	if l > 0 {
		n += 1 + l + sovTransport(uint64(l))
	}
	if m.LastLogIndex != 0 {
		n += 1 + sovTransport(uint64(m.LastLogIndex))
	}
	if m.LastLogTerm != 0 {
		n += 1 + sovTransport(uint64(m.LastLogTerm))
	}
	if m.LeadershipTransfer {
		n += 2
	}
	return n
}

func (m *RequestVoteResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.RpcHeader != nil {
		l = m.RpcHeader.Size()
		n += 1 + l + sovTransport(uint64(l))
	}
	if m.Term != 0 {
		n += 1 + sovTransport(uint64(m.Term))
	}
	l = len(m.Peers)
	if l > 0 {
		n += 1 + l + sovTransport(uint64(l))
	}
	if m.Granted {
		n += 2
	}
	return n
}

func (m *TimeoutNowRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.RpcHeader != nil {
		l = m.RpcHeader.Size()
		n += 1 + l + sovTransport(uint64(l))
	}
	return n
}

func (m *TimeoutNowResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.RpcHeader != nil {
		l = m.RpcHeader.Size()
		n += 1 + l + sovTransport(uint64(l))
	}
	return n
}

func (m *InstallSnapshotRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.RpcHeader != nil {
		l = m.RpcHeader.Size()
		n += 1 + l + sovTransport(uint64(l))
	}
	if m.Term != 0 {
		n += 1 + sovTransport(uint64(m.Term))
	}
	l = len(m.Leader)
	if l > 0 {
		n += 1 + l + sovTransport(uint64(l))
	}
	if m.LastLogIndex != 0 {
		n += 1 + sovTransport(uint64(m.LastLogIndex))
	}
	if m.LastLogTerm != 0 {
		n += 1 + sovTransport(uint64(m.LastLogTerm))
	}
	l = len(m.Peers)
	if l > 0 {
		n += 1 + l + sovTransport(uint64(l))
	}
	l = len(m.Configuration)
	if l > 0 {
		n += 1 + l + sovTransport(uint64(l))
	}
	if m.ConfigurationIndex != 0 {
		n += 1 + sovTransport(uint64(m.ConfigurationIndex))
	}
	if m.Size_ != 0 {
		n += 1 + sovTransport(uint64(m.Size_))
	}
	l = len(m.Data)
	if l > 0 {
		n += 1 + l + sovTransport(uint64(l))
	}
	if m.SnapshotVersion != 0 {
		n += 1 + sovTransport(uint64(m.SnapshotVersion))
	}
	return n
}

func (m *InstallSnapshotResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.RpcHeader != nil {
		l = m.RpcHeader.Size()
		n += 1 + l + sovTransport(uint64(l))
	}
	if m.Term != 0 {
		n += 1 + sovTransport(uint64(m.Term))
	}
	if m.Success {
		n += 2
	}
	return n
}

func sovTransport(x uint64) (n int) {
	return (math_bits.Len64(x|1) + 6) / 7
}
func sozTransport(x uint64) (n int) {
	return sovTransport(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (m *RPCHeader) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTransport
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: RPCHeader: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: RPCHeader: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ProtocolVersion", wireType)
			}
			m.ProtocolVersion = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTransport
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ProtocolVersion |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field GroupId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTransport
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTransport
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTransport
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.GroupId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTransport(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTransport
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Log) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTransport
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Log: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Log: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Index", wireType)
			}
			m.Index = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTransport
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Index |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Term", wireType)
			}
			m.Term = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTransport
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Term |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Type", wireType)
			}
			m.Type = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTransport
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Type |= Log_LogType(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Data", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTransport
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthTransport
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthTransport
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Data = append(m.Data[:0], dAtA[iNdEx:postIndex]...)
			if m.Data == nil {
				m.Data = []byte{}
			}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Extensions", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTransport
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthTransport
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthTransport
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Extensions = append(m.Extensions[:0], dAtA[iNdEx:postIndex]...)
			if m.Extensions == nil {
				m.Extensions = []byte{}
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTransport(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTransport
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *AppendEntriesRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTransport
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: AppendEntriesRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: AppendEntriesRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RpcHeader", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTransport
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTransport
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTransport
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.RpcHeader == nil {
				m.RpcHeader = &RPCHeader{}
			}
			if err := m.RpcHeader.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Term", wireType)
			}
			m.Term = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTransport
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Term |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Leader", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTransport
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthTransport
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthTransport
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Leader = append(m.Leader[:0], dAtA[iNdEx:postIndex]...)
			if m.Leader == nil {
				m.Leader = []byte{}
			}
			iNdEx = postIndex
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field PrevLogEntry", wireType)
			}
			m.PrevLogEntry = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTransport
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.PrevLogEntry |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field PrevLogTerm", wireType)
			}
			m.PrevLogTerm = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTransport
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.PrevLogTerm |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Entries", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTransport
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTransport
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTransport
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Entries = append(m.Entries, &Log{})
			if err := m.Entries[len(m.Entries)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field LeaderCommitIndex", wireType)
			}
			m.LeaderCommitIndex = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTransport
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.LeaderCommitIndex |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipTransport(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTransport
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *AppendEntriesResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTransport
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: AppendEntriesResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: AppendEntriesResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RpcHeader", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTransport
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTransport
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTransport
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.RpcHeader == nil {
				m.RpcHeader = &RPCHeader{}
			}
			if err := m.RpcHeader.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Term", wireType)
			}
			m.Term = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTransport
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Term |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field LastLog", wireType)
			}
			m.LastLog = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTransport
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.LastLog |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Success", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTransport
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Success = bool(v != 0)
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field NoRetryBackoff", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTransport
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.NoRetryBackoff = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipTransport(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTransport
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *RequestVoteRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTransport
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: RequestVoteRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: RequestVoteRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RpcHeader", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTransport
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTransport
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTransport
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.RpcHeader == nil {
				m.RpcHeader = &RPCHeader{}
			}
			if err := m.RpcHeader.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Term", wireType)
			}
			m.Term = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTransport
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Term |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Candidate", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTransport
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthTransport
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthTransport
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Candidate = append(m.Candidate[:0], dAtA[iNdEx:postIndex]...)
			if m.Candidate == nil {
				m.Candidate = []byte{}
			}
			iNdEx = postIndex
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field LastLogIndex", wireType)
			}
			m.LastLogIndex = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTransport
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.LastLogIndex |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field LastLogTerm", wireType)
			}
			m.LastLogTerm = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTransport
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.LastLogTerm |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field LeadershipTransfer", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTransport
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.LeadershipTransfer = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipTransport(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTransport
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *RequestVoteResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTransport
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: RequestVoteResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: RequestVoteResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RpcHeader", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTransport
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTransport
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTransport
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.RpcHeader == nil {
				m.RpcHeader = &RPCHeader{}
			}
			if err := m.RpcHeader.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Term", wireType)
			}
			m.Term = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTransport
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Term |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Peers", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTransport
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthTransport
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthTransport
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Peers = append(m.Peers[:0], dAtA[iNdEx:postIndex]...)
			if m.Peers == nil {
				m.Peers = []byte{}
			}
			iNdEx = postIndex
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Granted", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTransport
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Granted = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipTransport(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTransport
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *TimeoutNowRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTransport
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: TimeoutNowRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: TimeoutNowRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RpcHeader", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTransport
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTransport
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTransport
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.RpcHeader == nil {
				m.RpcHeader = &RPCHeader{}
			}
			if err := m.RpcHeader.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTransport(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTransport
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *TimeoutNowResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTransport
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: TimeoutNowResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: TimeoutNowResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RpcHeader", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTransport
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTransport
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTransport
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.RpcHeader == nil {
				m.RpcHeader = &RPCHeader{}
			}
			if err := m.RpcHeader.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTransport(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTransport
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *InstallSnapshotRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTransport
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: InstallSnapshotRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: InstallSnapshotRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RpcHeader", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTransport
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTransport
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTransport
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.RpcHeader == nil {
				m.RpcHeader = &RPCHeader{}
			}
			if err := m.RpcHeader.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Term", wireType)
			}
			m.Term = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTransport
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Term |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Leader", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTransport
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthTransport
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthTransport
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Leader = append(m.Leader[:0], dAtA[iNdEx:postIndex]...)
			if m.Leader == nil {
				m.Leader = []byte{}
			}
			iNdEx = postIndex
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field LastLogIndex", wireType)
			}
			m.LastLogIndex = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTransport
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.LastLogIndex |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field LastLogTerm", wireType)
			}
			m.LastLogTerm = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTransport
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.LastLogTerm |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Peers", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTransport
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthTransport
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthTransport
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Peers = append(m.Peers[:0], dAtA[iNdEx:postIndex]...)
			if m.Peers == nil {
				m.Peers = []byte{}
			}
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Configuration", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTransport
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthTransport
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthTransport
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Configuration = append(m.Configuration[:0], dAtA[iNdEx:postIndex]...)
			if m.Configuration == nil {
				m.Configuration = []byte{}
			}
			iNdEx = postIndex
		case 8:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ConfigurationIndex", wireType)
			}
			m.ConfigurationIndex = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTransport
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ConfigurationIndex |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 9:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Size_", wireType)
			}
			m.Size_ = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTransport
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Size_ |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 10:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Data", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTransport
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthTransport
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthTransport
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Data = append(m.Data[:0], dAtA[iNdEx:postIndex]...)
			if m.Data == nil {
				m.Data = []byte{}
			}
			iNdEx = postIndex
		case 11:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SnapshotVersion", wireType)
			}
			m.SnapshotVersion = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTransport
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.SnapshotVersion |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipTransport(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTransport
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *InstallSnapshotResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTransport
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: InstallSnapshotResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: InstallSnapshotResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RpcHeader", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTransport
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTransport
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTransport
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.RpcHeader == nil {
				m.RpcHeader = &RPCHeader{}
			}
			if err := m.RpcHeader.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Term", wireType)
			}
			m.Term = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTransport
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Term |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Success", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTransport
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Success = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipTransport(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTransport
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipTransport(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	depth := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowTransport
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowTransport
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
		case 1:
			iNdEx += 8
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowTransport
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if length < 0 {
				return 0, ErrInvalidLengthTransport
			}
			iNdEx += length
		case 3:
			depth++
		case 4:
			if depth == 0 {
				return 0, ErrUnexpectedEndOfGroupTransport
			}
			depth--
		case 5:
			iNdEx += 4
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
		if iNdEx < 0 {
			return 0, ErrInvalidLengthTransport
		}
		if depth == 0 {
			return iNdEx, nil
		}
	}
	return 0, io.ErrUnexpectedEOF
}

var (
	ErrInvalidLengthTransport        = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowTransport          = fmt.Errorf("proto: integer overflow")
	ErrUnexpectedEndOfGroupTransport = fmt.Errorf("proto: unexpected end of group")
)
