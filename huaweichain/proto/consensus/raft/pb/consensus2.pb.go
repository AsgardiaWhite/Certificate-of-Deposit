// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: consensus/raft/consensus2.proto

package pb

import (
	fmt "fmt"
	common "git.huawei.com/huaweichain/proto/common"
	cons "git.huawei.com/huaweichain/proto/consensus/cons"
	_ "github.com/gogo/protobuf/gogoproto"
	proto "github.com/gogo/protobuf/proto"
	io "io"
	math "math"
	math_bits "math/bits"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.GoGoProtoPackageIsVersion3 // please upgrade the proto package

type NodeType int32

const (
	CONSENTER NodeType = 0
	VALIDATOR NodeType = 1
)

var NodeType_name = map[int32]string{
	0: "CONSENTER",
	1: "VALIDATOR",
}

var NodeType_value = map[string]int32{
	"CONSENTER": 0,
	"VALIDATOR": 1,
}

func (x NodeType) String() string {
	return proto.EnumName(NodeType_name, int32(x))
}

func (NodeType) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_b5e2274d09c819e4, []int{0}
}

type Cons struct {
	ChainId string `protobuf:"bytes,1,opt,name=chainId,proto3" json:"chainId,omitempty"`
	From    string `protobuf:"bytes,2,opt,name=from,proto3" json:"from,omitempty"`
	To      string `protobuf:"bytes,3,opt,name=to,proto3" json:"to,omitempty"`
	// Types that are valid to be assigned to Type:
	//	*Cons_Raft
	//	*Cons_Tx
	//	*Cons_Conn
	//	*Cons_Hotstuff
	//	*Cons_Sync
	Type isCons_Type `protobuf_oneof:"type"`
}

func (m *Cons) Reset()         { *m = Cons{} }
func (m *Cons) String() string { return proto.CompactTextString(m) }
func (*Cons) ProtoMessage()    {}
func (*Cons) Descriptor() ([]byte, []int) {
	return fileDescriptor_b5e2274d09c819e4, []int{0}
}
func (m *Cons) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Cons) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Cons.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Cons) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Cons.Merge(m, src)
}
func (m *Cons) XXX_Size() int {
	return m.Size()
}
func (m *Cons) XXX_DiscardUnknown() {
	xxx_messageInfo_Cons.DiscardUnknown(m)
}

var xxx_messageInfo_Cons proto.InternalMessageInfo

type isCons_Type interface {
	isCons_Type()
	MarshalTo([]byte) (int, error)
	Size() int
}

type Cons_Raft struct {
	Raft *Raft `protobuf:"bytes,4,opt,name=raft,proto3,oneof" json:"raft,omitempty"`
}
type Cons_Tx struct {
	Tx *Tx `protobuf:"bytes,5,opt,name=tx,proto3,oneof" json:"tx,omitempty"`
}
type Cons_Conn struct {
	Conn *Connection `protobuf:"bytes,6,opt,name=conn,proto3,oneof" json:"conn,omitempty"`
}
type Cons_Hotstuff struct {
	Hotstuff *cons.Hotstuff `protobuf:"bytes,7,opt,name=hotstuff,proto3,oneof" json:"hotstuff,omitempty"`
}
type Cons_Sync struct {
	Sync *BlockSync `protobuf:"bytes,8,opt,name=sync,proto3,oneof" json:"sync,omitempty"`
}

func (*Cons_Raft) isCons_Type()     {}
func (*Cons_Tx) isCons_Type()       {}
func (*Cons_Conn) isCons_Type()     {}
func (*Cons_Hotstuff) isCons_Type() {}
func (*Cons_Sync) isCons_Type()     {}

func (m *Cons) GetType() isCons_Type {
	if m != nil {
		return m.Type
	}
	return nil
}

func (m *Cons) GetRaft() *Raft {
	if x, ok := m.GetType().(*Cons_Raft); ok {
		return x.Raft
	}
	return nil
}

func (m *Cons) GetTx() *Tx {
	if x, ok := m.GetType().(*Cons_Tx); ok {
		return x.Tx
	}
	return nil
}

func (m *Cons) GetConn() *Connection {
	if x, ok := m.GetType().(*Cons_Conn); ok {
		return x.Conn
	}
	return nil
}

func (m *Cons) GetHotstuff() *cons.Hotstuff {
	if x, ok := m.GetType().(*Cons_Hotstuff); ok {
		return x.Hotstuff
	}
	return nil
}

func (m *Cons) GetSync() *BlockSync {
	if x, ok := m.GetType().(*Cons_Sync); ok {
		return x.Sync
	}
	return nil
}

// XXX_OneofWrappers is for the internal use of the proto package.
func (*Cons) XXX_OneofWrappers() []interface{} {
	return []interface{}{
		(*Cons_Raft)(nil),
		(*Cons_Tx)(nil),
		(*Cons_Conn)(nil),
		(*Cons_Hotstuff)(nil),
		(*Cons_Sync)(nil),
	}
}

type Tx struct {
	RootHash []byte `protobuf:"bytes,1,opt,name=root_hash,json=rootHash,proto3" json:"root_hash,omitempty"`
	TxList   []byte `protobuf:"bytes,2,opt,name=tx_list,json=txList,proto3" json:"tx_list,omitempty"`
	IsConfig bool   `protobuf:"varint,3,opt,name=isConfig,proto3" json:"isConfig,omitempty"`
}

func (m *Tx) Reset()         { *m = Tx{} }
func (m *Tx) String() string { return proto.CompactTextString(m) }
func (*Tx) ProtoMessage()    {}
func (*Tx) Descriptor() ([]byte, []int) {
	return fileDescriptor_b5e2274d09c819e4, []int{1}
}
func (m *Tx) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Tx) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Tx.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Tx) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Tx.Merge(m, src)
}
func (m *Tx) XXX_Size() int {
	return m.Size()
}
func (m *Tx) XXX_DiscardUnknown() {
	xxx_messageInfo_Tx.DiscardUnknown(m)
}

var xxx_messageInfo_Tx proto.InternalMessageInfo

type Raft struct {
	Cert           *Certificate    `protobuf:"bytes,1,opt,name=cert,proto3" json:"cert,omitempty"`
	Blocks         []*common.Block `protobuf:"bytes,2,rep,name=blocks,proto3" json:"blocks,omitempty"`
	IsForwardBlock bool            `protobuf:"varint,3,opt,name=isForwardBlock,proto3" json:"isForwardBlock,omitempty"`
}

func (m *Raft) Reset()         { *m = Raft{} }
func (m *Raft) String() string { return proto.CompactTextString(m) }
func (*Raft) ProtoMessage()    {}
func (*Raft) Descriptor() ([]byte, []int) {
	return fileDescriptor_b5e2274d09c819e4, []int{2}
}
func (m *Raft) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Raft) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Raft.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Raft) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Raft.Merge(m, src)
}
func (m *Raft) XXX_Size() int {
	return m.Size()
}
func (m *Raft) XXX_DiscardUnknown() {
	xxx_messageInfo_Raft.DiscardUnknown(m)
}

var xxx_messageInfo_Raft proto.InternalMessageInfo

type Connection struct {
	Id       string   `protobuf:"bytes,1,opt,name=id,proto3" json:"id,omitempty"`
	State    uint32   `protobuf:"varint,2,opt,name=state,proto3" json:"state,omitempty"`
	NodeType NodeType `protobuf:"varint,3,opt,name=node_type,json=nodeType,proto3,enum=consensus2.NodeType" json:"node_type,omitempty"`
}

func (m *Connection) Reset()         { *m = Connection{} }
func (m *Connection) String() string { return proto.CompactTextString(m) }
func (*Connection) ProtoMessage()    {}
func (*Connection) Descriptor() ([]byte, []int) {
	return fileDescriptor_b5e2274d09c819e4, []int{3}
}
func (m *Connection) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Connection) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Connection.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Connection) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Connection.Merge(m, src)
}
func (m *Connection) XXX_Size() int {
	return m.Size()
}
func (m *Connection) XXX_DiscardUnknown() {
	xxx_messageInfo_Connection.DiscardUnknown(m)
}

var xxx_messageInfo_Connection proto.InternalMessageInfo

type BlockSync struct {
	// Types that are valid to be assigned to Payload:
	//	*BlockSync_Req
	//	*BlockSync_Res
	Payload isBlockSync_Payload `protobuf_oneof:"payload"`
}

func (m *BlockSync) Reset()         { *m = BlockSync{} }
func (m *BlockSync) String() string { return proto.CompactTextString(m) }
func (*BlockSync) ProtoMessage()    {}
func (*BlockSync) Descriptor() ([]byte, []int) {
	return fileDescriptor_b5e2274d09c819e4, []int{4}
}
func (m *BlockSync) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *BlockSync) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_BlockSync.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *BlockSync) XXX_Merge(src proto.Message) {
	xxx_messageInfo_BlockSync.Merge(m, src)
}
func (m *BlockSync) XXX_Size() int {
	return m.Size()
}
func (m *BlockSync) XXX_DiscardUnknown() {
	xxx_messageInfo_BlockSync.DiscardUnknown(m)
}

var xxx_messageInfo_BlockSync proto.InternalMessageInfo

type isBlockSync_Payload interface {
	isBlockSync_Payload()
	MarshalTo([]byte) (int, error)
	Size() int
}

type BlockSync_Req struct {
	Req *BlockSync_BlockRequest `protobuf:"bytes,1,opt,name=req,proto3,oneof" json:"req,omitempty"`
}
type BlockSync_Res struct {
	Res *BlockSeq `protobuf:"bytes,2,opt,name=res,proto3,oneof" json:"res,omitempty"`
}

func (*BlockSync_Req) isBlockSync_Payload() {}
func (*BlockSync_Res) isBlockSync_Payload() {}

func (m *BlockSync) GetPayload() isBlockSync_Payload {
	if m != nil {
		return m.Payload
	}
	return nil
}

func (m *BlockSync) GetReq() *BlockSync_BlockRequest {
	if x, ok := m.GetPayload().(*BlockSync_Req); ok {
		return x.Req
	}
	return nil
}

func (m *BlockSync) GetRes() *BlockSeq {
	if x, ok := m.GetPayload().(*BlockSync_Res); ok {
		return x.Res
	}
	return nil
}

// XXX_OneofWrappers is for the internal use of the proto package.
func (*BlockSync) XXX_OneofWrappers() []interface{} {
	return []interface{}{
		(*BlockSync_Req)(nil),
		(*BlockSync_Res)(nil),
	}
}

type BlockSync_BlockRequest struct {
	Begin  uint64 `protobuf:"varint,1,opt,name=begin,proto3" json:"begin,omitempty"`
	Length int32  `protobuf:"varint,2,opt,name=length,proto3" json:"length,omitempty"`
}

func (m *BlockSync_BlockRequest) Reset()         { *m = BlockSync_BlockRequest{} }
func (m *BlockSync_BlockRequest) String() string { return proto.CompactTextString(m) }
func (*BlockSync_BlockRequest) ProtoMessage()    {}
func (*BlockSync_BlockRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_b5e2274d09c819e4, []int{4, 0}
}
func (m *BlockSync_BlockRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *BlockSync_BlockRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_BlockSync_BlockRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *BlockSync_BlockRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_BlockSync_BlockRequest.Merge(m, src)
}
func (m *BlockSync_BlockRequest) XXX_Size() int {
	return m.Size()
}
func (m *BlockSync_BlockRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_BlockSync_BlockRequest.DiscardUnknown(m)
}

var xxx_messageInfo_BlockSync_BlockRequest proto.InternalMessageInfo

type BlockSeq struct {
	Blocks []*common.Block `protobuf:"bytes,1,rep,name=blocks,proto3" json:"blocks,omitempty"`
}

func (m *BlockSeq) Reset()         { *m = BlockSeq{} }
func (m *BlockSeq) String() string { return proto.CompactTextString(m) }
func (*BlockSeq) ProtoMessage()    {}
func (*BlockSeq) Descriptor() ([]byte, []int) {
	return fileDescriptor_b5e2274d09c819e4, []int{5}
}
func (m *BlockSeq) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *BlockSeq) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_BlockSeq.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *BlockSeq) XXX_Merge(src proto.Message) {
	xxx_messageInfo_BlockSeq.Merge(m, src)
}
func (m *BlockSeq) XXX_Size() int {
	return m.Size()
}
func (m *BlockSeq) XXX_DiscardUnknown() {
	xxx_messageInfo_BlockSeq.DiscardUnknown(m)
}

var xxx_messageInfo_BlockSeq proto.InternalMessageInfo

type SyncResult struct {
	// Types that are valid to be assigned to Res:
	//	*SyncResult_Success_
	//	*SyncResult_Failed_
	//	*SyncResult_Exception_
	Res isSyncResult_Res `protobuf_oneof:"res"`
}

func (m *SyncResult) Reset()         { *m = SyncResult{} }
func (m *SyncResult) String() string { return proto.CompactTextString(m) }
func (*SyncResult) ProtoMessage()    {}
func (*SyncResult) Descriptor() ([]byte, []int) {
	return fileDescriptor_b5e2274d09c819e4, []int{6}
}
func (m *SyncResult) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *SyncResult) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_SyncResult.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *SyncResult) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SyncResult.Merge(m, src)
}
func (m *SyncResult) XXX_Size() int {
	return m.Size()
}
func (m *SyncResult) XXX_DiscardUnknown() {
	xxx_messageInfo_SyncResult.DiscardUnknown(m)
}

var xxx_messageInfo_SyncResult proto.InternalMessageInfo

type isSyncResult_Res interface {
	isSyncResult_Res()
	MarshalTo([]byte) (int, error)
	Size() int
}

type SyncResult_Success_ struct {
	Success *SyncResult_Success `protobuf:"bytes,1,opt,name=success,proto3,oneof" json:"success,omitempty"`
}
type SyncResult_Failed_ struct {
	Failed *SyncResult_Failed `protobuf:"bytes,2,opt,name=failed,proto3,oneof" json:"failed,omitempty"`
}
type SyncResult_Exception_ struct {
	Exception *SyncResult_Exception `protobuf:"bytes,3,opt,name=exception,proto3,oneof" json:"exception,omitempty"`
}

func (*SyncResult_Success_) isSyncResult_Res()   {}
func (*SyncResult_Failed_) isSyncResult_Res()    {}
func (*SyncResult_Exception_) isSyncResult_Res() {}

func (m *SyncResult) GetRes() isSyncResult_Res {
	if m != nil {
		return m.Res
	}
	return nil
}

func (m *SyncResult) GetSuccess() *SyncResult_Success {
	if x, ok := m.GetRes().(*SyncResult_Success_); ok {
		return x.Success
	}
	return nil
}

func (m *SyncResult) GetFailed() *SyncResult_Failed {
	if x, ok := m.GetRes().(*SyncResult_Failed_); ok {
		return x.Failed
	}
	return nil
}

func (m *SyncResult) GetException() *SyncResult_Exception {
	if x, ok := m.GetRes().(*SyncResult_Exception_); ok {
		return x.Exception
	}
	return nil
}

// XXX_OneofWrappers is for the internal use of the proto package.
func (*SyncResult) XXX_OneofWrappers() []interface{} {
	return []interface{}{
		(*SyncResult_Success_)(nil),
		(*SyncResult_Failed_)(nil),
		(*SyncResult_Exception_)(nil),
	}
}

type SyncResult_Success struct {
	BlockNum uint64 `protobuf:"varint,1,opt,name=block_num,json=blockNum,proto3" json:"block_num,omitempty"`
}

func (m *SyncResult_Success) Reset()         { *m = SyncResult_Success{} }
func (m *SyncResult_Success) String() string { return proto.CompactTextString(m) }
func (*SyncResult_Success) ProtoMessage()    {}
func (*SyncResult_Success) Descriptor() ([]byte, []int) {
	return fileDescriptor_b5e2274d09c819e4, []int{6, 0}
}
func (m *SyncResult_Success) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *SyncResult_Success) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_SyncResult_Success.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *SyncResult_Success) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SyncResult_Success.Merge(m, src)
}
func (m *SyncResult_Success) XXX_Size() int {
	return m.Size()
}
func (m *SyncResult_Success) XXX_DiscardUnknown() {
	xxx_messageInfo_SyncResult_Success.DiscardUnknown(m)
}

var xxx_messageInfo_SyncResult_Success proto.InternalMessageInfo

type SyncResult_Failed struct {
	Cause string `protobuf:"bytes,1,opt,name=cause,proto3" json:"cause,omitempty"`
}

func (m *SyncResult_Failed) Reset()         { *m = SyncResult_Failed{} }
func (m *SyncResult_Failed) String() string { return proto.CompactTextString(m) }
func (*SyncResult_Failed) ProtoMessage()    {}
func (*SyncResult_Failed) Descriptor() ([]byte, []int) {
	return fileDescriptor_b5e2274d09c819e4, []int{6, 1}
}
func (m *SyncResult_Failed) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *SyncResult_Failed) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_SyncResult_Failed.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *SyncResult_Failed) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SyncResult_Failed.Merge(m, src)
}
func (m *SyncResult_Failed) XXX_Size() int {
	return m.Size()
}
func (m *SyncResult_Failed) XXX_DiscardUnknown() {
	xxx_messageInfo_SyncResult_Failed.DiscardUnknown(m)
}

var xxx_messageInfo_SyncResult_Failed proto.InternalMessageInfo

type SyncResult_Exception struct {
	Msg string `protobuf:"bytes,1,opt,name=msg,proto3" json:"msg,omitempty"`
}

func (m *SyncResult_Exception) Reset()         { *m = SyncResult_Exception{} }
func (m *SyncResult_Exception) String() string { return proto.CompactTextString(m) }
func (*SyncResult_Exception) ProtoMessage()    {}
func (*SyncResult_Exception) Descriptor() ([]byte, []int) {
	return fileDescriptor_b5e2274d09c819e4, []int{6, 2}
}
func (m *SyncResult_Exception) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *SyncResult_Exception) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_SyncResult_Exception.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *SyncResult_Exception) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SyncResult_Exception.Merge(m, src)
}
func (m *SyncResult_Exception) XXX_Size() int {
	return m.Size()
}
func (m *SyncResult_Exception) XXX_DiscardUnknown() {
	xxx_messageInfo_SyncResult_Exception.DiscardUnknown(m)
}

var xxx_messageInfo_SyncResult_Exception proto.InternalMessageInfo

func init() {
	proto.RegisterEnum("consensus2.NodeType", NodeType_name, NodeType_value)
	proto.RegisterType((*Cons)(nil), "consensus2.Cons")
	proto.RegisterType((*Tx)(nil), "consensus2.Tx")
	proto.RegisterType((*Raft)(nil), "consensus2.Raft")
	proto.RegisterType((*Connection)(nil), "consensus2.Connection")
	proto.RegisterType((*BlockSync)(nil), "consensus2.BlockSync")
	proto.RegisterType((*BlockSync_BlockRequest)(nil), "consensus2.BlockSync.BlockRequest")
	proto.RegisterType((*BlockSeq)(nil), "consensus2.BlockSeq")
	proto.RegisterType((*SyncResult)(nil), "consensus2.SyncResult")
	proto.RegisterType((*SyncResult_Success)(nil), "consensus2.SyncResult.Success")
	proto.RegisterType((*SyncResult_Failed)(nil), "consensus2.SyncResult.Failed")
	proto.RegisterType((*SyncResult_Exception)(nil), "consensus2.SyncResult.Exception")
}

func init() { proto.RegisterFile("consensus/raft/consensus2.proto", fileDescriptor_b5e2274d09c819e4) }

var fileDescriptor_b5e2274d09c819e4 = []byte{
	// 796 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0x7c, 0x54, 0xd1, 0x6a, 0xe3, 0x46,
	0x14, 0x95, 0x14, 0xc5, 0x96, 0xaf, 0x93, 0x90, 0x4e, 0xd3, 0xad, 0x50, 0x59, 0xd5, 0x18, 0x36,
	0x98, 0xb6, 0xc8, 0xc4, 0x85, 0x16, 0x4a, 0x1f, 0x76, 0xed, 0x66, 0xd1, 0xc2, 0x92, 0x85, 0x89,
	0xd9, 0x87, 0xbe, 0x18, 0x59, 0x1e, 0x59, 0x43, 0xed, 0x19, 0x47, 0x33, 0x22, 0x36, 0xf4, 0x23,
	0xfa, 0x11, 0xfd, 0x81, 0xbe, 0xf4, 0x1b, 0xf6, 0x31, 0x8f, 0x7d, 0xec, 0x26, 0x3f, 0x52, 0x66,
	0x34, 0xb6, 0xd5, 0xd0, 0xf4, 0x45, 0xcc, 0xbd, 0xf7, 0xdc, 0x73, 0xe7, 0x9c, 0x3b, 0x08, 0xbe,
	0x4c, 0x39, 0x13, 0x84, 0x89, 0x52, 0xf4, 0x8b, 0x24, 0x93, 0xfd, 0x5d, 0x38, 0x88, 0x56, 0x05,
	0x97, 0x1c, 0xc1, 0x3e, 0x13, 0x9c, 0xcd, 0xf9, 0x9c, 0xeb, 0x74, 0x5f, 0x9d, 0x2a, 0x44, 0x80,
	0x52, 0xbe, 0x5c, 0x72, 0xd6, 0x9f, 0x2e, 0x78, 0xfa, 0x8b, 0xc9, 0x05, 0x8f, 0x68, 0xd5, 0xc7,
	0x30, 0x06, 0xe1, 0x53, 0x23, 0xab, 0x7a, 0xf7, 0x77, 0x07, 0xdc, 0x11, 0x67, 0x02, 0xf9, 0xd0,
	0x4c, 0xf3, 0x84, 0xb2, 0x37, 0x33, 0xdf, 0xee, 0xd8, 0xbd, 0x16, 0xde, 0x86, 0x08, 0x81, 0x9b,
	0x15, 0x7c, 0xe9, 0x3b, 0x3a, 0xad, 0xcf, 0xe8, 0x04, 0x1c, 0xc9, 0xfd, 0x03, 0x9d, 0x71, 0x24,
	0x47, 0xe7, 0xe0, 0x2a, 0x7a, 0xdf, 0xed, 0xd8, 0xbd, 0xf6, 0xe0, 0x34, 0xaa, 0x29, 0xc3, 0x49,
	0x26, 0x63, 0x0b, 0xeb, 0x3a, 0xea, 0x80, 0x23, 0xd7, 0xfe, 0xa1, 0x46, 0x9d, 0xd4, 0x51, 0xe3,
	0x75, 0x6c, 0x61, 0x47, 0xae, 0xd1, 0x37, 0xe0, 0xa6, 0x9c, 0x31, 0xbf, 0xa1, 0x31, 0xcf, 0xea,
	0x98, 0x11, 0x67, 0x8c, 0xa4, 0x92, 0x72, 0xa6, 0xf8, 0x14, 0x0a, 0x5d, 0x80, 0x97, 0x73, 0x29,
	0x64, 0x99, 0x65, 0x7e, 0x53, 0x77, 0x7c, 0xba, 0xef, 0x88, 0x62, 0x53, 0x8a, 0x2d, 0xbc, 0x83,
	0xa1, 0xaf, 0xc1, 0x15, 0x1b, 0x96, 0xfa, 0x9e, 0x86, 0x7f, 0x56, 0x1f, 0x30, 0x54, 0xa6, 0x5e,
	0x6f, 0x58, 0xaa, 0xf8, 0x15, 0x68, 0xd8, 0x00, 0x57, 0x6e, 0x56, 0xa4, 0xfb, 0x1e, 0x9c, 0xf1,
	0x1a, 0x7d, 0x01, 0xad, 0x82, 0x73, 0x39, 0xc9, 0x13, 0x91, 0x6b, 0x97, 0x8e, 0xb0, 0xa7, 0x12,
	0x71, 0x22, 0x72, 0xf4, 0x39, 0x34, 0xe5, 0x7a, 0xb2, 0xa0, 0x42, 0x6a, 0xa7, 0x8e, 0x70, 0x43,
	0xae, 0xdf, 0x52, 0x21, 0x51, 0x00, 0x1e, 0x15, 0x23, 0xce, 0x32, 0x3a, 0xd7, 0x8e, 0x79, 0x78,
	0x17, 0x77, 0x7f, 0x05, 0x57, 0xf9, 0x83, 0x5e, 0x80, 0x9b, 0x92, 0x42, 0x6a, 0xd2, 0xf6, 0xe0,
	0x93, 0x48, 0x99, 0x15, 0x8d, 0x48, 0x21, 0x69, 0x46, 0xd3, 0x44, 0x12, 0xac, 0xcb, 0xe8, 0x05,
	0x34, 0xf4, 0xe2, 0x85, 0xef, 0x74, 0x0e, 0x7a, 0xed, 0xc1, 0x71, 0x54, 0x3d, 0x87, 0xea, 0xe6,
	0xd8, 0x14, 0xd1, 0x39, 0x9c, 0x50, 0xf1, 0x9a, 0x17, 0xb7, 0x49, 0x31, 0xd3, 0x15, 0x33, 0xf7,
	0x51, 0xb6, 0x4b, 0x00, 0xf6, 0x9e, 0xaa, 0x9d, 0xd2, 0xed, 0xf2, 0x1d, 0x3a, 0x43, 0x67, 0x70,
	0x28, 0x64, 0x22, 0x89, 0x96, 0x73, 0x8c, 0xab, 0x00, 0x5d, 0x40, 0x8b, 0xf1, 0x19, 0x99, 0x28,
	0x5b, 0x34, 0xed, 0xc9, 0xe0, 0xac, 0xee, 0xe1, 0x15, 0x9f, 0x91, 0xf1, 0x66, 0x45, 0xb0, 0xc7,
	0xcc, 0xa9, 0xfb, 0xa7, 0x0d, 0xad, 0x9d, 0xb5, 0xe8, 0x3b, 0x38, 0x28, 0xc8, 0x8d, 0x51, 0xda,
	0xfd, 0x4f, 0xfb, 0x8d, 0x1c, 0x72, 0x53, 0x12, 0xa1, 0xde, 0x8e, 0x6a, 0x40, 0x3d, 0xd5, 0x27,
	0xf4, 0x65, 0xda, 0xff, 0x1e, 0x59, 0xf5, 0x91, 0x9b, 0x0a, 0x29, 0x82, 0x1f, 0xe1, 0xa8, 0x4e,
	0xa0, 0x84, 0x4c, 0xc9, 0x9c, 0x32, 0x3d, 0xd3, 0xc5, 0x55, 0x80, 0x9e, 0x41, 0x63, 0x41, 0xd8,
	0x5c, 0xe6, 0x9a, 0xf2, 0x10, 0x9b, 0x68, 0xd8, 0x82, 0xe6, 0x2a, 0xd9, 0x2c, 0x78, 0x32, 0xeb,
	0x5e, 0x80, 0xb7, 0xe5, 0xae, 0x59, 0x6f, 0xff, 0x8f, 0xf5, 0xdd, 0x3f, 0x1c, 0x00, 0x25, 0x01,
	0x13, 0x51, 0x2e, 0x24, 0xfa, 0x01, 0x9a, 0xa2, 0x4c, 0x53, 0x22, 0x84, 0x11, 0x1c, 0xd6, 0x2f,
	0xbe, 0x07, 0x46, 0xd7, 0x15, 0x2a, 0xb6, 0xf0, 0xb6, 0x01, 0x7d, 0x0f, 0x8d, 0x2c, 0xa1, 0x0b,
	0x32, 0x33, 0x9a, 0x9f, 0x3f, 0xd1, 0xfa, 0x5a, 0x83, 0x62, 0x0b, 0x1b, 0x38, 0x7a, 0x09, 0x2d,
	0xb2, 0x4e, 0xc9, 0x4a, 0x6d, 0x55, 0xaf, 0xa8, 0x3d, 0xe8, 0x3c, 0xd1, 0x7b, 0xb9, 0xc5, 0xc5,
	0x16, 0xde, 0x37, 0x05, 0xe7, 0xd0, 0x34, 0x17, 0x52, 0x6f, 0x5e, 0x4b, 0x9b, 0xb0, 0x72, 0x69,
	0x0c, 0xf4, 0x74, 0xe2, 0xaa, 0x5c, 0x06, 0x21, 0x34, 0xaa, 0xe9, 0xca, 0xe3, 0x34, 0x29, 0x05,
	0x31, 0xef, 0xa7, 0x0a, 0x82, 0xe7, 0xd0, 0xda, 0x4d, 0x40, 0xa7, 0x70, 0xb0, 0x14, 0x73, 0x03,
	0x50, 0xc7, 0xe1, 0xa1, 0x5e, 0xe9, 0x57, 0x3d, 0xf0, 0xb6, 0xaf, 0x06, 0x1d, 0x43, 0x6b, 0xf4,
	0xee, 0xea, 0xfa, 0xf2, 0x6a, 0x7c, 0x89, 0x4f, 0x2d, 0x15, 0xbe, 0x7f, 0xf5, 0xf6, 0xcd, 0x4f,
	0xaf, 0xc6, 0xef, 0xf0, 0xa9, 0x3d, 0x9c, 0x7e, 0xf8, 0x18, 0x5a, 0x77, 0x1f, 0x43, 0xeb, 0xc3,
	0x7d, 0x68, 0xdf, 0xdd, 0x87, 0xf6, 0xdf, 0xf7, 0xa1, 0xfd, 0xdb, 0x43, 0x68, 0xdd, 0x3d, 0x84,
	0xd6, 0x5f, 0x0f, 0xa1, 0xf5, 0xf3, 0xcb, 0x39, 0x95, 0x51, 0x5e, 0x26, 0xb7, 0x84, 0xaa, 0x05,
	0xf5, 0x57, 0x9c, 0x0a, 0xa1, 0xa4, 0x27, 0x45, 0x9a, 0xf7, 0x6f, 0x29, 0x61, 0xa4, 0xd0, 0x3f,
	0xb6, 0x7e, 0xf5, 0x6b, 0x7d, 0xf4, 0x7b, 0x5c, 0x4d, 0xa7, 0x0d, 0x5d, 0xf8, 0xf6, 0x9f, 0x00,
	0x00, 0x00, 0xff, 0xff, 0xbc, 0x98, 0x56, 0x9d, 0xad, 0x05, 0x00, 0x00,
}

func (m *Cons) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Cons) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Cons) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Type != nil {
		{
			size := m.Type.Size()
			i -= size
			if _, err := m.Type.MarshalTo(dAtA[i:]); err != nil {
				return 0, err
			}
		}
	}
	if len(m.To) > 0 {
		i -= len(m.To)
		copy(dAtA[i:], m.To)
		i = encodeVarintConsensus2(dAtA, i, uint64(len(m.To)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.From) > 0 {
		i -= len(m.From)
		copy(dAtA[i:], m.From)
		i = encodeVarintConsensus2(dAtA, i, uint64(len(m.From)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.ChainId) > 0 {
		i -= len(m.ChainId)
		copy(dAtA[i:], m.ChainId)
		i = encodeVarintConsensus2(dAtA, i, uint64(len(m.ChainId)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *Cons_Raft) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Cons_Raft) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.Raft != nil {
		{
			size, err := m.Raft.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintConsensus2(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x22
	}
	return len(dAtA) - i, nil
}
func (m *Cons_Tx) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Cons_Tx) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.Tx != nil {
		{
			size, err := m.Tx.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintConsensus2(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x2a
	}
	return len(dAtA) - i, nil
}
func (m *Cons_Conn) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Cons_Conn) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.Conn != nil {
		{
			size, err := m.Conn.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintConsensus2(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x32
	}
	return len(dAtA) - i, nil
}
func (m *Cons_Hotstuff) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Cons_Hotstuff) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.Hotstuff != nil {
		{
			size, err := m.Hotstuff.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintConsensus2(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x3a
	}
	return len(dAtA) - i, nil
}
func (m *Cons_Sync) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Cons_Sync) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.Sync != nil {
		{
			size, err := m.Sync.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintConsensus2(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x42
	}
	return len(dAtA) - i, nil
}
func (m *Tx) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Tx) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Tx) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.IsConfig {
		i--
		if m.IsConfig {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x18
	}
	if len(m.TxList) > 0 {
		i -= len(m.TxList)
		copy(dAtA[i:], m.TxList)
		i = encodeVarintConsensus2(dAtA, i, uint64(len(m.TxList)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.RootHash) > 0 {
		i -= len(m.RootHash)
		copy(dAtA[i:], m.RootHash)
		i = encodeVarintConsensus2(dAtA, i, uint64(len(m.RootHash)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *Raft) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Raft) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Raft) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.IsForwardBlock {
		i--
		if m.IsForwardBlock {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x18
	}
	if len(m.Blocks) > 0 {
		for iNdEx := len(m.Blocks) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Blocks[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintConsensus2(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x12
		}
	}
	if m.Cert != nil {
		{
			size, err := m.Cert.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintConsensus2(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *Connection) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Connection) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Connection) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.NodeType != 0 {
		i = encodeVarintConsensus2(dAtA, i, uint64(m.NodeType))
		i--
		dAtA[i] = 0x18
	}
	if m.State != 0 {
		i = encodeVarintConsensus2(dAtA, i, uint64(m.State))
		i--
		dAtA[i] = 0x10
	}
	if len(m.Id) > 0 {
		i -= len(m.Id)
		copy(dAtA[i:], m.Id)
		i = encodeVarintConsensus2(dAtA, i, uint64(len(m.Id)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *BlockSync) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *BlockSync) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *BlockSync) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Payload != nil {
		{
			size := m.Payload.Size()
			i -= size
			if _, err := m.Payload.MarshalTo(dAtA[i:]); err != nil {
				return 0, err
			}
		}
	}
	return len(dAtA) - i, nil
}

func (m *BlockSync_Req) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *BlockSync_Req) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.Req != nil {
		{
			size, err := m.Req.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintConsensus2(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}
func (m *BlockSync_Res) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *BlockSync_Res) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.Res != nil {
		{
			size, err := m.Res.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintConsensus2(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	return len(dAtA) - i, nil
}
func (m *BlockSync_BlockRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *BlockSync_BlockRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *BlockSync_BlockRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Length != 0 {
		i = encodeVarintConsensus2(dAtA, i, uint64(m.Length))
		i--
		dAtA[i] = 0x10
	}
	if m.Begin != 0 {
		i = encodeVarintConsensus2(dAtA, i, uint64(m.Begin))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *BlockSeq) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *BlockSeq) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *BlockSeq) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Blocks) > 0 {
		for iNdEx := len(m.Blocks) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Blocks[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintConsensus2(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *SyncResult) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SyncResult) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *SyncResult) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Res != nil {
		{
			size := m.Res.Size()
			i -= size
			if _, err := m.Res.MarshalTo(dAtA[i:]); err != nil {
				return 0, err
			}
		}
	}
	return len(dAtA) - i, nil
}

func (m *SyncResult_Success_) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *SyncResult_Success_) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.Success != nil {
		{
			size, err := m.Success.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintConsensus2(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}
func (m *SyncResult_Failed_) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *SyncResult_Failed_) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.Failed != nil {
		{
			size, err := m.Failed.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintConsensus2(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	return len(dAtA) - i, nil
}
func (m *SyncResult_Exception_) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *SyncResult_Exception_) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.Exception != nil {
		{
			size, err := m.Exception.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintConsensus2(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1a
	}
	return len(dAtA) - i, nil
}
func (m *SyncResult_Success) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SyncResult_Success) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *SyncResult_Success) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.BlockNum != 0 {
		i = encodeVarintConsensus2(dAtA, i, uint64(m.BlockNum))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *SyncResult_Failed) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SyncResult_Failed) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *SyncResult_Failed) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Cause) > 0 {
		i -= len(m.Cause)
		copy(dAtA[i:], m.Cause)
		i = encodeVarintConsensus2(dAtA, i, uint64(len(m.Cause)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *SyncResult_Exception) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SyncResult_Exception) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *SyncResult_Exception) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Msg) > 0 {
		i -= len(m.Msg)
		copy(dAtA[i:], m.Msg)
		i = encodeVarintConsensus2(dAtA, i, uint64(len(m.Msg)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func encodeVarintConsensus2(dAtA []byte, offset int, v uint64) int {
	offset -= sovConsensus2(v)
	base := offset
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return base
}
func (m *Cons) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.ChainId)
	if l > 0 {
		n += 1 + l + sovConsensus2(uint64(l))
	}
	l = len(m.From)
	if l > 0 {
		n += 1 + l + sovConsensus2(uint64(l))
	}
	l = len(m.To)
	if l > 0 {
		n += 1 + l + sovConsensus2(uint64(l))
	}
	if m.Type != nil {
		n += m.Type.Size()
	}
	return n
}

func (m *Cons_Raft) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Raft != nil {
		l = m.Raft.Size()
		n += 1 + l + sovConsensus2(uint64(l))
	}
	return n
}
func (m *Cons_Tx) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Tx != nil {
		l = m.Tx.Size()
		n += 1 + l + sovConsensus2(uint64(l))
	}
	return n
}
func (m *Cons_Conn) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Conn != nil {
		l = m.Conn.Size()
		n += 1 + l + sovConsensus2(uint64(l))
	}
	return n
}
func (m *Cons_Hotstuff) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Hotstuff != nil {
		l = m.Hotstuff.Size()
		n += 1 + l + sovConsensus2(uint64(l))
	}
	return n
}
func (m *Cons_Sync) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Sync != nil {
		l = m.Sync.Size()
		n += 1 + l + sovConsensus2(uint64(l))
	}
	return n
}
func (m *Tx) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.RootHash)
	if l > 0 {
		n += 1 + l + sovConsensus2(uint64(l))
	}
	l = len(m.TxList)
	if l > 0 {
		n += 1 + l + sovConsensus2(uint64(l))
	}
	if m.IsConfig {
		n += 2
	}
	return n
}

func (m *Raft) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Cert != nil {
		l = m.Cert.Size()
		n += 1 + l + sovConsensus2(uint64(l))
	}
	if len(m.Blocks) > 0 {
		for _, e := range m.Blocks {
			l = e.Size()
			n += 1 + l + sovConsensus2(uint64(l))
		}
	}
	if m.IsForwardBlock {
		n += 2
	}
	return n
}

func (m *Connection) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Id)
	if l > 0 {
		n += 1 + l + sovConsensus2(uint64(l))
	}
	if m.State != 0 {
		n += 1 + sovConsensus2(uint64(m.State))
	}
	if m.NodeType != 0 {
		n += 1 + sovConsensus2(uint64(m.NodeType))
	}
	return n
}

func (m *BlockSync) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Payload != nil {
		n += m.Payload.Size()
	}
	return n
}

func (m *BlockSync_Req) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Req != nil {
		l = m.Req.Size()
		n += 1 + l + sovConsensus2(uint64(l))
	}
	return n
}
func (m *BlockSync_Res) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Res != nil {
		l = m.Res.Size()
		n += 1 + l + sovConsensus2(uint64(l))
	}
	return n
}
func (m *BlockSync_BlockRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Begin != 0 {
		n += 1 + sovConsensus2(uint64(m.Begin))
	}
	if m.Length != 0 {
		n += 1 + sovConsensus2(uint64(m.Length))
	}
	return n
}

func (m *BlockSeq) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Blocks) > 0 {
		for _, e := range m.Blocks {
			l = e.Size()
			n += 1 + l + sovConsensus2(uint64(l))
		}
	}
	return n
}

func (m *SyncResult) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Res != nil {
		n += m.Res.Size()
	}
	return n
}

func (m *SyncResult_Success_) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Success != nil {
		l = m.Success.Size()
		n += 1 + l + sovConsensus2(uint64(l))
	}
	return n
}
func (m *SyncResult_Failed_) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Failed != nil {
		l = m.Failed.Size()
		n += 1 + l + sovConsensus2(uint64(l))
	}
	return n
}
func (m *SyncResult_Exception_) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Exception != nil {
		l = m.Exception.Size()
		n += 1 + l + sovConsensus2(uint64(l))
	}
	return n
}
func (m *SyncResult_Success) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.BlockNum != 0 {
		n += 1 + sovConsensus2(uint64(m.BlockNum))
	}
	return n
}

func (m *SyncResult_Failed) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Cause)
	if l > 0 {
		n += 1 + l + sovConsensus2(uint64(l))
	}
	return n
}

func (m *SyncResult_Exception) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Msg)
	if l > 0 {
		n += 1 + l + sovConsensus2(uint64(l))
	}
	return n
}

func sovConsensus2(x uint64) (n int) {
	return (math_bits.Len64(x|1) + 6) / 7
}
func sozConsensus2(x uint64) (n int) {
	return sovConsensus2(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (m *Cons) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowConsensus2
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Cons: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Cons: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ChainId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowConsensus2
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthConsensus2
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthConsensus2
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ChainId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field From", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowConsensus2
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthConsensus2
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthConsensus2
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.From = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field To", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowConsensus2
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthConsensus2
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthConsensus2
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.To = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Raft", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowConsensus2
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthConsensus2
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthConsensus2
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &Raft{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Type = &Cons_Raft{v}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Tx", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowConsensus2
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthConsensus2
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthConsensus2
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &Tx{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Type = &Cons_Tx{v}
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Conn", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowConsensus2
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthConsensus2
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthConsensus2
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &Connection{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Type = &Cons_Conn{v}
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Hotstuff", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowConsensus2
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthConsensus2
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthConsensus2
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &cons.Hotstuff{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Type = &Cons_Hotstuff{v}
			iNdEx = postIndex
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Sync", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowConsensus2
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthConsensus2
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthConsensus2
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &BlockSync{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Type = &Cons_Sync{v}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipConsensus2(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthConsensus2
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Tx) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowConsensus2
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Tx: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Tx: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RootHash", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowConsensus2
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthConsensus2
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthConsensus2
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.RootHash = append(m.RootHash[:0], dAtA[iNdEx:postIndex]...)
			if m.RootHash == nil {
				m.RootHash = []byte{}
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TxList", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowConsensus2
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthConsensus2
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthConsensus2
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.TxList = append(m.TxList[:0], dAtA[iNdEx:postIndex]...)
			if m.TxList == nil {
				m.TxList = []byte{}
			}
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IsConfig", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowConsensus2
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.IsConfig = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipConsensus2(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthConsensus2
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Raft) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowConsensus2
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Raft: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Raft: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Cert", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowConsensus2
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthConsensus2
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthConsensus2
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Cert == nil {
				m.Cert = &Certificate{}
			}
			if err := m.Cert.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Blocks", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowConsensus2
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthConsensus2
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthConsensus2
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Blocks = append(m.Blocks, &common.Block{})
			if err := m.Blocks[len(m.Blocks)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IsForwardBlock", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowConsensus2
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.IsForwardBlock = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipConsensus2(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthConsensus2
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Connection) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowConsensus2
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Connection: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Connection: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowConsensus2
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthConsensus2
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthConsensus2
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Id = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field State", wireType)
			}
			m.State = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowConsensus2
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.State |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field NodeType", wireType)
			}
			m.NodeType = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowConsensus2
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.NodeType |= NodeType(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipConsensus2(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthConsensus2
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *BlockSync) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowConsensus2
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: BlockSync: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: BlockSync: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Req", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowConsensus2
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthConsensus2
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthConsensus2
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &BlockSync_BlockRequest{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Payload = &BlockSync_Req{v}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Res", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowConsensus2
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthConsensus2
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthConsensus2
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &BlockSeq{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Payload = &BlockSync_Res{v}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipConsensus2(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthConsensus2
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *BlockSync_BlockRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowConsensus2
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: BlockRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: BlockRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Begin", wireType)
			}
			m.Begin = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowConsensus2
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Begin |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Length", wireType)
			}
			m.Length = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowConsensus2
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Length |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipConsensus2(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthConsensus2
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *BlockSeq) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowConsensus2
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: BlockSeq: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: BlockSeq: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Blocks", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowConsensus2
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthConsensus2
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthConsensus2
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Blocks = append(m.Blocks, &common.Block{})
			if err := m.Blocks[len(m.Blocks)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipConsensus2(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthConsensus2
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SyncResult) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowConsensus2
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SyncResult: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SyncResult: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Success", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowConsensus2
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthConsensus2
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthConsensus2
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &SyncResult_Success{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Res = &SyncResult_Success_{v}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Failed", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowConsensus2
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthConsensus2
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthConsensus2
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &SyncResult_Failed{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Res = &SyncResult_Failed_{v}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Exception", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowConsensus2
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthConsensus2
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthConsensus2
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &SyncResult_Exception{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Res = &SyncResult_Exception_{v}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipConsensus2(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthConsensus2
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SyncResult_Success) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowConsensus2
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Success: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Success: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field BlockNum", wireType)
			}
			m.BlockNum = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowConsensus2
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.BlockNum |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipConsensus2(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthConsensus2
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SyncResult_Failed) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowConsensus2
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Failed: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Failed: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Cause", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowConsensus2
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthConsensus2
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthConsensus2
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Cause = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipConsensus2(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthConsensus2
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SyncResult_Exception) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowConsensus2
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Exception: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Exception: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Msg", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowConsensus2
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthConsensus2
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthConsensus2
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Msg = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipConsensus2(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthConsensus2
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipConsensus2(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	depth := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowConsensus2
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowConsensus2
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
		case 1:
			iNdEx += 8
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowConsensus2
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if length < 0 {
				return 0, ErrInvalidLengthConsensus2
			}
			iNdEx += length
		case 3:
			depth++
		case 4:
			if depth == 0 {
				return 0, ErrUnexpectedEndOfGroupConsensus2
			}
			depth--
		case 5:
			iNdEx += 4
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
		if iNdEx < 0 {
			return 0, ErrInvalidLengthConsensus2
		}
		if depth == 0 {
			return iNdEx, nil
		}
	}
	return 0, io.ErrUnexpectedEOF
}

var (
	ErrInvalidLengthConsensus2        = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowConsensus2          = fmt.Errorf("proto: integer overflow")
	ErrUnexpectedEndOfGroupConsensus2 = fmt.Errorf("proto: unexpected end of group")
)
