// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: consensus/raft/raft2.proto

package pb

import (
	fmt "fmt"
	consensus "git.huawei.com/huaweichain/proto/consensus"
	_ "github.com/gogo/protobuf/gogoproto"
	proto "github.com/gogo/protobuf/proto"
	io "io"
	math "math"
	math_bits "math/bits"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.GoGoProtoPackageIsVersion3 // please upgrade the proto package

type MsgType int32

const (
	Append            MsgType = 0
	AppReject         MsgType = 1
	AppAccept         MsgType = 10
	VoteReq           MsgType = 2
	VoteResp          MsgType = 3
	PreVoteReq        MsgType = 4
	PreVoteResp       MsgType = 5
	HeartbeatReq      MsgType = 6
	HeartbeatResp     MsgType = 7
	Snap              MsgType = 8
	SnapSent          MsgType = 16
	TimeoutNow        MsgType = 9
	TransferLeader    MsgType = 12
	TransferConfEntry MsgType = 13
	InitRaftConsensus MsgType = 14
	StopRaftConsensus MsgType = 15
	Unreachable       MsgType = 11
)

var MsgType_name = map[int32]string{
	0:  "Append",
	1:  "AppReject",
	10: "AppAccept",
	2:  "VoteReq",
	3:  "VoteResp",
	4:  "PreVoteReq",
	5:  "PreVoteResp",
	6:  "HeartbeatReq",
	7:  "HeartbeatResp",
	8:  "Snap",
	16: "SnapSent",
	9:  "TimeoutNow",
	12: "TransferLeader",
	13: "TransferConfEntry",
	14: "InitRaftConsensus",
	15: "StopRaftConsensus",
	11: "Unreachable",
}

var MsgType_value = map[string]int32{
	"Append":            0,
	"AppReject":         1,
	"AppAccept":         10,
	"VoteReq":           2,
	"VoteResp":          3,
	"PreVoteReq":        4,
	"PreVoteResp":       5,
	"HeartbeatReq":      6,
	"HeartbeatResp":     7,
	"Snap":              8,
	"SnapSent":          16,
	"TimeoutNow":        9,
	"TransferLeader":    12,
	"TransferConfEntry": 13,
	"InitRaftConsensus": 14,
	"StopRaftConsensus": 15,
	"Unreachable":       11,
}

func (x MsgType) String() string {
	return proto.EnumName(MsgType_name, int32(x))
}

func (MsgType) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_afe3c49a0352b568, []int{0}
}

type State int32

const (
	Follower     State = 0
	Candidate    State = 1
	PreCandidate State = 2
	Leader       State = 3
)

var State_name = map[int32]string{
	0: "Follower",
	1: "Candidate",
	2: "PreCandidate",
	3: "Leader",
}

var State_value = map[string]int32{
	"Follower":     0,
	"Candidate":    1,
	"PreCandidate": 2,
	"Leader":       3,
}

func (x State) String() string {
	return proto.EnumName(State_name, int32(x))
}

func (State) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_afe3c49a0352b568, []int{1}
}

type StateSet struct {
	Timer      *Timer      `protobuf:"bytes,1,opt,name=timer,proto3" json:"timer,omitempty"`
	Leadership *Leadership `protobuf:"bytes,2,opt,name=leadership,proto3" json:"leadership,omitempty"`
	Term       uint64      `protobuf:"varint,3,opt,name=term,proto3" json:"term,omitempty"`
	LastIndex  uint64      `protobuf:"varint,4,opt,name=lastIndex,proto3" json:"lastIndex,omitempty"`
	Transfer   bool        `protobuf:"varint,5,opt,name=transfer,proto3" json:"transfer,omitempty"`
}

func (m *StateSet) Reset()         { *m = StateSet{} }
func (m *StateSet) String() string { return proto.CompactTextString(m) }
func (*StateSet) ProtoMessage()    {}
func (*StateSet) Descriptor() ([]byte, []int) {
	return fileDescriptor_afe3c49a0352b568, []int{0}
}
func (m *StateSet) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *StateSet) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_StateSet.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *StateSet) XXX_Merge(src proto.Message) {
	xxx_messageInfo_StateSet.Merge(m, src)
}
func (m *StateSet) XXX_Size() int {
	return m.Size()
}
func (m *StateSet) XXX_DiscardUnknown() {
	xxx_messageInfo_StateSet.DiscardUnknown(m)
}

var xxx_messageInfo_StateSet proto.InternalMessageInfo

type DataSet struct {
	StateStore       *StateStore    `protobuf:"bytes,1,opt,name=stateStore,proto3" json:"stateStore,omitempty"`
	Entries          []*Entry       `protobuf:"bytes,2,rep,name=entries,proto3" json:"entries,omitempty"`
	Snapshot         *Snapshot      `protobuf:"bytes,3,opt,name=snapshot,proto3" json:"snapshot,omitempty"`
	Message          []*Certificate `protobuf:"bytes,4,rep,name=message,proto3" json:"message,omitempty"`
	Sync             bool           `protobuf:"varint,5,opt,name=sync,proto3" json:"sync,omitempty"`
	Remaining        uint64         `protobuf:"varint,6,opt,name=remaining,proto3" json:"remaining,omitempty"`
	Terminate        bool           `protobuf:"varint,7,opt,name=terminate,proto3" json:"terminate,omitempty"`
	CurrentConfIndex uint64         `protobuf:"varint,8,opt,name=currentConfIndex,proto3" json:"currentConfIndex,omitempty"`
}

func (m *DataSet) Reset()         { *m = DataSet{} }
func (m *DataSet) String() string { return proto.CompactTextString(m) }
func (*DataSet) ProtoMessage()    {}
func (*DataSet) Descriptor() ([]byte, []int) {
	return fileDescriptor_afe3c49a0352b568, []int{1}
}
func (m *DataSet) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *DataSet) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_DataSet.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *DataSet) XXX_Merge(src proto.Message) {
	xxx_messageInfo_DataSet.Merge(m, src)
}
func (m *DataSet) XXX_Size() int {
	return m.Size()
}
func (m *DataSet) XXX_DiscardUnknown() {
	xxx_messageInfo_DataSet.DiscardUnknown(m)
}

var xxx_messageInfo_DataSet proto.InternalMessageInfo

type Timer struct {
	IsReset bool   `protobuf:"varint,1,opt,name=isReset,proto3" json:"isReset,omitempty"`
	Timeout uint64 `protobuf:"varint,2,opt,name=timeout,proto3" json:"timeout,omitempty"`
}

func (m *Timer) Reset()         { *m = Timer{} }
func (m *Timer) String() string { return proto.CompactTextString(m) }
func (*Timer) ProtoMessage()    {}
func (*Timer) Descriptor() ([]byte, []int) {
	return fileDescriptor_afe3c49a0352b568, []int{2}
}
func (m *Timer) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Timer) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Timer.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Timer) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Timer.Merge(m, src)
}
func (m *Timer) XXX_Size() int {
	return m.Size()
}
func (m *Timer) XXX_DiscardUnknown() {
	xxx_messageInfo_Timer.DiscardUnknown(m)
}

var xxx_messageInfo_Timer proto.InternalMessageInfo

type Leadership struct {
	Leader string `protobuf:"bytes,1,opt,name=leader,proto3" json:"leader,omitempty"`
	State  State  `protobuf:"varint,2,opt,name=state,proto3,enum=raft.State" json:"state,omitempty"`
}

func (m *Leadership) Reset()         { *m = Leadership{} }
func (m *Leadership) String() string { return proto.CompactTextString(m) }
func (*Leadership) ProtoMessage()    {}
func (*Leadership) Descriptor() ([]byte, []int) {
	return fileDescriptor_afe3c49a0352b568, []int{3}
}
func (m *Leadership) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Leadership) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Leadership.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Leadership) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Leadership.Merge(m, src)
}
func (m *Leadership) XXX_Size() int {
	return m.Size()
}
func (m *Leadership) XXX_DiscardUnknown() {
	xxx_messageInfo_Leadership.DiscardUnknown(m)
}

var xxx_messageInfo_Leadership proto.InternalMessageInfo

type Conf struct {
	Voters   []string `protobuf:"bytes,1,rep,name=voters,proto3" json:"voters,omitempty"`
	Learners []string `protobuf:"bytes,2,rep,name=learners,proto3" json:"learners,omitempty"`
}

func (m *Conf) Reset()         { *m = Conf{} }
func (m *Conf) String() string { return proto.CompactTextString(m) }
func (*Conf) ProtoMessage()    {}
func (*Conf) Descriptor() ([]byte, []int) {
	return fileDescriptor_afe3c49a0352b568, []int{4}
}
func (m *Conf) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Conf) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Conf.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Conf) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Conf.Merge(m, src)
}
func (m *Conf) XXX_Size() int {
	return m.Size()
}
func (m *Conf) XXX_DiscardUnknown() {
	xxx_messageInfo_Conf.DiscardUnknown(m)
}

var xxx_messageInfo_Conf proto.InternalMessageInfo

type ConfChange struct {
	Block *BlockMetadata       `protobuf:"bytes,1,opt,name=block,proto3" json:"block,omitempty"`
	Op    consensus.ConfOp     `protobuf:"varint,2,opt,name=op,proto3,enum=consensus.ConfOp" json:"op,omitempty"`
	Node  *consensus.Consenter `protobuf:"bytes,3,opt,name=node,proto3" json:"node,omitempty"`
}

func (m *ConfChange) Reset()         { *m = ConfChange{} }
func (m *ConfChange) String() string { return proto.CompactTextString(m) }
func (*ConfChange) ProtoMessage()    {}
func (*ConfChange) Descriptor() ([]byte, []int) {
	return fileDescriptor_afe3c49a0352b568, []int{5}
}
func (m *ConfChange) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ConfChange) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ConfChange.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ConfChange) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ConfChange.Merge(m, src)
}
func (m *ConfChange) XXX_Size() int {
	return m.Size()
}
func (m *ConfChange) XXX_DiscardUnknown() {
	xxx_messageInfo_ConfChange.DiscardUnknown(m)
}

var xxx_messageInfo_ConfChange proto.InternalMessageInfo

type Entry struct {
	Term  uint64 `protobuf:"varint,1,opt,name=term,proto3" json:"term,omitempty"`
	Index uint64 `protobuf:"varint,2,opt,name=index,proto3" json:"index,omitempty"`
	// Types that are valid to be assigned to Value:
	//	*Entry_Block
	//	*Entry_ConfChange
	Value      isEntry_Value `protobuf_oneof:"value"`
	Signature  []byte        `protobuf:"bytes,5,opt,name=signature,proto3" json:"signature,omitempty"`
	BlockBytes []byte        `protobuf:"bytes,6,opt,name=blockBytes,proto3" json:"blockBytes,omitempty"`
}

func (m *Entry) Reset()         { *m = Entry{} }
func (m *Entry) String() string { return proto.CompactTextString(m) }
func (*Entry) ProtoMessage()    {}
func (*Entry) Descriptor() ([]byte, []int) {
	return fileDescriptor_afe3c49a0352b568, []int{6}
}
func (m *Entry) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Entry) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Entry.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Entry) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Entry.Merge(m, src)
}
func (m *Entry) XXX_Size() int {
	return m.Size()
}
func (m *Entry) XXX_DiscardUnknown() {
	xxx_messageInfo_Entry.DiscardUnknown(m)
}

var xxx_messageInfo_Entry proto.InternalMessageInfo

type isEntry_Value interface {
	isEntry_Value()
	MarshalTo([]byte) (int, error)
	Size() int
}

type Entry_Block struct {
	Block *BlockMetadata `protobuf:"bytes,3,opt,name=block,proto3,oneof" json:"block,omitempty"`
}
type Entry_ConfChange struct {
	ConfChange *ConfChange `protobuf:"bytes,4,opt,name=confChange,proto3,oneof" json:"confChange,omitempty"`
}

func (*Entry_Block) isEntry_Value()      {}
func (*Entry_ConfChange) isEntry_Value() {}

func (m *Entry) GetValue() isEntry_Value {
	if m != nil {
		return m.Value
	}
	return nil
}

func (m *Entry) GetBlock() *BlockMetadata {
	if x, ok := m.GetValue().(*Entry_Block); ok {
		return x.Block
	}
	return nil
}

func (m *Entry) GetConfChange() *ConfChange {
	if x, ok := m.GetValue().(*Entry_ConfChange); ok {
		return x.ConfChange
	}
	return nil
}

// XXX_OneofWrappers is for the internal use of the proto package.
func (*Entry) XXX_OneofWrappers() []interface{} {
	return []interface{}{
		(*Entry_Block)(nil),
		(*Entry_ConfChange)(nil),
	}
}

type BlockMetadata struct {
	Height uint64 `protobuf:"varint,1,opt,name=height,proto3" json:"height,omitempty"`
	Hash   []byte `protobuf:"bytes,2,opt,name=hash,proto3" json:"hash,omitempty"`
}

func (m *BlockMetadata) Reset()         { *m = BlockMetadata{} }
func (m *BlockMetadata) String() string { return proto.CompactTextString(m) }
func (*BlockMetadata) ProtoMessage()    {}
func (*BlockMetadata) Descriptor() ([]byte, []int) {
	return fileDescriptor_afe3c49a0352b568, []int{7}
}
func (m *BlockMetadata) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *BlockMetadata) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_BlockMetadata.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *BlockMetadata) XXX_Merge(src proto.Message) {
	xxx_messageInfo_BlockMetadata.Merge(m, src)
}
func (m *BlockMetadata) XXX_Size() int {
	return m.Size()
}
func (m *BlockMetadata) XXX_DiscardUnknown() {
	xxx_messageInfo_BlockMetadata.DiscardUnknown(m)
}

var xxx_messageInfo_BlockMetadata proto.InternalMessageInfo

type Certificate struct {
	Msg  []byte `protobuf:"bytes,1,opt,name=msg,proto3" json:"msg,omitempty"`
	Sign []byte `protobuf:"bytes,2,opt,name=sign,proto3" json:"sign,omitempty"`
}

func (m *Certificate) Reset()         { *m = Certificate{} }
func (m *Certificate) String() string { return proto.CompactTextString(m) }
func (*Certificate) ProtoMessage()    {}
func (*Certificate) Descriptor() ([]byte, []int) {
	return fileDescriptor_afe3c49a0352b568, []int{8}
}
func (m *Certificate) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Certificate) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Certificate.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Certificate) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Certificate.Merge(m, src)
}
func (m *Certificate) XXX_Size() int {
	return m.Size()
}
func (m *Certificate) XXX_DiscardUnknown() {
	xxx_messageInfo_Certificate.DiscardUnknown(m)
}

var xxx_messageInfo_Certificate proto.InternalMessageInfo

type Msg struct {
	Group string  `protobuf:"bytes,12,opt,name=group,proto3" json:"group,omitempty"`
	Type  MsgType `protobuf:"varint,1,opt,name=type,proto3,enum=raft.MsgType" json:"type,omitempty"`
	From  string  `protobuf:"bytes,2,opt,name=from,proto3" json:"from,omitempty"`
	To    string  `protobuf:"bytes,3,opt,name=to,proto3" json:"to,omitempty"`
	Term  uint64  `protobuf:"varint,13,opt,name=term,proto3" json:"term,omitempty"`
	// Types that are valid to be assigned to Payload:
	//	*Msg_Append
	//	*Msg_Accpet
	//	*Msg_Reject
	//	*Msg_Vote
	//	*Msg_VoteResp
	//	*Msg_Hb
	//	*Msg_HbResp
	//	*Msg_Snap
	//	*Msg_SnapStatus
	//	*Msg_Prop
	//	*Msg_Config
	Payload isMsg_Payload `protobuf_oneof:"payload"`
}

func (m *Msg) Reset()         { *m = Msg{} }
func (m *Msg) String() string { return proto.CompactTextString(m) }
func (*Msg) ProtoMessage()    {}
func (*Msg) Descriptor() ([]byte, []int) {
	return fileDescriptor_afe3c49a0352b568, []int{9}
}
func (m *Msg) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Msg) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Msg.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Msg) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Msg.Merge(m, src)
}
func (m *Msg) XXX_Size() int {
	return m.Size()
}
func (m *Msg) XXX_DiscardUnknown() {
	xxx_messageInfo_Msg.DiscardUnknown(m)
}

var xxx_messageInfo_Msg proto.InternalMessageInfo

type isMsg_Payload interface {
	isMsg_Payload()
	MarshalTo([]byte) (int, error)
	Size() int
}

type Msg_Append struct {
	Append *AppendEntries `protobuf:"bytes,4,opt,name=append,proto3,oneof" json:"append,omitempty"`
}
type Msg_Accpet struct {
	Accpet *AppendAccept `protobuf:"bytes,5,opt,name=accpet,proto3,oneof" json:"accpet,omitempty"`
}
type Msg_Reject struct {
	Reject *AppendReject `protobuf:"bytes,6,opt,name=reject,proto3,oneof" json:"reject,omitempty"`
}
type Msg_Vote struct {
	Vote *Vote `protobuf:"bytes,7,opt,name=vote,proto3,oneof" json:"vote,omitempty"`
}
type Msg_VoteResp struct {
	VoteResp *VoteResponse `protobuf:"bytes,8,opt,name=voteResp,proto3,oneof" json:"voteResp,omitempty"`
}
type Msg_Hb struct {
	Hb *Heartbeat `protobuf:"bytes,9,opt,name=hb,proto3,oneof" json:"hb,omitempty"`
}
type Msg_HbResp struct {
	HbResp *HeartbeatResponse `protobuf:"bytes,14,opt,name=hbResp,proto3,oneof" json:"hbResp,omitempty"`
}
type Msg_Snap struct {
	Snap *Snapshot `protobuf:"bytes,10,opt,name=snap,proto3,oneof" json:"snap,omitempty"`
}
type Msg_SnapStatus struct {
	SnapStatus *SnapshotStatus `protobuf:"bytes,11,opt,name=snapStatus,proto3,oneof" json:"snapStatus,omitempty"`
}
type Msg_Prop struct {
	Prop *Proposal `protobuf:"bytes,15,opt,name=prop,proto3,oneof" json:"prop,omitempty"`
}
type Msg_Config struct {
	Config *InitConfig `protobuf:"bytes,16,opt,name=config,proto3,oneof" json:"config,omitempty"`
}

func (*Msg_Append) isMsg_Payload()     {}
func (*Msg_Accpet) isMsg_Payload()     {}
func (*Msg_Reject) isMsg_Payload()     {}
func (*Msg_Vote) isMsg_Payload()       {}
func (*Msg_VoteResp) isMsg_Payload()   {}
func (*Msg_Hb) isMsg_Payload()         {}
func (*Msg_HbResp) isMsg_Payload()     {}
func (*Msg_Snap) isMsg_Payload()       {}
func (*Msg_SnapStatus) isMsg_Payload() {}
func (*Msg_Prop) isMsg_Payload()       {}
func (*Msg_Config) isMsg_Payload()     {}

func (m *Msg) GetPayload() isMsg_Payload {
	if m != nil {
		return m.Payload
	}
	return nil
}

func (m *Msg) GetAppend() *AppendEntries {
	if x, ok := m.GetPayload().(*Msg_Append); ok {
		return x.Append
	}
	return nil
}

func (m *Msg) GetAccpet() *AppendAccept {
	if x, ok := m.GetPayload().(*Msg_Accpet); ok {
		return x.Accpet
	}
	return nil
}

func (m *Msg) GetReject() *AppendReject {
	if x, ok := m.GetPayload().(*Msg_Reject); ok {
		return x.Reject
	}
	return nil
}

func (m *Msg) GetVote() *Vote {
	if x, ok := m.GetPayload().(*Msg_Vote); ok {
		return x.Vote
	}
	return nil
}

func (m *Msg) GetVoteResp() *VoteResponse {
	if x, ok := m.GetPayload().(*Msg_VoteResp); ok {
		return x.VoteResp
	}
	return nil
}

func (m *Msg) GetHb() *Heartbeat {
	if x, ok := m.GetPayload().(*Msg_Hb); ok {
		return x.Hb
	}
	return nil
}

func (m *Msg) GetHbResp() *HeartbeatResponse {
	if x, ok := m.GetPayload().(*Msg_HbResp); ok {
		return x.HbResp
	}
	return nil
}

func (m *Msg) GetSnap() *Snapshot {
	if x, ok := m.GetPayload().(*Msg_Snap); ok {
		return x.Snap
	}
	return nil
}

func (m *Msg) GetSnapStatus() *SnapshotStatus {
	if x, ok := m.GetPayload().(*Msg_SnapStatus); ok {
		return x.SnapStatus
	}
	return nil
}

func (m *Msg) GetProp() *Proposal {
	if x, ok := m.GetPayload().(*Msg_Prop); ok {
		return x.Prop
	}
	return nil
}

func (m *Msg) GetConfig() *InitConfig {
	if x, ok := m.GetPayload().(*Msg_Config); ok {
		return x.Config
	}
	return nil
}

// XXX_OneofWrappers is for the internal use of the proto package.
func (*Msg) XXX_OneofWrappers() []interface{} {
	return []interface{}{
		(*Msg_Append)(nil),
		(*Msg_Accpet)(nil),
		(*Msg_Reject)(nil),
		(*Msg_Vote)(nil),
		(*Msg_VoteResp)(nil),
		(*Msg_Hb)(nil),
		(*Msg_HbResp)(nil),
		(*Msg_Snap)(nil),
		(*Msg_SnapStatus)(nil),
		(*Msg_Prop)(nil),
		(*Msg_Config)(nil),
	}
}

type InitConfig struct {
	Op        consensus.ConfOp `protobuf:"varint,1,opt,name=op,proto3,enum=consensus.ConfOp" json:"op,omitempty"`
	InitState []byte           `protobuf:"bytes,2,opt,name=initState,proto3" json:"initState,omitempty"`
	Height    uint64           `protobuf:"varint,3,opt,name=height,proto3" json:"height,omitempty"`
}

func (m *InitConfig) Reset()         { *m = InitConfig{} }
func (m *InitConfig) String() string { return proto.CompactTextString(m) }
func (*InitConfig) ProtoMessage()    {}
func (*InitConfig) Descriptor() ([]byte, []int) {
	return fileDescriptor_afe3c49a0352b568, []int{10}
}
func (m *InitConfig) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *InitConfig) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_InitConfig.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *InitConfig) XXX_Merge(src proto.Message) {
	xxx_messageInfo_InitConfig.Merge(m, src)
}
func (m *InitConfig) XXX_Size() int {
	return m.Size()
}
func (m *InitConfig) XXX_DiscardUnknown() {
	xxx_messageInfo_InitConfig.DiscardUnknown(m)
}

var xxx_messageInfo_InitConfig proto.InternalMessageInfo

type HeartbeatResponse struct {
	LastIndex uint64 `protobuf:"varint,1,opt,name=lastIndex,proto3" json:"lastIndex,omitempty"`
}

func (m *HeartbeatResponse) Reset()         { *m = HeartbeatResponse{} }
func (m *HeartbeatResponse) String() string { return proto.CompactTextString(m) }
func (*HeartbeatResponse) ProtoMessage()    {}
func (*HeartbeatResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_afe3c49a0352b568, []int{11}
}
func (m *HeartbeatResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *HeartbeatResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_HeartbeatResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *HeartbeatResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_HeartbeatResponse.Merge(m, src)
}
func (m *HeartbeatResponse) XXX_Size() int {
	return m.Size()
}
func (m *HeartbeatResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_HeartbeatResponse.DiscardUnknown(m)
}

var xxx_messageInfo_HeartbeatResponse proto.InternalMessageInfo

type Proposal struct {
	Entries []*Entry `protobuf:"bytes,1,rep,name=entries,proto3" json:"entries,omitempty"`
}

func (m *Proposal) Reset()         { *m = Proposal{} }
func (m *Proposal) String() string { return proto.CompactTextString(m) }
func (*Proposal) ProtoMessage()    {}
func (*Proposal) Descriptor() ([]byte, []int) {
	return fileDescriptor_afe3c49a0352b568, []int{12}
}
func (m *Proposal) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Proposal) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Proposal.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Proposal) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Proposal.Merge(m, src)
}
func (m *Proposal) XXX_Size() int {
	return m.Size()
}
func (m *Proposal) XXX_DiscardUnknown() {
	xxx_messageInfo_Proposal.DiscardUnknown(m)
}

var xxx_messageInfo_Proposal proto.InternalMessageInfo

type AppendEntries struct {
	Entries []*Entry `protobuf:"bytes,1,rep,name=entries,proto3" json:"entries,omitempty"`
	Term    uint64   `protobuf:"varint,2,opt,name=term,proto3" json:"term,omitempty"`
	Index   uint64   `protobuf:"varint,3,opt,name=index,proto3" json:"index,omitempty"`
	Commit  uint64   `protobuf:"varint,4,opt,name=commit,proto3" json:"commit,omitempty"`
}

func (m *AppendEntries) Reset()         { *m = AppendEntries{} }
func (m *AppendEntries) String() string { return proto.CompactTextString(m) }
func (*AppendEntries) ProtoMessage()    {}
func (*AppendEntries) Descriptor() ([]byte, []int) {
	return fileDescriptor_afe3c49a0352b568, []int{13}
}
func (m *AppendEntries) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *AppendEntries) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_AppendEntries.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *AppendEntries) XXX_Merge(src proto.Message) {
	xxx_messageInfo_AppendEntries.Merge(m, src)
}
func (m *AppendEntries) XXX_Size() int {
	return m.Size()
}
func (m *AppendEntries) XXX_DiscardUnknown() {
	xxx_messageInfo_AppendEntries.DiscardUnknown(m)
}

var xxx_messageInfo_AppendEntries proto.InternalMessageInfo

type Snapshot struct {
	Term     uint64      `protobuf:"varint,1,opt,name=term,proto3" json:"term,omitempty"`
	Index    uint64      `protobuf:"varint,2,opt,name=index,proto3" json:"index,omitempty"`
	Conf     *Conf       `protobuf:"bytes,3,opt,name=conf,proto3" json:"conf,omitempty"`
	Range    *BlockRange `protobuf:"bytes,4,opt,name=range,proto3" json:"range,omitempty"`
	BlockSeq []byte      `protobuf:"bytes,5,opt,name=block_seq,json=blockSeq,proto3" json:"block_seq,omitempty"`
}

func (m *Snapshot) Reset()         { *m = Snapshot{} }
func (m *Snapshot) String() string { return proto.CompactTextString(m) }
func (*Snapshot) ProtoMessage()    {}
func (*Snapshot) Descriptor() ([]byte, []int) {
	return fileDescriptor_afe3c49a0352b568, []int{14}
}
func (m *Snapshot) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Snapshot) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Snapshot.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Snapshot) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Snapshot.Merge(m, src)
}
func (m *Snapshot) XXX_Size() int {
	return m.Size()
}
func (m *Snapshot) XXX_DiscardUnknown() {
	xxx_messageInfo_Snapshot.DiscardUnknown(m)
}

var xxx_messageInfo_Snapshot proto.InternalMessageInfo

type BlockRange struct {
	Begin         uint64   `protobuf:"varint,1,opt,name=begin,proto3" json:"begin,omitempty"`
	End           uint64   `protobuf:"varint,2,opt,name=end,proto3" json:"end,omitempty"`
	IndexToHeight []uint64 `protobuf:"varint,3,rep,packed,name=index_to_height,json=indexToHeight,proto3" json:"index_to_height,omitempty"`
}

func (m *BlockRange) Reset()         { *m = BlockRange{} }
func (m *BlockRange) String() string { return proto.CompactTextString(m) }
func (*BlockRange) ProtoMessage()    {}
func (*BlockRange) Descriptor() ([]byte, []int) {
	return fileDescriptor_afe3c49a0352b568, []int{15}
}
func (m *BlockRange) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *BlockRange) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_BlockRange.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *BlockRange) XXX_Merge(src proto.Message) {
	xxx_messageInfo_BlockRange.Merge(m, src)
}
func (m *BlockRange) XXX_Size() int {
	return m.Size()
}
func (m *BlockRange) XXX_DiscardUnknown() {
	xxx_messageInfo_BlockRange.DiscardUnknown(m)
}

var xxx_messageInfo_BlockRange proto.InternalMessageInfo

type AppendReject struct {
	AppIndex  uint64 `protobuf:"varint,1,opt,name=appIndex,proto3" json:"appIndex,omitempty"`
	LastIndex uint64 `protobuf:"varint,2,opt,name=lastIndex,proto3" json:"lastIndex,omitempty"`
}

func (m *AppendReject) Reset()         { *m = AppendReject{} }
func (m *AppendReject) String() string { return proto.CompactTextString(m) }
func (*AppendReject) ProtoMessage()    {}
func (*AppendReject) Descriptor() ([]byte, []int) {
	return fileDescriptor_afe3c49a0352b568, []int{16}
}
func (m *AppendReject) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *AppendReject) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_AppendReject.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *AppendReject) XXX_Merge(src proto.Message) {
	xxx_messageInfo_AppendReject.Merge(m, src)
}
func (m *AppendReject) XXX_Size() int {
	return m.Size()
}
func (m *AppendReject) XXX_DiscardUnknown() {
	xxx_messageInfo_AppendReject.DiscardUnknown(m)
}

var xxx_messageInfo_AppendReject proto.InternalMessageInfo

type AppendAccept struct {
	MatchIndex uint64 `protobuf:"varint,1,opt,name=matchIndex,proto3" json:"matchIndex,omitempty"`
}

func (m *AppendAccept) Reset()         { *m = AppendAccept{} }
func (m *AppendAccept) String() string { return proto.CompactTextString(m) }
func (*AppendAccept) ProtoMessage()    {}
func (*AppendAccept) Descriptor() ([]byte, []int) {
	return fileDescriptor_afe3c49a0352b568, []int{17}
}
func (m *AppendAccept) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *AppendAccept) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_AppendAccept.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *AppendAccept) XXX_Merge(src proto.Message) {
	xxx_messageInfo_AppendAccept.Merge(m, src)
}
func (m *AppendAccept) XXX_Size() int {
	return m.Size()
}
func (m *AppendAccept) XXX_DiscardUnknown() {
	xxx_messageInfo_AppendAccept.DiscardUnknown(m)
}

var xxx_messageInfo_AppendAccept proto.InternalMessageInfo

type Vote struct {
	Term      uint64 `protobuf:"varint,1,opt,name=term,proto3" json:"term,omitempty"`
	LastIndex uint64 `protobuf:"varint,2,opt,name=lastIndex,proto3" json:"lastIndex,omitempty"`
	LastTerm  uint64 `protobuf:"varint,3,opt,name=lastTerm,proto3" json:"lastTerm,omitempty"`
}

func (m *Vote) Reset()         { *m = Vote{} }
func (m *Vote) String() string { return proto.CompactTextString(m) }
func (*Vote) ProtoMessage()    {}
func (*Vote) Descriptor() ([]byte, []int) {
	return fileDescriptor_afe3c49a0352b568, []int{18}
}
func (m *Vote) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Vote) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Vote.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Vote) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Vote.Merge(m, src)
}
func (m *Vote) XXX_Size() int {
	return m.Size()
}
func (m *Vote) XXX_DiscardUnknown() {
	xxx_messageInfo_Vote.DiscardUnknown(m)
}

var xxx_messageInfo_Vote proto.InternalMessageInfo

type VoteResponse struct {
	Granted bool `protobuf:"varint,1,opt,name=granted,proto3" json:"granted,omitempty"`
}

func (m *VoteResponse) Reset()         { *m = VoteResponse{} }
func (m *VoteResponse) String() string { return proto.CompactTextString(m) }
func (*VoteResponse) ProtoMessage()    {}
func (*VoteResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_afe3c49a0352b568, []int{19}
}
func (m *VoteResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *VoteResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_VoteResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *VoteResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_VoteResponse.Merge(m, src)
}
func (m *VoteResponse) XXX_Size() int {
	return m.Size()
}
func (m *VoteResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_VoteResponse.DiscardUnknown(m)
}

var xxx_messageInfo_VoteResponse proto.InternalMessageInfo

type Heartbeat struct {
	Commit uint64 `protobuf:"varint,1,opt,name=commit,proto3" json:"commit,omitempty"`
}

func (m *Heartbeat) Reset()         { *m = Heartbeat{} }
func (m *Heartbeat) String() string { return proto.CompactTextString(m) }
func (*Heartbeat) ProtoMessage()    {}
func (*Heartbeat) Descriptor() ([]byte, []int) {
	return fileDescriptor_afe3c49a0352b568, []int{20}
}
func (m *Heartbeat) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Heartbeat) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Heartbeat.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Heartbeat) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Heartbeat.Merge(m, src)
}
func (m *Heartbeat) XXX_Size() int {
	return m.Size()
}
func (m *Heartbeat) XXX_DiscardUnknown() {
	xxx_messageInfo_Heartbeat.DiscardUnknown(m)
}

var xxx_messageInfo_Heartbeat proto.InternalMessageInfo

type SnapshotStatus struct {
	Done   bool `protobuf:"varint,2,opt,name=done,proto3" json:"done,omitempty"`
	Reject bool `protobuf:"varint,1,opt,name=reject,proto3" json:"reject,omitempty"`
}

func (m *SnapshotStatus) Reset()         { *m = SnapshotStatus{} }
func (m *SnapshotStatus) String() string { return proto.CompactTextString(m) }
func (*SnapshotStatus) ProtoMessage()    {}
func (*SnapshotStatus) Descriptor() ([]byte, []int) {
	return fileDescriptor_afe3c49a0352b568, []int{21}
}
func (m *SnapshotStatus) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *SnapshotStatus) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_SnapshotStatus.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *SnapshotStatus) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SnapshotStatus.Merge(m, src)
}
func (m *SnapshotStatus) XXX_Size() int {
	return m.Size()
}
func (m *SnapshotStatus) XXX_DiscardUnknown() {
	xxx_messageInfo_SnapshotStatus.DiscardUnknown(m)
}

var xxx_messageInfo_SnapshotStatus proto.InternalMessageInfo

type StateStore struct {
	Term   uint64 `protobuf:"varint,1,opt,name=term,proto3" json:"term,omitempty"`
	Vote   string `protobuf:"bytes,2,opt,name=vote,proto3" json:"vote,omitempty"`
	Commit uint64 `protobuf:"varint,3,opt,name=commit,proto3" json:"commit,omitempty"`
}

func (m *StateStore) Reset()         { *m = StateStore{} }
func (m *StateStore) String() string { return proto.CompactTextString(m) }
func (*StateStore) ProtoMessage()    {}
func (*StateStore) Descriptor() ([]byte, []int) {
	return fileDescriptor_afe3c49a0352b568, []int{22}
}
func (m *StateStore) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *StateStore) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_StateStore.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *StateStore) XXX_Merge(src proto.Message) {
	xxx_messageInfo_StateStore.Merge(m, src)
}
func (m *StateStore) XXX_Size() int {
	return m.Size()
}
func (m *StateStore) XXX_DiscardUnknown() {
	xxx_messageInfo_StateStore.DiscardUnknown(m)
}

var xxx_messageInfo_StateStore proto.InternalMessageInfo

type RecoveryState struct {
	Config  []byte      `protobuf:"bytes,1,opt,name=config,proto3" json:"config,omitempty"`
	Store   *StateStore `protobuf:"bytes,2,opt,name=store,proto3" json:"store,omitempty"`
	Snap    *Snapshot   `protobuf:"bytes,3,opt,name=snap,proto3" json:"snap,omitempty"`
	Entries []*Entry    `protobuf:"bytes,4,rep,name=entries,proto3" json:"entries,omitempty"`
}

func (m *RecoveryState) Reset()         { *m = RecoveryState{} }
func (m *RecoveryState) String() string { return proto.CompactTextString(m) }
func (*RecoveryState) ProtoMessage()    {}
func (*RecoveryState) Descriptor() ([]byte, []int) {
	return fileDescriptor_afe3c49a0352b568, []int{23}
}
func (m *RecoveryState) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *RecoveryState) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_RecoveryState.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *RecoveryState) XXX_Merge(src proto.Message) {
	xxx_messageInfo_RecoveryState.Merge(m, src)
}
func (m *RecoveryState) XXX_Size() int {
	return m.Size()
}
func (m *RecoveryState) XXX_DiscardUnknown() {
	xxx_messageInfo_RecoveryState.DiscardUnknown(m)
}

var xxx_messageInfo_RecoveryState proto.InternalMessageInfo

type SignedInitialState struct {
	InitialState []byte `protobuf:"bytes,1,opt,name=initialState,proto3" json:"initialState,omitempty"`
	Signature    []byte `protobuf:"bytes,2,opt,name=signature,proto3" json:"signature,omitempty"`
	PublicKey    []byte `protobuf:"bytes,3,opt,name=publicKey,proto3" json:"publicKey,omitempty"`
}

func (m *SignedInitialState) Reset()         { *m = SignedInitialState{} }
func (m *SignedInitialState) String() string { return proto.CompactTextString(m) }
func (*SignedInitialState) ProtoMessage()    {}
func (*SignedInitialState) Descriptor() ([]byte, []int) {
	return fileDescriptor_afe3c49a0352b568, []int{24}
}
func (m *SignedInitialState) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *SignedInitialState) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_SignedInitialState.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *SignedInitialState) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SignedInitialState.Merge(m, src)
}
func (m *SignedInitialState) XXX_Size() int {
	return m.Size()
}
func (m *SignedInitialState) XXX_DiscardUnknown() {
	xxx_messageInfo_SignedInitialState.DiscardUnknown(m)
}

var xxx_messageInfo_SignedInitialState proto.InternalMessageInfo

func init() {
	proto.RegisterEnum("raft.MsgType", MsgType_name, MsgType_value)
	proto.RegisterEnum("raft.State", State_name, State_value)
	proto.RegisterType((*StateSet)(nil), "raft.StateSet")
	proto.RegisterType((*DataSet)(nil), "raft.DataSet")
	proto.RegisterType((*Timer)(nil), "raft.Timer")
	proto.RegisterType((*Leadership)(nil), "raft.Leadership")
	proto.RegisterType((*Conf)(nil), "raft.Conf")
	proto.RegisterType((*ConfChange)(nil), "raft.ConfChange")
	proto.RegisterType((*Entry)(nil), "raft.Entry")
	proto.RegisterType((*BlockMetadata)(nil), "raft.BlockMetadata")
	proto.RegisterType((*Certificate)(nil), "raft.Certificate")
	proto.RegisterType((*Msg)(nil), "raft.Msg")
	proto.RegisterType((*InitConfig)(nil), "raft.InitConfig")
	proto.RegisterType((*HeartbeatResponse)(nil), "raft.HeartbeatResponse")
	proto.RegisterType((*Proposal)(nil), "raft.Proposal")
	proto.RegisterType((*AppendEntries)(nil), "raft.AppendEntries")
	proto.RegisterType((*Snapshot)(nil), "raft.Snapshot")
	proto.RegisterType((*BlockRange)(nil), "raft.BlockRange")
	proto.RegisterType((*AppendReject)(nil), "raft.AppendReject")
	proto.RegisterType((*AppendAccept)(nil), "raft.AppendAccept")
	proto.RegisterType((*Vote)(nil), "raft.Vote")
	proto.RegisterType((*VoteResponse)(nil), "raft.VoteResponse")
	proto.RegisterType((*Heartbeat)(nil), "raft.Heartbeat")
	proto.RegisterType((*SnapshotStatus)(nil), "raft.SnapshotStatus")
	proto.RegisterType((*StateStore)(nil), "raft.StateStore")
	proto.RegisterType((*RecoveryState)(nil), "raft.RecoveryState")
	proto.RegisterType((*SignedInitialState)(nil), "raft.SignedInitialState")
}

func init() { proto.RegisterFile("consensus/raft/raft2.proto", fileDescriptor_afe3c49a0352b568) }

var fileDescriptor_afe3c49a0352b568 = []byte{
	// 1580 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0x8c, 0x57, 0xcd, 0x72, 0x1c, 0x49,
	0x11, 0x9e, 0x9e, 0xe9, 0xf9, 0xcb, 0xf9, 0x51, 0xab, 0x30, 0xa6, 0xc3, 0x38, 0x26, 0xe4, 0x06,
	0x36, 0x84, 0x16, 0x24, 0x5b, 0x1b, 0xc1, 0x81, 0xe5, 0x80, 0x25, 0x16, 0xb4, 0xc1, 0x1a, 0x1c,
	0x25, 0xb1, 0x07, 0x82, 0x08, 0x47, 0x4d, 0x4f, 0xa9, 0xa7, 0x61, 0xa6, 0xaa, 0x5d, 0x55, 0x63,
	0xef, 0xdc, 0x79, 0x00, 0xae, 0xf0, 0x00, 0xdc, 0x38, 0xf3, 0x0a, 0x7b, 0xf4, 0x11, 0x6e, 0xac,
	0x1d, 0xc1, 0x73, 0x6c, 0x64, 0x55, 0xf5, 0xcf, 0xc8, 0xb2, 0xc3, 0x17, 0xa9, 0x32, 0xf3, 0xab,
	0xec, 0xac, 0xfc, 0xf9, 0xaa, 0x06, 0xee, 0xa5, 0x52, 0x68, 0x2e, 0xf4, 0x46, 0x9f, 0x28, 0x76,
	0x6d, 0xec, 0x9f, 0xd3, 0xe3, 0x42, 0x49, 0x23, 0x49, 0x88, 0xc2, 0xbd, 0x3b, 0x99, 0xcc, 0xa4,
	0x55, 0x9c, 0xe0, 0xca, 0xd9, 0xee, 0xdd, 0xad, 0xf7, 0xa5, 0x52, 0x5c, 0xe7, 0x99, 0xd3, 0x27,
	0xff, 0x0a, 0x60, 0x70, 0x69, 0x98, 0xe1, 0x97, 0xdc, 0x90, 0x07, 0xd0, 0x35, 0xf9, 0x9a, 0xab,
	0x38, 0x38, 0x08, 0x0e, 0x47, 0xa7, 0xa3, 0x63, 0x74, 0x78, 0x7c, 0x85, 0x2a, 0xea, 0x2c, 0xe4,
	0x21, 0xc0, 0x8a, 0xb3, 0x05, 0x57, 0x7a, 0x99, 0x17, 0x71, 0xdb, 0xe2, 0x22, 0x87, 0xfb, 0xa2,
	0xd2, 0xd3, 0x06, 0x86, 0x10, 0x08, 0x0d, 0x57, 0xeb, 0xb8, 0x73, 0x10, 0x1c, 0x86, 0xd4, 0xae,
	0xc9, 0x7d, 0x18, 0xae, 0x98, 0x36, 0x9f, 0x8b, 0x05, 0xff, 0x2a, 0x0e, 0xad, 0xa1, 0x56, 0x90,
	0x7b, 0x30, 0x30, 0x8a, 0x09, 0x7d, 0xcd, 0x55, 0xdc, 0x3d, 0x08, 0x0e, 0x07, 0xb4, 0x92, 0x93,
	0x7f, 0xb7, 0xa1, 0xff, 0x2b, 0x66, 0x18, 0x86, 0xfb, 0x10, 0x40, 0xdb, 0xd0, 0x8d, 0x54, 0xdc,
	0xc7, 0xec, 0x63, 0xb9, 0xac, 0xf4, 0xb4, 0x81, 0x21, 0x3f, 0x82, 0x3e, 0x17, 0x46, 0xe5, 0x5c,
	0xc7, 0xed, 0x83, 0x4e, 0x7d, 0xc4, 0xcf, 0x84, 0x51, 0x5b, 0x5a, 0xda, 0xc8, 0x11, 0x0c, 0xb4,
	0x60, 0x85, 0x5e, 0x4a, 0x63, 0xc3, 0x1e, 0x9d, 0x4e, 0xbd, 0x5b, 0xaf, 0xa5, 0x95, 0x9d, 0x7c,
	0x0c, 0xfd, 0x35, 0xd7, 0x9a, 0x65, 0x3c, 0x0e, 0xad, 0xcb, 0x7d, 0x07, 0x3d, 0xe7, 0xca, 0xe4,
	0xd7, 0x79, 0xca, 0x0c, 0xa7, 0x25, 0x02, 0x73, 0xa1, 0xb7, 0x22, 0xf5, 0xa7, 0xb2, 0x6b, 0xcc,
	0x85, 0xe2, 0x6b, 0x96, 0x8b, 0x5c, 0x64, 0x71, 0xcf, 0xe5, 0xa2, 0x52, 0xa0, 0x15, 0x33, 0x96,
	0x0b, 0x66, 0x78, 0xdc, 0xb7, 0xdb, 0x6a, 0x05, 0x39, 0x82, 0x28, 0xdd, 0x28, 0xc5, 0x85, 0x39,
	0x97, 0xe2, 0xda, 0xa5, 0x73, 0x60, 0x5d, 0xbc, 0xa5, 0x4f, 0x3e, 0x85, 0xae, 0xad, 0x24, 0x89,
	0xa1, 0x9f, 0x6b, 0xca, 0x35, 0x37, 0x36, 0x67, 0x03, 0x5a, 0x8a, 0x68, 0xc1, 0x2a, 0xcb, 0x8d,
	0xb1, 0x95, 0x0d, 0x69, 0x29, 0x26, 0xbf, 0x01, 0xa8, 0xcb, 0x4b, 0xee, 0x42, 0xcf, 0x15, 0xd8,
	0x3a, 0x18, 0x52, 0x2f, 0x61, 0xff, 0xd8, 0x64, 0xdb, 0xdd, 0xd3, 0x32, 0xb9, 0xb6, 0x16, 0xd4,
	0x59, 0x92, 0x9f, 0x43, 0x88, 0x21, 0xa1, 0x8b, 0x17, 0xd2, 0x70, 0xa5, 0xe3, 0xe0, 0xa0, 0x83,
	0x2e, 0x9c, 0x84, 0xb5, 0x5f, 0x71, 0xa6, 0x04, 0x5a, 0xda, 0xd6, 0x52, 0xc9, 0xc9, 0x5f, 0x03,
	0x00, 0xdc, 0x7c, 0xbe, 0x64, 0x22, 0xe3, 0xe4, 0xc7, 0xd0, 0x9d, 0xaf, 0x64, 0xfa, 0x17, 0x5f,
	0xf9, 0xef, 0xb8, 0xaf, 0x9d, 0xa1, 0xea, 0x09, 0x37, 0x6c, 0xc1, 0x0c, 0xa3, 0x0e, 0x41, 0x1e,
	0x40, 0x5b, 0x16, 0x3e, 0xaa, 0xfd, 0xe3, 0x6a, 0x14, 0x8e, 0xd1, 0xdb, 0xef, 0x0b, 0xda, 0x96,
	0x05, 0x39, 0x84, 0x50, 0xc8, 0x05, 0xf7, 0xf5, 0xbe, 0xb3, 0x0b, 0xd2, 0x5c, 0x18, 0xae, 0xa8,
	0x45, 0x24, 0xff, 0x0d, 0xa0, 0x6b, 0x1b, 0xa6, 0x6a, 0xed, 0xa0, 0xd1, 0xda, 0x77, 0xa0, 0x9b,
	0xdb, 0x3a, 0xb8, 0x0c, 0x3a, 0x81, 0x7c, 0x5c, 0xc6, 0xda, 0x79, 0x67, 0xac, 0x17, 0xad, 0x32,
	0xda, 0x53, 0x80, 0xb4, 0x3a, 0xa6, 0x1d, 0x8f, 0xaa, 0xaf, 0xeb, 0xe3, 0x5f, 0xb4, 0x68, 0x03,
	0x85, 0x7d, 0xa2, 0xf3, 0x4c, 0x30, 0xb3, 0x51, 0xdc, 0xb6, 0xd7, 0x98, 0xd6, 0x0a, 0x32, 0x03,
	0xb0, 0xae, 0xcf, 0xb6, 0x86, 0x6b, 0xdb, 0x64, 0x63, 0xda, 0xd0, 0x9c, 0xf5, 0xa1, 0xfb, 0x82,
	0xad, 0x36, 0x3c, 0xf9, 0x14, 0x26, 0x3b, 0x41, 0x61, 0x9d, 0x96, 0x3c, 0xcf, 0x96, 0xc6, 0x1f,
	0xd2, 0x4b, 0x78, 0xf4, 0x25, 0xd3, 0x4b, 0x7b, 0xca, 0x31, 0xb5, 0xeb, 0xe4, 0x13, 0x18, 0x35,
	0xba, 0x9e, 0x44, 0xd0, 0x59, 0xeb, 0xcc, 0xee, 0x1b, 0x53, 0x5c, 0xda, 0xf6, 0xcf, 0x33, 0x51,
	0x6e, 0xc2, 0x75, 0xf2, 0xff, 0x10, 0x3a, 0x4f, 0x74, 0x86, 0x79, 0xcb, 0x94, 0xdc, 0x14, 0xf1,
	0xd8, 0xb6, 0x94, 0x13, 0xc8, 0x03, 0x08, 0xcd, 0xb6, 0x70, 0xc3, 0x3d, 0x3d, 0x9d, 0xb8, 0x24,
	0x3c, 0xd1, 0xd9, 0xd5, 0xb6, 0xe0, 0xd4, 0x9a, 0xd0, 0xe9, 0xb5, 0x92, 0x6b, 0xeb, 0x74, 0x48,
	0xed, 0x9a, 0x4c, 0xa1, 0x6d, 0xa4, 0xcd, 0xf5, 0x90, 0xb6, 0x8d, 0xac, 0x0a, 0x35, 0x69, 0x14,
	0xea, 0xa7, 0xd0, 0x63, 0x45, 0xc1, 0xc5, 0xc2, 0x67, 0xd8, 0xd7, 0xe4, 0xb1, 0xd5, 0x7d, 0xe6,
	0x98, 0xe0, 0xa2, 0x45, 0x3d, 0x88, 0xfc, 0x04, 0x7a, 0x2c, 0x4d, 0x0b, 0x6e, 0x6c, 0x76, 0x47,
	0xa7, 0xa4, 0x09, 0x7f, 0x9c, 0xa6, 0xbc, 0x30, 0x16, 0x6d, 0x31, 0x88, 0x56, 0xfc, 0xcf, 0x3c,
	0x35, 0x36, 0xd9, 0x37, 0xd0, 0xd4, 0x5a, 0x10, 0xed, 0x30, 0xe4, 0x00, 0x42, 0x6c, 0x7f, 0x3b,
	0xdf, 0xa3, 0x53, 0x70, 0xd8, 0x2f, 0xa5, 0xc1, 0x22, 0x5b, 0x0b, 0x79, 0x08, 0x03, 0xfc, 0x4f,
	0xb9, 0x2e, 0xec, 0x80, 0x57, 0x1e, 0xbf, 0xf4, 0x5a, 0xec, 0xd1, 0x8b, 0x16, 0xad, 0x50, 0xd8,
	0xf2, 0xcb, 0x79, 0x3c, 0xb4, 0xd8, 0x3d, 0x87, 0xbd, 0xe0, 0x4c, 0x99, 0x39, 0x67, 0xf8, 0xe9,
	0xf6, 0x72, 0x4e, 0x1e, 0x41, 0x6f, 0x39, 0xb7, 0x2e, 0xa7, 0x16, 0xf6, 0xbd, 0x1b, 0xb0, 0x86,
	0x5f, 0x0f, 0x24, 0x3f, 0x84, 0x10, 0x99, 0x2f, 0x86, 0xdb, 0x58, 0x11, 0xa3, 0x45, 0x2b, 0xf9,
	0x19, 0x00, 0xfe, 0xc7, 0xc1, 0xdf, 0xe8, 0x78, 0xe4, 0x27, 0x6a, 0x07, 0xeb, 0x6c, 0xd8, 0xc4,
	0x35, 0x12, 0xbd, 0x17, 0x4a, 0x16, 0xf1, 0x5e, 0xd3, 0xfb, 0x53, 0x25, 0x0b, 0xa9, 0xd9, 0x0a,
	0xbd, 0xa3, 0x95, 0x1c, 0x41, 0xcf, 0x5d, 0x61, 0x71, 0xd4, 0x1c, 0x8d, 0xcf, 0x45, 0x6e, 0xd9,
	0x2e, 0xcf, 0x30, 0x5e, 0x87, 0x38, 0x1b, 0x42, 0xbf, 0x60, 0xdb, 0x95, 0x64, 0x8b, 0x84, 0x03,
	0xd4, 0x10, 0xcf, 0x08, 0xc1, 0xfb, 0x18, 0xe1, 0x3e, 0x0c, 0x73, 0x91, 0xdb, 0x48, 0xb9, 0x6f,
	0xd9, 0x5a, 0xd1, 0x18, 0x8c, 0x4e, 0x73, 0x30, 0x92, 0x47, 0xb0, 0xff, 0x56, 0x02, 0x77, 0xef,
	0xbb, 0xe0, 0xc6, 0x7d, 0x97, 0x3c, 0x82, 0x41, 0x79, 0xc8, 0xe6, 0x0d, 0x15, 0xbc, 0xfb, 0x86,
	0x4a, 0xbe, 0x82, 0xc9, 0x4e, 0xa3, 0x7e, 0xe0, 0xbe, 0x6a, 0x10, 0xda, 0xb7, 0x31, 0x56, 0xa7,
	0xc9, 0x58, 0x77, 0x31, 0xcb, 0xeb, 0x75, 0x6e, 0xfc, 0xfd, 0xec, 0xa5, 0xe4, 0xef, 0xf8, 0x60,
	0x28, 0x2f, 0xbf, 0x0f, 0x27, 0xc0, 0x19, 0x84, 0x58, 0x12, 0xcf, 0x7f, 0x50, 0xb3, 0x19, 0xb5,
	0x7a, 0xf2, 0x11, 0x74, 0xd5, 0xdb, 0x74, 0x67, 0xb9, 0x88, 0xa2, 0x9e, 0x3a, 0x33, 0xf9, 0x3e,
	0x0c, 0x2d, 0x6f, 0x3d, 0xd3, 0xfc, 0xb9, 0xe7, 0xb9, 0x81, 0x55, 0x5c, 0xf2, 0xe7, 0xc9, 0x9f,
	0x00, 0xea, 0x1d, 0x18, 0xc8, 0x9c, 0x67, 0xb9, 0xf0, 0xd1, 0x39, 0x01, 0x59, 0x09, 0x67, 0xde,
	0x05, 0x87, 0x4b, 0xf2, 0x11, 0xec, 0xd9, 0x18, 0x9f, 0x19, 0xf9, 0xac, 0x2a, 0x69, 0xe7, 0x30,
	0xa4, 0x13, 0xab, 0xbe, 0x92, 0x17, 0xae, 0xb2, 0x17, 0x30, 0x6e, 0xce, 0x2f, 0x5e, 0x55, 0xac,
	0x28, 0x9a, 0x35, 0xad, 0xe4, 0xdd, 0x82, 0xb7, 0x6f, 0x16, 0xfc, 0xb8, 0xf4, 0xe4, 0x78, 0x03,
	0xe9, 0x79, 0xcd, 0x4c, 0xba, 0x6c, 0xfa, 0x6a, 0x68, 0x92, 0x2b, 0x08, 0x71, 0xce, 0x6f, 0x4d,
	0xf7, 0x7b, 0xbf, 0x64, 0xaf, 0x53, 0xa6, 0xcd, 0x55, 0xfd, 0x00, 0xab, 0xe4, 0xe4, 0x10, 0xc6,
	0x4d, 0xf6, 0xc0, 0xdb, 0x3f, 0x53, 0x4c, 0x18, 0xbe, 0x28, 0xdf, 0x05, 0x5e, 0x4c, 0x7e, 0x00,
	0xc3, 0xaa, 0xa7, 0x1b, 0x8d, 0x11, 0xec, 0x34, 0xc6, 0x2f, 0x60, 0xba, 0x3b, 0xdc, 0x18, 0xee,
	0x42, 0x0a, 0x37, 0x3b, 0x03, 0x6a, 0xd7, 0xb8, 0xdb, 0x13, 0xa3, 0xfb, 0x86, 0x97, 0x92, 0x2f,
	0x00, 0xea, 0x37, 0xdb, 0xad, 0x07, 0x25, 0x9e, 0x24, 0x3d, 0xcf, 0x5b, 0x5a, 0xac, 0x63, 0xe9,
	0xec, 0xc4, 0xf2, 0x8f, 0x00, 0x26, 0x94, 0xa7, 0xf2, 0x05, 0x57, 0xdb, 0x6a, 0x5c, 0x3d, 0x69,
	0xb8, 0xfb, 0xc8, 0x4b, 0xd8, 0x77, 0xda, 0x3e, 0x1f, 0xdb, 0xef, 0x78, 0x3e, 0x3a, 0x33, 0x49,
	0x3c, 0xf1, 0xdd, 0xfe, 0x1c, 0x74, 0xb4, 0xd7, 0x98, 0xc1, 0xf0, 0x3d, 0xb3, 0x6b, 0x80, 0x5c,
	0xe6, 0x99, 0xe0, 0x0b, 0xa4, 0xa3, 0x9c, 0xad, 0x5c, 0x80, 0x09, 0x8c, 0xf3, 0x86, 0xec, 0xc3,
	0xdc, 0xd1, 0xed, 0x5e, 0xf2, 0xed, 0x9b, 0x97, 0xfc, 0x7d, 0x18, 0x16, 0x9b, 0xf9, 0x2a, 0x4f,
	0x7f, 0xcb, 0xb7, 0x36, 0xce, 0x31, 0xad, 0x15, 0x47, 0xff, 0x6c, 0x43, 0xdf, 0x5f, 0x9c, 0x04,
	0xa0, 0xe7, 0xfa, 0x2f, 0x6a, 0x91, 0x09, 0x0c, 0x1f, 0x17, 0x85, 0x6b, 0xe9, 0x28, 0xf0, 0xa2,
	0xeb, 0xcb, 0x08, 0xc8, 0x08, 0xfa, 0xae, 0x47, 0x9e, 0x47, 0x6d, 0x32, 0x86, 0x41, 0xd9, 0x30,
	0x51, 0x87, 0x4c, 0x01, 0x9e, 0x2a, 0x5e, 0x5a, 0x43, 0xb2, 0x07, 0xa3, 0x4a, 0xd6, 0x45, 0xd4,
	0x25, 0x11, 0x8c, 0x1b, 0x4c, 0xf8, 0x3c, 0xea, 0x91, 0x7d, 0x98, 0xec, 0x70, 0x63, 0xd4, 0x27,
	0x03, 0x08, 0x31, 0x8b, 0xd1, 0x00, 0xbd, 0xe3, 0xea, 0x92, 0x0b, 0x13, 0x45, 0xe8, 0xfd, 0xca,
	0xbd, 0x3d, 0x7f, 0x27, 0x5f, 0x46, 0x43, 0x42, 0x60, 0x7a, 0xe5, 0x7f, 0x03, 0xb8, 0x87, 0x68,
	0x34, 0x26, 0xdf, 0x85, 0xfd, 0x52, 0x87, 0x4c, 0x62, 0xd3, 0x1c, 0x4d, 0x50, 0x8d, 0x99, 0xa5,
	0xec, 0xda, 0x9c, 0x97, 0xbc, 0x1e, 0x4d, 0x51, 0x7d, 0x69, 0x64, 0xb1, 0xab, 0xde, 0xc3, 0xb0,
	0xff, 0x20, 0x14, 0x67, 0xe9, 0x92, 0xcd, 0x57, 0x3c, 0x1a, 0x1d, 0x9d, 0x41, 0xd7, 0x65, 0x7b,
	0x0c, 0x83, 0x5f, 0xcb, 0xd5, 0x4a, 0xbe, 0xe4, 0xca, 0xe5, 0xe9, 0x9c, 0x89, 0x45, 0xbe, 0x60,
	0x86, 0x47, 0x01, 0x1e, 0xee, 0xa9, 0xe2, 0xb5, 0xa6, 0x8d, 0x49, 0xf5, 0x91, 0x75, 0xce, 0xe6,
	0x5f, 0x7f, 0x33, 0x6b, 0xbd, 0xfa, 0x66, 0xd6, 0xfa, 0xfa, 0xf5, 0x2c, 0x78, 0xf5, 0x7a, 0x16,
	0xfc, 0xef, 0xf5, 0x2c, 0xf8, 0xdb, 0x9b, 0x59, 0xeb, 0xd5, 0x9b, 0x59, 0xeb, 0x3f, 0x6f, 0x66,
	0xad, 0x3f, 0xfe, 0x32, 0xcb, 0xcd, 0xf1, 0x72, 0xc3, 0x5e, 0xf2, 0xfc, 0x38, 0x95, 0xeb, 0x93,
	0x42, 0xe6, 0x5a, 0x63, 0x58, 0x4c, 0xa5, 0xcb, 0x93, 0x97, 0x39, 0x17, 0x5c, 0xa5, 0x4b, 0x96,
	0x8b, 0x13, 0xf7, 0x53, 0xee, 0xc6, 0xcf, 0xbe, 0x62, 0x3e, 0xef, 0x59, 0xc3, 0x27, 0xdf, 0x06,
	0x00, 0x00, 0xff, 0xff, 0x6f, 0x52, 0x20, 0xb8, 0x12, 0x0e, 0x00, 0x00,
}

func (m *StateSet) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *StateSet) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *StateSet) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Transfer {
		i--
		if m.Transfer {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x28
	}
	if m.LastIndex != 0 {
		i = encodeVarintRaft2(dAtA, i, uint64(m.LastIndex))
		i--
		dAtA[i] = 0x20
	}
	if m.Term != 0 {
		i = encodeVarintRaft2(dAtA, i, uint64(m.Term))
		i--
		dAtA[i] = 0x18
	}
	if m.Leadership != nil {
		{
			size, err := m.Leadership.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintRaft2(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	if m.Timer != nil {
		{
			size, err := m.Timer.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintRaft2(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *DataSet) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *DataSet) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *DataSet) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.CurrentConfIndex != 0 {
		i = encodeVarintRaft2(dAtA, i, uint64(m.CurrentConfIndex))
		i--
		dAtA[i] = 0x40
	}
	if m.Terminate {
		i--
		if m.Terminate {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x38
	}
	if m.Remaining != 0 {
		i = encodeVarintRaft2(dAtA, i, uint64(m.Remaining))
		i--
		dAtA[i] = 0x30
	}
	if m.Sync {
		i--
		if m.Sync {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x28
	}
	if len(m.Message) > 0 {
		for iNdEx := len(m.Message) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Message[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintRaft2(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x22
		}
	}
	if m.Snapshot != nil {
		{
			size, err := m.Snapshot.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintRaft2(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1a
	}
	if len(m.Entries) > 0 {
		for iNdEx := len(m.Entries) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Entries[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintRaft2(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x12
		}
	}
	if m.StateStore != nil {
		{
			size, err := m.StateStore.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintRaft2(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *Timer) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Timer) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Timer) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Timeout != 0 {
		i = encodeVarintRaft2(dAtA, i, uint64(m.Timeout))
		i--
		dAtA[i] = 0x10
	}
	if m.IsReset {
		i--
		if m.IsReset {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *Leadership) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Leadership) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Leadership) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.State != 0 {
		i = encodeVarintRaft2(dAtA, i, uint64(m.State))
		i--
		dAtA[i] = 0x10
	}
	if len(m.Leader) > 0 {
		i -= len(m.Leader)
		copy(dAtA[i:], m.Leader)
		i = encodeVarintRaft2(dAtA, i, uint64(len(m.Leader)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *Conf) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Conf) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Conf) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Learners) > 0 {
		for iNdEx := len(m.Learners) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.Learners[iNdEx])
			copy(dAtA[i:], m.Learners[iNdEx])
			i = encodeVarintRaft2(dAtA, i, uint64(len(m.Learners[iNdEx])))
			i--
			dAtA[i] = 0x12
		}
	}
	if len(m.Voters) > 0 {
		for iNdEx := len(m.Voters) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.Voters[iNdEx])
			copy(dAtA[i:], m.Voters[iNdEx])
			i = encodeVarintRaft2(dAtA, i, uint64(len(m.Voters[iNdEx])))
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *ConfChange) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ConfChange) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ConfChange) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Node != nil {
		{
			size, err := m.Node.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintRaft2(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1a
	}
	if m.Op != 0 {
		i = encodeVarintRaft2(dAtA, i, uint64(m.Op))
		i--
		dAtA[i] = 0x10
	}
	if m.Block != nil {
		{
			size, err := m.Block.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintRaft2(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *Entry) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Entry) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Entry) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.BlockBytes) > 0 {
		i -= len(m.BlockBytes)
		copy(dAtA[i:], m.BlockBytes)
		i = encodeVarintRaft2(dAtA, i, uint64(len(m.BlockBytes)))
		i--
		dAtA[i] = 0x32
	}
	if len(m.Signature) > 0 {
		i -= len(m.Signature)
		copy(dAtA[i:], m.Signature)
		i = encodeVarintRaft2(dAtA, i, uint64(len(m.Signature)))
		i--
		dAtA[i] = 0x2a
	}
	if m.Value != nil {
		{
			size := m.Value.Size()
			i -= size
			if _, err := m.Value.MarshalTo(dAtA[i:]); err != nil {
				return 0, err
			}
		}
	}
	if m.Index != 0 {
		i = encodeVarintRaft2(dAtA, i, uint64(m.Index))
		i--
		dAtA[i] = 0x10
	}
	if m.Term != 0 {
		i = encodeVarintRaft2(dAtA, i, uint64(m.Term))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *Entry_Block) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Entry_Block) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.Block != nil {
		{
			size, err := m.Block.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintRaft2(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1a
	}
	return len(dAtA) - i, nil
}
func (m *Entry_ConfChange) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Entry_ConfChange) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.ConfChange != nil {
		{
			size, err := m.ConfChange.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintRaft2(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x22
	}
	return len(dAtA) - i, nil
}
func (m *BlockMetadata) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *BlockMetadata) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *BlockMetadata) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Hash) > 0 {
		i -= len(m.Hash)
		copy(dAtA[i:], m.Hash)
		i = encodeVarintRaft2(dAtA, i, uint64(len(m.Hash)))
		i--
		dAtA[i] = 0x12
	}
	if m.Height != 0 {
		i = encodeVarintRaft2(dAtA, i, uint64(m.Height))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *Certificate) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Certificate) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Certificate) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Sign) > 0 {
		i -= len(m.Sign)
		copy(dAtA[i:], m.Sign)
		i = encodeVarintRaft2(dAtA, i, uint64(len(m.Sign)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Msg) > 0 {
		i -= len(m.Msg)
		copy(dAtA[i:], m.Msg)
		i = encodeVarintRaft2(dAtA, i, uint64(len(m.Msg)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *Msg) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Msg) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Msg) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Payload != nil {
		{
			size := m.Payload.Size()
			i -= size
			if _, err := m.Payload.MarshalTo(dAtA[i:]); err != nil {
				return 0, err
			}
		}
	}
	if m.Term != 0 {
		i = encodeVarintRaft2(dAtA, i, uint64(m.Term))
		i--
		dAtA[i] = 0x68
	}
	if len(m.Group) > 0 {
		i -= len(m.Group)
		copy(dAtA[i:], m.Group)
		i = encodeVarintRaft2(dAtA, i, uint64(len(m.Group)))
		i--
		dAtA[i] = 0x62
	}
	if len(m.To) > 0 {
		i -= len(m.To)
		copy(dAtA[i:], m.To)
		i = encodeVarintRaft2(dAtA, i, uint64(len(m.To)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.From) > 0 {
		i -= len(m.From)
		copy(dAtA[i:], m.From)
		i = encodeVarintRaft2(dAtA, i, uint64(len(m.From)))
		i--
		dAtA[i] = 0x12
	}
	if m.Type != 0 {
		i = encodeVarintRaft2(dAtA, i, uint64(m.Type))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *Msg_Append) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Msg_Append) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.Append != nil {
		{
			size, err := m.Append.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintRaft2(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x22
	}
	return len(dAtA) - i, nil
}
func (m *Msg_Accpet) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Msg_Accpet) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.Accpet != nil {
		{
			size, err := m.Accpet.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintRaft2(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x2a
	}
	return len(dAtA) - i, nil
}
func (m *Msg_Reject) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Msg_Reject) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.Reject != nil {
		{
			size, err := m.Reject.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintRaft2(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x32
	}
	return len(dAtA) - i, nil
}
func (m *Msg_Vote) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Msg_Vote) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.Vote != nil {
		{
			size, err := m.Vote.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintRaft2(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x3a
	}
	return len(dAtA) - i, nil
}
func (m *Msg_VoteResp) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Msg_VoteResp) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.VoteResp != nil {
		{
			size, err := m.VoteResp.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintRaft2(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x42
	}
	return len(dAtA) - i, nil
}
func (m *Msg_Hb) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Msg_Hb) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.Hb != nil {
		{
			size, err := m.Hb.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintRaft2(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x4a
	}
	return len(dAtA) - i, nil
}
func (m *Msg_Snap) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Msg_Snap) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.Snap != nil {
		{
			size, err := m.Snap.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintRaft2(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x52
	}
	return len(dAtA) - i, nil
}
func (m *Msg_SnapStatus) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Msg_SnapStatus) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.SnapStatus != nil {
		{
			size, err := m.SnapStatus.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintRaft2(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x5a
	}
	return len(dAtA) - i, nil
}
func (m *Msg_HbResp) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Msg_HbResp) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.HbResp != nil {
		{
			size, err := m.HbResp.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintRaft2(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x72
	}
	return len(dAtA) - i, nil
}
func (m *Msg_Prop) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Msg_Prop) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.Prop != nil {
		{
			size, err := m.Prop.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintRaft2(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x7a
	}
	return len(dAtA) - i, nil
}
func (m *Msg_Config) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Msg_Config) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.Config != nil {
		{
			size, err := m.Config.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintRaft2(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0x82
	}
	return len(dAtA) - i, nil
}
func (m *InitConfig) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *InitConfig) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *InitConfig) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Height != 0 {
		i = encodeVarintRaft2(dAtA, i, uint64(m.Height))
		i--
		dAtA[i] = 0x18
	}
	if len(m.InitState) > 0 {
		i -= len(m.InitState)
		copy(dAtA[i:], m.InitState)
		i = encodeVarintRaft2(dAtA, i, uint64(len(m.InitState)))
		i--
		dAtA[i] = 0x12
	}
	if m.Op != 0 {
		i = encodeVarintRaft2(dAtA, i, uint64(m.Op))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *HeartbeatResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *HeartbeatResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *HeartbeatResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.LastIndex != 0 {
		i = encodeVarintRaft2(dAtA, i, uint64(m.LastIndex))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *Proposal) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Proposal) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Proposal) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Entries) > 0 {
		for iNdEx := len(m.Entries) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Entries[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintRaft2(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *AppendEntries) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *AppendEntries) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *AppendEntries) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Commit != 0 {
		i = encodeVarintRaft2(dAtA, i, uint64(m.Commit))
		i--
		dAtA[i] = 0x20
	}
	if m.Index != 0 {
		i = encodeVarintRaft2(dAtA, i, uint64(m.Index))
		i--
		dAtA[i] = 0x18
	}
	if m.Term != 0 {
		i = encodeVarintRaft2(dAtA, i, uint64(m.Term))
		i--
		dAtA[i] = 0x10
	}
	if len(m.Entries) > 0 {
		for iNdEx := len(m.Entries) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Entries[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintRaft2(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *Snapshot) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Snapshot) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Snapshot) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.BlockSeq) > 0 {
		i -= len(m.BlockSeq)
		copy(dAtA[i:], m.BlockSeq)
		i = encodeVarintRaft2(dAtA, i, uint64(len(m.BlockSeq)))
		i--
		dAtA[i] = 0x2a
	}
	if m.Range != nil {
		{
			size, err := m.Range.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintRaft2(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x22
	}
	if m.Conf != nil {
		{
			size, err := m.Conf.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintRaft2(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1a
	}
	if m.Index != 0 {
		i = encodeVarintRaft2(dAtA, i, uint64(m.Index))
		i--
		dAtA[i] = 0x10
	}
	if m.Term != 0 {
		i = encodeVarintRaft2(dAtA, i, uint64(m.Term))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *BlockRange) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *BlockRange) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *BlockRange) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.IndexToHeight) > 0 {
		dAtA23 := make([]byte, len(m.IndexToHeight)*10)
		var j22 int
		for _, num := range m.IndexToHeight {
			for num >= 1<<7 {
				dAtA23[j22] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j22++
			}
			dAtA23[j22] = uint8(num)
			j22++
		}
		i -= j22
		copy(dAtA[i:], dAtA23[:j22])
		i = encodeVarintRaft2(dAtA, i, uint64(j22))
		i--
		dAtA[i] = 0x1a
	}
	if m.End != 0 {
		i = encodeVarintRaft2(dAtA, i, uint64(m.End))
		i--
		dAtA[i] = 0x10
	}
	if m.Begin != 0 {
		i = encodeVarintRaft2(dAtA, i, uint64(m.Begin))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *AppendReject) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *AppendReject) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *AppendReject) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.LastIndex != 0 {
		i = encodeVarintRaft2(dAtA, i, uint64(m.LastIndex))
		i--
		dAtA[i] = 0x10
	}
	if m.AppIndex != 0 {
		i = encodeVarintRaft2(dAtA, i, uint64(m.AppIndex))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *AppendAccept) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *AppendAccept) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *AppendAccept) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.MatchIndex != 0 {
		i = encodeVarintRaft2(dAtA, i, uint64(m.MatchIndex))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *Vote) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Vote) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Vote) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.LastTerm != 0 {
		i = encodeVarintRaft2(dAtA, i, uint64(m.LastTerm))
		i--
		dAtA[i] = 0x18
	}
	if m.LastIndex != 0 {
		i = encodeVarintRaft2(dAtA, i, uint64(m.LastIndex))
		i--
		dAtA[i] = 0x10
	}
	if m.Term != 0 {
		i = encodeVarintRaft2(dAtA, i, uint64(m.Term))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *VoteResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *VoteResponse) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *VoteResponse) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Granted {
		i--
		if m.Granted {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *Heartbeat) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Heartbeat) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Heartbeat) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Commit != 0 {
		i = encodeVarintRaft2(dAtA, i, uint64(m.Commit))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *SnapshotStatus) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SnapshotStatus) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *SnapshotStatus) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Done {
		i--
		if m.Done {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x10
	}
	if m.Reject {
		i--
		if m.Reject {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *StateStore) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *StateStore) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *StateStore) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Commit != 0 {
		i = encodeVarintRaft2(dAtA, i, uint64(m.Commit))
		i--
		dAtA[i] = 0x18
	}
	if len(m.Vote) > 0 {
		i -= len(m.Vote)
		copy(dAtA[i:], m.Vote)
		i = encodeVarintRaft2(dAtA, i, uint64(len(m.Vote)))
		i--
		dAtA[i] = 0x12
	}
	if m.Term != 0 {
		i = encodeVarintRaft2(dAtA, i, uint64(m.Term))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *RecoveryState) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *RecoveryState) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *RecoveryState) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Entries) > 0 {
		for iNdEx := len(m.Entries) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Entries[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintRaft2(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x22
		}
	}
	if m.Snap != nil {
		{
			size, err := m.Snap.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintRaft2(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1a
	}
	if m.Store != nil {
		{
			size, err := m.Store.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintRaft2(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	if len(m.Config) > 0 {
		i -= len(m.Config)
		copy(dAtA[i:], m.Config)
		i = encodeVarintRaft2(dAtA, i, uint64(len(m.Config)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *SignedInitialState) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SignedInitialState) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *SignedInitialState) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.PublicKey) > 0 {
		i -= len(m.PublicKey)
		copy(dAtA[i:], m.PublicKey)
		i = encodeVarintRaft2(dAtA, i, uint64(len(m.PublicKey)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.Signature) > 0 {
		i -= len(m.Signature)
		copy(dAtA[i:], m.Signature)
		i = encodeVarintRaft2(dAtA, i, uint64(len(m.Signature)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.InitialState) > 0 {
		i -= len(m.InitialState)
		copy(dAtA[i:], m.InitialState)
		i = encodeVarintRaft2(dAtA, i, uint64(len(m.InitialState)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func encodeVarintRaft2(dAtA []byte, offset int, v uint64) int {
	offset -= sovRaft2(v)
	base := offset
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return base
}
func (m *StateSet) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Timer != nil {
		l = m.Timer.Size()
		n += 1 + l + sovRaft2(uint64(l))
	}
	if m.Leadership != nil {
		l = m.Leadership.Size()
		n += 1 + l + sovRaft2(uint64(l))
	}
	if m.Term != 0 {
		n += 1 + sovRaft2(uint64(m.Term))
	}
	if m.LastIndex != 0 {
		n += 1 + sovRaft2(uint64(m.LastIndex))
	}
	if m.Transfer {
		n += 2
	}
	return n
}

func (m *DataSet) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.StateStore != nil {
		l = m.StateStore.Size()
		n += 1 + l + sovRaft2(uint64(l))
	}
	if len(m.Entries) > 0 {
		for _, e := range m.Entries {
			l = e.Size()
			n += 1 + l + sovRaft2(uint64(l))
		}
	}
	if m.Snapshot != nil {
		l = m.Snapshot.Size()
		n += 1 + l + sovRaft2(uint64(l))
	}
	if len(m.Message) > 0 {
		for _, e := range m.Message {
			l = e.Size()
			n += 1 + l + sovRaft2(uint64(l))
		}
	}
	if m.Sync {
		n += 2
	}
	if m.Remaining != 0 {
		n += 1 + sovRaft2(uint64(m.Remaining))
	}
	if m.Terminate {
		n += 2
	}
	if m.CurrentConfIndex != 0 {
		n += 1 + sovRaft2(uint64(m.CurrentConfIndex))
	}
	return n
}

func (m *Timer) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.IsReset {
		n += 2
	}
	if m.Timeout != 0 {
		n += 1 + sovRaft2(uint64(m.Timeout))
	}
	return n
}

func (m *Leadership) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Leader)
	if l > 0 {
		n += 1 + l + sovRaft2(uint64(l))
	}
	if m.State != 0 {
		n += 1 + sovRaft2(uint64(m.State))
	}
	return n
}

func (m *Conf) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Voters) > 0 {
		for _, s := range m.Voters {
			l = len(s)
			n += 1 + l + sovRaft2(uint64(l))
		}
	}
	if len(m.Learners) > 0 {
		for _, s := range m.Learners {
			l = len(s)
			n += 1 + l + sovRaft2(uint64(l))
		}
	}
	return n
}

func (m *ConfChange) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Block != nil {
		l = m.Block.Size()
		n += 1 + l + sovRaft2(uint64(l))
	}
	if m.Op != 0 {
		n += 1 + sovRaft2(uint64(m.Op))
	}
	if m.Node != nil {
		l = m.Node.Size()
		n += 1 + l + sovRaft2(uint64(l))
	}
	return n
}

func (m *Entry) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Term != 0 {
		n += 1 + sovRaft2(uint64(m.Term))
	}
	if m.Index != 0 {
		n += 1 + sovRaft2(uint64(m.Index))
	}
	if m.Value != nil {
		n += m.Value.Size()
	}
	l = len(m.Signature)
	if l > 0 {
		n += 1 + l + sovRaft2(uint64(l))
	}
	l = len(m.BlockBytes)
	if l > 0 {
		n += 1 + l + sovRaft2(uint64(l))
	}
	return n
}

func (m *Entry_Block) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Block != nil {
		l = m.Block.Size()
		n += 1 + l + sovRaft2(uint64(l))
	}
	return n
}
func (m *Entry_ConfChange) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.ConfChange != nil {
		l = m.ConfChange.Size()
		n += 1 + l + sovRaft2(uint64(l))
	}
	return n
}
func (m *BlockMetadata) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Height != 0 {
		n += 1 + sovRaft2(uint64(m.Height))
	}
	l = len(m.Hash)
	if l > 0 {
		n += 1 + l + sovRaft2(uint64(l))
	}
	return n
}

func (m *Certificate) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Msg)
	if l > 0 {
		n += 1 + l + sovRaft2(uint64(l))
	}
	l = len(m.Sign)
	if l > 0 {
		n += 1 + l + sovRaft2(uint64(l))
	}
	return n
}

func (m *Msg) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Type != 0 {
		n += 1 + sovRaft2(uint64(m.Type))
	}
	l = len(m.From)
	if l > 0 {
		n += 1 + l + sovRaft2(uint64(l))
	}
	l = len(m.To)
	if l > 0 {
		n += 1 + l + sovRaft2(uint64(l))
	}
	if m.Payload != nil {
		n += m.Payload.Size()
	}
	l = len(m.Group)
	if l > 0 {
		n += 1 + l + sovRaft2(uint64(l))
	}
	if m.Term != 0 {
		n += 1 + sovRaft2(uint64(m.Term))
	}
	return n
}

func (m *Msg_Append) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Append != nil {
		l = m.Append.Size()
		n += 1 + l + sovRaft2(uint64(l))
	}
	return n
}
func (m *Msg_Accpet) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Accpet != nil {
		l = m.Accpet.Size()
		n += 1 + l + sovRaft2(uint64(l))
	}
	return n
}
func (m *Msg_Reject) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Reject != nil {
		l = m.Reject.Size()
		n += 1 + l + sovRaft2(uint64(l))
	}
	return n
}
func (m *Msg_Vote) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Vote != nil {
		l = m.Vote.Size()
		n += 1 + l + sovRaft2(uint64(l))
	}
	return n
}
func (m *Msg_VoteResp) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.VoteResp != nil {
		l = m.VoteResp.Size()
		n += 1 + l + sovRaft2(uint64(l))
	}
	return n
}
func (m *Msg_Hb) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Hb != nil {
		l = m.Hb.Size()
		n += 1 + l + sovRaft2(uint64(l))
	}
	return n
}
func (m *Msg_Snap) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Snap != nil {
		l = m.Snap.Size()
		n += 1 + l + sovRaft2(uint64(l))
	}
	return n
}
func (m *Msg_SnapStatus) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.SnapStatus != nil {
		l = m.SnapStatus.Size()
		n += 1 + l + sovRaft2(uint64(l))
	}
	return n
}
func (m *Msg_HbResp) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.HbResp != nil {
		l = m.HbResp.Size()
		n += 1 + l + sovRaft2(uint64(l))
	}
	return n
}
func (m *Msg_Prop) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Prop != nil {
		l = m.Prop.Size()
		n += 1 + l + sovRaft2(uint64(l))
	}
	return n
}
func (m *Msg_Config) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Config != nil {
		l = m.Config.Size()
		n += 2 + l + sovRaft2(uint64(l))
	}
	return n
}
func (m *InitConfig) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Op != 0 {
		n += 1 + sovRaft2(uint64(m.Op))
	}
	l = len(m.InitState)
	if l > 0 {
		n += 1 + l + sovRaft2(uint64(l))
	}
	if m.Height != 0 {
		n += 1 + sovRaft2(uint64(m.Height))
	}
	return n
}

func (m *HeartbeatResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.LastIndex != 0 {
		n += 1 + sovRaft2(uint64(m.LastIndex))
	}
	return n
}

func (m *Proposal) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Entries) > 0 {
		for _, e := range m.Entries {
			l = e.Size()
			n += 1 + l + sovRaft2(uint64(l))
		}
	}
	return n
}

func (m *AppendEntries) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Entries) > 0 {
		for _, e := range m.Entries {
			l = e.Size()
			n += 1 + l + sovRaft2(uint64(l))
		}
	}
	if m.Term != 0 {
		n += 1 + sovRaft2(uint64(m.Term))
	}
	if m.Index != 0 {
		n += 1 + sovRaft2(uint64(m.Index))
	}
	if m.Commit != 0 {
		n += 1 + sovRaft2(uint64(m.Commit))
	}
	return n
}

func (m *Snapshot) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Term != 0 {
		n += 1 + sovRaft2(uint64(m.Term))
	}
	if m.Index != 0 {
		n += 1 + sovRaft2(uint64(m.Index))
	}
	if m.Conf != nil {
		l = m.Conf.Size()
		n += 1 + l + sovRaft2(uint64(l))
	}
	if m.Range != nil {
		l = m.Range.Size()
		n += 1 + l + sovRaft2(uint64(l))
	}
	l = len(m.BlockSeq)
	if l > 0 {
		n += 1 + l + sovRaft2(uint64(l))
	}
	return n
}

func (m *BlockRange) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Begin != 0 {
		n += 1 + sovRaft2(uint64(m.Begin))
	}
	if m.End != 0 {
		n += 1 + sovRaft2(uint64(m.End))
	}
	if len(m.IndexToHeight) > 0 {
		l = 0
		for _, e := range m.IndexToHeight {
			l += sovRaft2(uint64(e))
		}
		n += 1 + sovRaft2(uint64(l)) + l
	}
	return n
}

func (m *AppendReject) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.AppIndex != 0 {
		n += 1 + sovRaft2(uint64(m.AppIndex))
	}
	if m.LastIndex != 0 {
		n += 1 + sovRaft2(uint64(m.LastIndex))
	}
	return n
}

func (m *AppendAccept) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.MatchIndex != 0 {
		n += 1 + sovRaft2(uint64(m.MatchIndex))
	}
	return n
}

func (m *Vote) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Term != 0 {
		n += 1 + sovRaft2(uint64(m.Term))
	}
	if m.LastIndex != 0 {
		n += 1 + sovRaft2(uint64(m.LastIndex))
	}
	if m.LastTerm != 0 {
		n += 1 + sovRaft2(uint64(m.LastTerm))
	}
	return n
}

func (m *VoteResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Granted {
		n += 2
	}
	return n
}

func (m *Heartbeat) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Commit != 0 {
		n += 1 + sovRaft2(uint64(m.Commit))
	}
	return n
}

func (m *SnapshotStatus) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Reject {
		n += 2
	}
	if m.Done {
		n += 2
	}
	return n
}

func (m *StateStore) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Term != 0 {
		n += 1 + sovRaft2(uint64(m.Term))
	}
	l = len(m.Vote)
	if l > 0 {
		n += 1 + l + sovRaft2(uint64(l))
	}
	if m.Commit != 0 {
		n += 1 + sovRaft2(uint64(m.Commit))
	}
	return n
}

func (m *RecoveryState) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Config)
	if l > 0 {
		n += 1 + l + sovRaft2(uint64(l))
	}
	if m.Store != nil {
		l = m.Store.Size()
		n += 1 + l + sovRaft2(uint64(l))
	}
	if m.Snap != nil {
		l = m.Snap.Size()
		n += 1 + l + sovRaft2(uint64(l))
	}
	if len(m.Entries) > 0 {
		for _, e := range m.Entries {
			l = e.Size()
			n += 1 + l + sovRaft2(uint64(l))
		}
	}
	return n
}

func (m *SignedInitialState) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.InitialState)
	if l > 0 {
		n += 1 + l + sovRaft2(uint64(l))
	}
	l = len(m.Signature)
	if l > 0 {
		n += 1 + l + sovRaft2(uint64(l))
	}
	l = len(m.PublicKey)
	if l > 0 {
		n += 1 + l + sovRaft2(uint64(l))
	}
	return n
}

func sovRaft2(x uint64) (n int) {
	return (math_bits.Len64(x|1) + 6) / 7
}
func sozRaft2(x uint64) (n int) {
	return sovRaft2(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (m *StateSet) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowRaft2
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: StateSet: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: StateSet: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Timer", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRaft2
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthRaft2
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthRaft2
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Timer == nil {
				m.Timer = &Timer{}
			}
			if err := m.Timer.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Leadership", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRaft2
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthRaft2
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthRaft2
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Leadership == nil {
				m.Leadership = &Leadership{}
			}
			if err := m.Leadership.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Term", wireType)
			}
			m.Term = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRaft2
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Term |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field LastIndex", wireType)
			}
			m.LastIndex = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRaft2
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.LastIndex |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Transfer", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRaft2
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Transfer = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipRaft2(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthRaft2
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *DataSet) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowRaft2
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: DataSet: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: DataSet: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field StateStore", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRaft2
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthRaft2
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthRaft2
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.StateStore == nil {
				m.StateStore = &StateStore{}
			}
			if err := m.StateStore.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Entries", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRaft2
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthRaft2
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthRaft2
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Entries = append(m.Entries, &Entry{})
			if err := m.Entries[len(m.Entries)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Snapshot", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRaft2
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthRaft2
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthRaft2
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Snapshot == nil {
				m.Snapshot = &Snapshot{}
			}
			if err := m.Snapshot.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Message", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRaft2
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthRaft2
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthRaft2
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Message = append(m.Message, &Certificate{})
			if err := m.Message[len(m.Message)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Sync", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRaft2
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Sync = bool(v != 0)
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Remaining", wireType)
			}
			m.Remaining = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRaft2
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Remaining |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Terminate", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRaft2
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Terminate = bool(v != 0)
		case 8:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CurrentConfIndex", wireType)
			}
			m.CurrentConfIndex = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRaft2
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.CurrentConfIndex |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipRaft2(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthRaft2
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Timer) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowRaft2
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Timer: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Timer: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IsReset", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRaft2
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.IsReset = bool(v != 0)
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Timeout", wireType)
			}
			m.Timeout = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRaft2
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Timeout |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipRaft2(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthRaft2
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Leadership) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowRaft2
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Leadership: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Leadership: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Leader", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRaft2
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthRaft2
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthRaft2
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Leader = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field State", wireType)
			}
			m.State = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRaft2
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.State |= State(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipRaft2(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthRaft2
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Conf) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowRaft2
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Conf: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Conf: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Voters", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRaft2
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthRaft2
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthRaft2
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Voters = append(m.Voters, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Learners", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRaft2
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthRaft2
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthRaft2
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Learners = append(m.Learners, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipRaft2(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthRaft2
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ConfChange) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowRaft2
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ConfChange: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ConfChange: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Block", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRaft2
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthRaft2
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthRaft2
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Block == nil {
				m.Block = &BlockMetadata{}
			}
			if err := m.Block.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Op", wireType)
			}
			m.Op = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRaft2
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Op |= consensus.ConfOp(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Node", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRaft2
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthRaft2
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthRaft2
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Node == nil {
				m.Node = &consensus.Consenter{}
			}
			if err := m.Node.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipRaft2(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthRaft2
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Entry) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowRaft2
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Entry: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Entry: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Term", wireType)
			}
			m.Term = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRaft2
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Term |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Index", wireType)
			}
			m.Index = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRaft2
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Index |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Block", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRaft2
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthRaft2
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthRaft2
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &BlockMetadata{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Value = &Entry_Block{v}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ConfChange", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRaft2
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthRaft2
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthRaft2
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &ConfChange{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Value = &Entry_ConfChange{v}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Signature", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRaft2
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthRaft2
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthRaft2
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Signature = append(m.Signature[:0], dAtA[iNdEx:postIndex]...)
			if m.Signature == nil {
				m.Signature = []byte{}
			}
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field BlockBytes", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRaft2
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthRaft2
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthRaft2
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.BlockBytes = append(m.BlockBytes[:0], dAtA[iNdEx:postIndex]...)
			if m.BlockBytes == nil {
				m.BlockBytes = []byte{}
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipRaft2(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthRaft2
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *BlockMetadata) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowRaft2
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: BlockMetadata: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: BlockMetadata: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Height", wireType)
			}
			m.Height = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRaft2
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Height |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Hash", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRaft2
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthRaft2
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthRaft2
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Hash = append(m.Hash[:0], dAtA[iNdEx:postIndex]...)
			if m.Hash == nil {
				m.Hash = []byte{}
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipRaft2(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthRaft2
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Certificate) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowRaft2
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Certificate: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Certificate: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Msg", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRaft2
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthRaft2
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthRaft2
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Msg = append(m.Msg[:0], dAtA[iNdEx:postIndex]...)
			if m.Msg == nil {
				m.Msg = []byte{}
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Sign", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRaft2
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthRaft2
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthRaft2
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Sign = append(m.Sign[:0], dAtA[iNdEx:postIndex]...)
			if m.Sign == nil {
				m.Sign = []byte{}
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipRaft2(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthRaft2
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Msg) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowRaft2
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Msg: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Msg: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Type", wireType)
			}
			m.Type = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRaft2
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Type |= MsgType(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field From", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRaft2
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthRaft2
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthRaft2
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.From = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field To", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRaft2
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthRaft2
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthRaft2
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.To = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Append", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRaft2
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthRaft2
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthRaft2
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &AppendEntries{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Payload = &Msg_Append{v}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Accpet", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRaft2
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthRaft2
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthRaft2
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &AppendAccept{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Payload = &Msg_Accpet{v}
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Reject", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRaft2
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthRaft2
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthRaft2
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &AppendReject{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Payload = &Msg_Reject{v}
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Vote", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRaft2
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthRaft2
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthRaft2
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &Vote{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Payload = &Msg_Vote{v}
			iNdEx = postIndex
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field VoteResp", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRaft2
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthRaft2
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthRaft2
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &VoteResponse{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Payload = &Msg_VoteResp{v}
			iNdEx = postIndex
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Hb", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRaft2
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthRaft2
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthRaft2
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &Heartbeat{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Payload = &Msg_Hb{v}
			iNdEx = postIndex
		case 10:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Snap", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRaft2
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthRaft2
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthRaft2
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &Snapshot{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Payload = &Msg_Snap{v}
			iNdEx = postIndex
		case 11:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SnapStatus", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRaft2
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthRaft2
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthRaft2
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &SnapshotStatus{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Payload = &Msg_SnapStatus{v}
			iNdEx = postIndex
		case 12:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Group", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRaft2
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthRaft2
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthRaft2
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Group = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 13:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Term", wireType)
			}
			m.Term = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRaft2
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Term |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 14:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field HbResp", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRaft2
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthRaft2
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthRaft2
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &HeartbeatResponse{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Payload = &Msg_HbResp{v}
			iNdEx = postIndex
		case 15:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Prop", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRaft2
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthRaft2
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthRaft2
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &Proposal{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Payload = &Msg_Prop{v}
			iNdEx = postIndex
		case 16:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Config", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRaft2
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthRaft2
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthRaft2
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &InitConfig{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Payload = &Msg_Config{v}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipRaft2(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthRaft2
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *InitConfig) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowRaft2
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: InitConfig: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: InitConfig: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Op", wireType)
			}
			m.Op = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRaft2
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Op |= consensus.ConfOp(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field InitState", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRaft2
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthRaft2
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthRaft2
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.InitState = append(m.InitState[:0], dAtA[iNdEx:postIndex]...)
			if m.InitState == nil {
				m.InitState = []byte{}
			}
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Height", wireType)
			}
			m.Height = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRaft2
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Height |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipRaft2(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthRaft2
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *HeartbeatResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowRaft2
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: HeartbeatResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: HeartbeatResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field LastIndex", wireType)
			}
			m.LastIndex = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRaft2
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.LastIndex |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipRaft2(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthRaft2
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Proposal) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowRaft2
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Proposal: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Proposal: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Entries", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRaft2
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthRaft2
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthRaft2
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Entries = append(m.Entries, &Entry{})
			if err := m.Entries[len(m.Entries)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipRaft2(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthRaft2
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *AppendEntries) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowRaft2
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: AppendEntries: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: AppendEntries: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Entries", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRaft2
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthRaft2
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthRaft2
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Entries = append(m.Entries, &Entry{})
			if err := m.Entries[len(m.Entries)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Term", wireType)
			}
			m.Term = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRaft2
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Term |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Index", wireType)
			}
			m.Index = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRaft2
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Index |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Commit", wireType)
			}
			m.Commit = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRaft2
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Commit |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipRaft2(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthRaft2
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Snapshot) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowRaft2
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Snapshot: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Snapshot: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Term", wireType)
			}
			m.Term = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRaft2
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Term |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Index", wireType)
			}
			m.Index = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRaft2
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Index |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Conf", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRaft2
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthRaft2
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthRaft2
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Conf == nil {
				m.Conf = &Conf{}
			}
			if err := m.Conf.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Range", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRaft2
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthRaft2
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthRaft2
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Range == nil {
				m.Range = &BlockRange{}
			}
			if err := m.Range.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field BlockSeq", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRaft2
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthRaft2
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthRaft2
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.BlockSeq = append(m.BlockSeq[:0], dAtA[iNdEx:postIndex]...)
			if m.BlockSeq == nil {
				m.BlockSeq = []byte{}
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipRaft2(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthRaft2
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *BlockRange) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowRaft2
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: BlockRange: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: BlockRange: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Begin", wireType)
			}
			m.Begin = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRaft2
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Begin |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field End", wireType)
			}
			m.End = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRaft2
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.End |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType == 0 {
				var v uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowRaft2
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.IndexToHeight = append(m.IndexToHeight, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowRaft2
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthRaft2
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLengthRaft2
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				var count int
				for _, integer := range dAtA[iNdEx:postIndex] {
					if integer < 128 {
						count++
					}
				}
				elementCount = count
				if elementCount != 0 && len(m.IndexToHeight) == 0 {
					m.IndexToHeight = make([]uint64, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowRaft2
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.IndexToHeight = append(m.IndexToHeight, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field IndexToHeight", wireType)
			}
		default:
			iNdEx = preIndex
			skippy, err := skipRaft2(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthRaft2
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *AppendReject) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowRaft2
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: AppendReject: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: AppendReject: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field AppIndex", wireType)
			}
			m.AppIndex = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRaft2
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.AppIndex |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field LastIndex", wireType)
			}
			m.LastIndex = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRaft2
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.LastIndex |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipRaft2(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthRaft2
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *AppendAccept) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowRaft2
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: AppendAccept: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: AppendAccept: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MatchIndex", wireType)
			}
			m.MatchIndex = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRaft2
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MatchIndex |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipRaft2(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthRaft2
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Vote) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowRaft2
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Vote: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Vote: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Term", wireType)
			}
			m.Term = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRaft2
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Term |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field LastIndex", wireType)
			}
			m.LastIndex = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRaft2
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.LastIndex |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field LastTerm", wireType)
			}
			m.LastTerm = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRaft2
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.LastTerm |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipRaft2(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthRaft2
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *VoteResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowRaft2
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: VoteResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: VoteResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Granted", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRaft2
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Granted = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipRaft2(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthRaft2
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Heartbeat) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowRaft2
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Heartbeat: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Heartbeat: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Commit", wireType)
			}
			m.Commit = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRaft2
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Commit |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipRaft2(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthRaft2
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SnapshotStatus) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowRaft2
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SnapshotStatus: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SnapshotStatus: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Reject", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRaft2
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Reject = bool(v != 0)
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Done", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRaft2
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Done = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipRaft2(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthRaft2
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *StateStore) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowRaft2
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: StateStore: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: StateStore: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Term", wireType)
			}
			m.Term = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRaft2
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Term |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Vote", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRaft2
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthRaft2
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthRaft2
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Vote = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Commit", wireType)
			}
			m.Commit = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRaft2
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Commit |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipRaft2(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthRaft2
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *RecoveryState) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowRaft2
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: RecoveryState: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: RecoveryState: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Config", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRaft2
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthRaft2
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthRaft2
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Config = append(m.Config[:0], dAtA[iNdEx:postIndex]...)
			if m.Config == nil {
				m.Config = []byte{}
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Store", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRaft2
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthRaft2
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthRaft2
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Store == nil {
				m.Store = &StateStore{}
			}
			if err := m.Store.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Snap", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRaft2
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthRaft2
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthRaft2
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Snap == nil {
				m.Snap = &Snapshot{}
			}
			if err := m.Snap.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Entries", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRaft2
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthRaft2
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthRaft2
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Entries = append(m.Entries, &Entry{})
			if err := m.Entries[len(m.Entries)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipRaft2(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthRaft2
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SignedInitialState) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowRaft2
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SignedInitialState: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SignedInitialState: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field InitialState", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRaft2
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthRaft2
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthRaft2
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.InitialState = append(m.InitialState[:0], dAtA[iNdEx:postIndex]...)
			if m.InitialState == nil {
				m.InitialState = []byte{}
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Signature", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRaft2
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthRaft2
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthRaft2
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Signature = append(m.Signature[:0], dAtA[iNdEx:postIndex]...)
			if m.Signature == nil {
				m.Signature = []byte{}
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PublicKey", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRaft2
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthRaft2
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthRaft2
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.PublicKey = append(m.PublicKey[:0], dAtA[iNdEx:postIndex]...)
			if m.PublicKey == nil {
				m.PublicKey = []byte{}
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipRaft2(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthRaft2
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipRaft2(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	depth := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowRaft2
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowRaft2
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
		case 1:
			iNdEx += 8
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowRaft2
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if length < 0 {
				return 0, ErrInvalidLengthRaft2
			}
			iNdEx += length
		case 3:
			depth++
		case 4:
			if depth == 0 {
				return 0, ErrUnexpectedEndOfGroupRaft2
			}
			depth--
		case 5:
			iNdEx += 4
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
		if iNdEx < 0 {
			return 0, ErrInvalidLengthRaft2
		}
		if depth == 0 {
			return iNdEx, nil
		}
	}
	return 0, io.ErrUnexpectedEOF
}

var (
	ErrInvalidLengthRaft2        = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowRaft2          = fmt.Errorf("proto: integer overflow")
	ErrUnexpectedEndOfGroupRaft2 = fmt.Errorf("proto: unexpected end of group")
)
