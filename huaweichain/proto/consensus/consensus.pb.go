// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: consensus/consensus.proto

package consensus

import (
	fmt "fmt"
	_ "github.com/gogo/protobuf/gogoproto"
	proto "github.com/gogo/protobuf/proto"
	io "io"
	math "math"
	math_bits "math/bits"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.GoGoProtoPackageIsVersion3 // please upgrade the proto package

type ConsType int32

const (
	Solo     ConsType = 0
	Raft     ConsType = 1
	PBFT     ConsType = 2
	Hotstuff ConsType = 3
)

var ConsType_name = map[int32]string{
	0: "Solo",
	1: "Raft",
	2: "PBFT",
	3: "Hotstuff",
}

var ConsType_value = map[string]int32{
	"Solo":     0,
	"Raft":     1,
	"PBFT":     2,
	"Hotstuff": 3,
}

func (x ConsType) String() string {
	return proto.EnumName(ConsType_name, int32(x))
}

func (ConsType) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_477fc6492de41e15, []int{0}
}

type ProposerType int32

const (
	FixedProposer     ProposerType = 0
	ViewProposer      ProposerType = 1
	RotatingProposer  ProposerType = 2
	AlternateProposer ProposerType = 3
)

var ProposerType_name = map[int32]string{
	0: "FixedProposer",
	1: "ViewProposer",
	2: "RotatingProposer",
	3: "AlternateProposer",
}

var ProposerType_value = map[string]int32{
	"FixedProposer":     0,
	"ViewProposer":      1,
	"RotatingProposer":  2,
	"AlternateProposer": 3,
}

func (x ProposerType) String() string {
	return proto.EnumName(ProposerType_name, int32(x))
}

func (ProposerType) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_477fc6492de41e15, []int{1}
}

type VoteAction int32

const (
	Vote     VoteAction = 0
	Complete VoteAction = 1
	Revert   VoteAction = 2
)

var VoteAction_name = map[int32]string{
	0: "Vote",
	1: "Complete",
	2: "Revert",
}

var VoteAction_value = map[string]int32{
	"Vote":     0,
	"Complete": 1,
	"Revert":   2,
}

func (x VoteAction) String() string {
	return proto.EnumName(VoteAction_name, int32(x))
}

func (VoteAction) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_477fc6492de41e15, []int{2}
}

// SysConsensus defines the configurations in Config Transaction, meaning
// consensus system configuration.
type SysCons struct {
	Type      ConsType      `protobuf:"varint,1,opt,name=type,proto3,enum=consensus.ConsType" json:"type,omitempty"`
	Genesis   *Genesis      `protobuf:"bytes,2,opt,name=genesis,proto3" json:"genesis,omitempty"`
	Conf      *CommonConfig `protobuf:"bytes,3,opt,name=conf,proto3" json:"conf,omitempty"`
	Consenter []*Consenter  `protobuf:"bytes,4,rep,name=consenter,proto3" json:"consenter,omitempty"`
}

func (m *SysCons) Reset()         { *m = SysCons{} }
func (m *SysCons) String() string { return proto.CompactTextString(m) }
func (*SysCons) ProtoMessage()    {}
func (*SysCons) Descriptor() ([]byte, []int) {
	return fileDescriptor_477fc6492de41e15, []int{0}
}
func (m *SysCons) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *SysCons) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_SysCons.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *SysCons) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SysCons.Merge(m, src)
}
func (m *SysCons) XXX_Size() int {
	return m.Size()
}
func (m *SysCons) XXX_DiscardUnknown() {
	xxx_messageInfo_SysCons.DiscardUnknown(m)
}

var xxx_messageInfo_SysCons proto.InternalMessageInfo

type CommonConfig struct {
	MaxTxCount            uint64 `protobuf:"varint,1,opt,name=max_tx_count,json=maxTxCount,proto3" json:"max_tx_count,omitempty"`
	MaxBlockSize          uint64 `protobuf:"varint,2,opt,name=max_block_size,json=maxBlockSize,proto3" json:"max_block_size,omitempty"`
	TimeoutTick           uint64 `protobuf:"varint,3,opt,name=timeout_tick,json=timeoutTick,proto3" json:"timeout_tick,omitempty"`
	TickInterval          uint64 `protobuf:"varint,4,opt,name=tick_interval,json=tickInterval,proto3" json:"tick_interval,omitempty"`
	TxBufSize             uint64 `protobuf:"varint,5,opt,name=tx_buf_size,json=txBufSize,proto3" json:"tx_buf_size,omitempty"`
	MaxRoutines           uint64 `protobuf:"varint,12,opt,name=max_routines,json=maxRoutines,proto3" json:"max_routines,omitempty"`
	InitBlockSeqCap       uint64 `protobuf:"varint,6,opt,name=init_block_seq_cap,json=initBlockSeqCap,proto3" json:"init_block_seq_cap,omitempty"`
	InitPendingEntriesCap uint64 `protobuf:"varint,7,opt,name=init_pending_entries_cap,json=initPendingEntriesCap,proto3" json:"init_pending_entries_cap,omitempty"`
	TickBufSize           uint64 `protobuf:"varint,8,opt,name=tick_buf_size,json=tickBufSize,proto3" json:"tick_buf_size,omitempty"`
	ProposedBlockBufSize  uint64 `protobuf:"varint,9,opt,name=proposed_block_buf_size,json=proposedBlockBufSize,proto3" json:"proposed_block_buf_size,omitempty"`
	CommittedBlockBufSize uint64 `protobuf:"varint,10,opt,name=committed_block_buf_size,json=committedBlockBufSize,proto3" json:"committed_block_buf_size,omitempty"`
	PersistedBlockBufSize uint64 `protobuf:"varint,11,opt,name=persisted_block_buf_size,json=persistedBlockBufSize,proto3" json:"persisted_block_buf_size,omitempty"`
	BlockLimitRate        uint64 `protobuf:"varint,13,opt,name=block_limit_rate,json=blockLimitRate,proto3" json:"block_limit_rate,omitempty"`
	TxLimitRate           uint64 `protobuf:"varint,14,opt,name=tx_limit_rate,json=txLimitRate,proto3" json:"tx_limit_rate,omitempty"`
	SendBufSize           uint64 `protobuf:"varint,15,opt,name=send_buf_size,json=sendBufSize,proto3" json:"send_buf_size,omitempty"`
	RecvBufSize           uint64 `protobuf:"varint,16,opt,name=recv_buf_size,json=recvBufSize,proto3" json:"recv_buf_size,omitempty"`
}

func (m *CommonConfig) Reset()         { *m = CommonConfig{} }
func (m *CommonConfig) String() string { return proto.CompactTextString(m) }
func (*CommonConfig) ProtoMessage()    {}
func (*CommonConfig) Descriptor() ([]byte, []int) {
	return fileDescriptor_477fc6492de41e15, []int{1}
}
func (m *CommonConfig) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *CommonConfig) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_CommonConfig.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *CommonConfig) XXX_Merge(src proto.Message) {
	xxx_messageInfo_CommonConfig.Merge(m, src)
}
func (m *CommonConfig) XXX_Size() int {
	return m.Size()
}
func (m *CommonConfig) XXX_DiscardUnknown() {
	xxx_messageInfo_CommonConfig.DiscardUnknown(m)
}

var xxx_messageInfo_CommonConfig proto.InternalMessageInfo

// messages communicated between consenters
type Cons struct {
	// Types that are valid to be assigned to Type:
	//	*Cons_Identity
	//	*Cons_Flic
	Type isCons_Type `protobuf_oneof:"type"`
}

func (m *Cons) Reset()         { *m = Cons{} }
func (m *Cons) String() string { return proto.CompactTextString(m) }
func (*Cons) ProtoMessage()    {}
func (*Cons) Descriptor() ([]byte, []int) {
	return fileDescriptor_477fc6492de41e15, []int{2}
}
func (m *Cons) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Cons) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Cons.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Cons) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Cons.Merge(m, src)
}
func (m *Cons) XXX_Size() int {
	return m.Size()
}
func (m *Cons) XXX_DiscardUnknown() {
	xxx_messageInfo_Cons.DiscardUnknown(m)
}

var xxx_messageInfo_Cons proto.InternalMessageInfo

type isCons_Type interface {
	isCons_Type()
	MarshalTo([]byte) (int, error)
	Size() int
}

type Cons_Identity struct {
	Identity *Identity `protobuf:"bytes,1,opt,name=identity,proto3,oneof" json:"identity,omitempty"`
}
type Cons_Flic struct {
	Flic *Flic `protobuf:"bytes,2,opt,name=flic,proto3,oneof" json:"flic,omitempty"`
}

func (*Cons_Identity) isCons_Type() {}
func (*Cons_Flic) isCons_Type()     {}

func (m *Cons) GetType() isCons_Type {
	if m != nil {
		return m.Type
	}
	return nil
}

func (m *Cons) GetIdentity() *Identity {
	if x, ok := m.GetType().(*Cons_Identity); ok {
		return x.Identity
	}
	return nil
}

func (m *Cons) GetFlic() *Flic {
	if x, ok := m.GetType().(*Cons_Flic); ok {
		return x.Flic
	}
	return nil
}

// XXX_OneofWrappers is for the internal use of the proto package.
func (*Cons) XXX_OneofWrappers() []interface{} {
	return []interface{}{
		(*Cons_Identity)(nil),
		(*Cons_Flic)(nil),
	}
}

type Identity struct {
	Addr string `protobuf:"bytes,1,opt,name=addr,proto3" json:"addr,omitempty"`
	Cert []byte `protobuf:"bytes,2,opt,name=cert,proto3" json:"cert,omitempty"`
}

func (m *Identity) Reset()         { *m = Identity{} }
func (m *Identity) String() string { return proto.CompactTextString(m) }
func (*Identity) ProtoMessage()    {}
func (*Identity) Descriptor() ([]byte, []int) {
	return fileDescriptor_477fc6492de41e15, []int{3}
}
func (m *Identity) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Identity) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Identity.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Identity) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Identity.Merge(m, src)
}
func (m *Identity) XXX_Size() int {
	return m.Size()
}
func (m *Identity) XXX_DiscardUnknown() {
	xxx_messageInfo_Identity.DiscardUnknown(m)
}

var xxx_messageInfo_Identity proto.InternalMessageInfo

type ConfigChange struct {
	Op        ConfOp     `protobuf:"varint,1,opt,name=op,proto3,enum=consensus.ConfOp" json:"op,omitempty"`
	Consenter *Consenter `protobuf:"bytes,2,opt,name=consenter,proto3" json:"consenter,omitempty"`
}

func (m *ConfigChange) Reset()         { *m = ConfigChange{} }
func (m *ConfigChange) String() string { return proto.CompactTextString(m) }
func (*ConfigChange) ProtoMessage()    {}
func (*ConfigChange) Descriptor() ([]byte, []int) {
	return fileDescriptor_477fc6492de41e15, []int{4}
}
func (m *ConfigChange) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ConfigChange) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ConfigChange.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ConfigChange) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ConfigChange.Merge(m, src)
}
func (m *ConfigChange) XXX_Size() int {
	return m.Size()
}
func (m *ConfigChange) XXX_DiscardUnknown() {
	xxx_messageInfo_ConfigChange.DiscardUnknown(m)
}

var xxx_messageInfo_ConfigChange proto.InternalMessageInfo

type Genesis struct {
	// Types that are valid to be assigned to Conf:
	//	*Genesis_Solo
	//	*Genesis_Raft
	//	*Genesis_Flic
	//	*Genesis_Hotstuff
	Conf isGenesis_Conf `protobuf_oneof:"conf"`
}

func (m *Genesis) Reset()         { *m = Genesis{} }
func (m *Genesis) String() string { return proto.CompactTextString(m) }
func (*Genesis) ProtoMessage()    {}
func (*Genesis) Descriptor() ([]byte, []int) {
	return fileDescriptor_477fc6492de41e15, []int{5}
}
func (m *Genesis) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Genesis) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Genesis.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Genesis) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Genesis.Merge(m, src)
}
func (m *Genesis) XXX_Size() int {
	return m.Size()
}
func (m *Genesis) XXX_DiscardUnknown() {
	xxx_messageInfo_Genesis.DiscardUnknown(m)
}

var xxx_messageInfo_Genesis proto.InternalMessageInfo

type isGenesis_Conf interface {
	isGenesis_Conf()
	MarshalTo([]byte) (int, error)
	Size() int
}

type Genesis_Solo struct {
	Solo *SoloConfig `protobuf:"bytes,1,opt,name=solo,proto3,oneof" json:"solo,omitempty"`
}
type Genesis_Raft struct {
	Raft *RaftConfig `protobuf:"bytes,2,opt,name=raft,proto3,oneof" json:"raft,omitempty"`
}
type Genesis_Flic struct {
	Flic *FlicConfig `protobuf:"bytes,3,opt,name=flic,proto3,oneof" json:"flic,omitempty"`
}
type Genesis_Hotstuff struct {
	Hotstuff *HotStuffConfig `protobuf:"bytes,4,opt,name=hotstuff,proto3,oneof" json:"hotstuff,omitempty"`
}

func (*Genesis_Solo) isGenesis_Conf()     {}
func (*Genesis_Raft) isGenesis_Conf()     {}
func (*Genesis_Flic) isGenesis_Conf()     {}
func (*Genesis_Hotstuff) isGenesis_Conf() {}

func (m *Genesis) GetConf() isGenesis_Conf {
	if m != nil {
		return m.Conf
	}
	return nil
}

func (m *Genesis) GetSolo() *SoloConfig {
	if x, ok := m.GetConf().(*Genesis_Solo); ok {
		return x.Solo
	}
	return nil
}

func (m *Genesis) GetRaft() *RaftConfig {
	if x, ok := m.GetConf().(*Genesis_Raft); ok {
		return x.Raft
	}
	return nil
}

func (m *Genesis) GetFlic() *FlicConfig {
	if x, ok := m.GetConf().(*Genesis_Flic); ok {
		return x.Flic
	}
	return nil
}

func (m *Genesis) GetHotstuff() *HotStuffConfig {
	if x, ok := m.GetConf().(*Genesis_Hotstuff); ok {
		return x.Hotstuff
	}
	return nil
}

// XXX_OneofWrappers is for the internal use of the proto package.
func (*Genesis) XXX_OneofWrappers() []interface{} {
	return []interface{}{
		(*Genesis_Solo)(nil),
		(*Genesis_Raft)(nil),
		(*Genesis_Flic)(nil),
		(*Genesis_Hotstuff)(nil),
	}
}

type RaftConfig struct {
	InitialState []byte `protobuf:"bytes,1,opt,name=initialState,proto3" json:"initialState,omitempty"`
	Signature    []byte `protobuf:"bytes,2,opt,name=signature,proto3" json:"signature,omitempty"`
	PublicKey    []byte `protobuf:"bytes,3,opt,name=publicKey,proto3" json:"publicKey,omitempty"`
	Trusted      bool   `protobuf:"varint,4,opt,name=trusted,proto3" json:"trusted,omitempty"`
}

func (m *RaftConfig) Reset()         { *m = RaftConfig{} }
func (m *RaftConfig) String() string { return proto.CompactTextString(m) }
func (*RaftConfig) ProtoMessage()    {}
func (*RaftConfig) Descriptor() ([]byte, []int) {
	return fileDescriptor_477fc6492de41e15, []int{6}
}
func (m *RaftConfig) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *RaftConfig) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_RaftConfig.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *RaftConfig) XXX_Merge(src proto.Message) {
	xxx_messageInfo_RaftConfig.Merge(m, src)
}
func (m *RaftConfig) XXX_Size() int {
	return m.Size()
}
func (m *RaftConfig) XXX_DiscardUnknown() {
	xxx_messageInfo_RaftConfig.DiscardUnknown(m)
}

var xxx_messageInfo_RaftConfig proto.InternalMessageInfo

type SoloConfig struct {
}

func (m *SoloConfig) Reset()         { *m = SoloConfig{} }
func (m *SoloConfig) String() string { return proto.CompactTextString(m) }
func (*SoloConfig) ProtoMessage()    {}
func (*SoloConfig) Descriptor() ([]byte, []int) {
	return fileDescriptor_477fc6492de41e15, []int{7}
}
func (m *SoloConfig) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *SoloConfig) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_SoloConfig.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *SoloConfig) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SoloConfig.Merge(m, src)
}
func (m *SoloConfig) XXX_Size() int {
	return m.Size()
}
func (m *SoloConfig) XXX_DiscardUnknown() {
	xxx_messageInfo_SoloConfig.DiscardUnknown(m)
}

var xxx_messageInfo_SoloConfig proto.InternalMessageInfo

type FlicConfig struct {
	MaxFaultNodes uint64 `protobuf:"varint,1,opt,name=max_fault_nodes,json=maxFaultNodes,proto3" json:"max_fault_nodes,omitempty"`
	ReqTimeout    uint64 `protobuf:"varint,2,opt,name=req_timeout,json=reqTimeout,proto3" json:"req_timeout,omitempty"`
}

func (m *FlicConfig) Reset()         { *m = FlicConfig{} }
func (m *FlicConfig) String() string { return proto.CompactTextString(m) }
func (*FlicConfig) ProtoMessage()    {}
func (*FlicConfig) Descriptor() ([]byte, []int) {
	return fileDescriptor_477fc6492de41e15, []int{8}
}
func (m *FlicConfig) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *FlicConfig) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_FlicConfig.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *FlicConfig) XXX_Merge(src proto.Message) {
	xxx_messageInfo_FlicConfig.Merge(m, src)
}
func (m *FlicConfig) XXX_Size() int {
	return m.Size()
}
func (m *FlicConfig) XXX_DiscardUnknown() {
	xxx_messageInfo_FlicConfig.DiscardUnknown(m)
}

var xxx_messageInfo_FlicConfig proto.InternalMessageInfo

type HotStuffConfig struct {
	Epoch           uint64       `protobuf:"varint,1,opt,name=epoch,proto3" json:"epoch,omitempty"`
	Group           string       `protobuf:"bytes,2,opt,name=group,proto3" json:"group,omitempty"`
	Consenters      []*Consenter `protobuf:"bytes,3,rep,name=consenters,proto3" json:"consenters,omitempty"`
	Learners        []string     `protobuf:"bytes,4,rep,name=learners,proto3" json:"learners,omitempty"`
	MaxPrunedBlocks uint64       `protobuf:"varint,5,opt,name=max_pruned_blocks,json=maxPrunedBlocks,proto3" json:"max_pruned_blocks,omitempty"`
	Tick            uint64       `protobuf:"varint,6,opt,name=tick,proto3" json:"tick,omitempty"`
	ViewTimeout     uint32       `protobuf:"varint,7,opt,name=view_timeout,json=viewTimeout,proto3" json:"view_timeout,omitempty"`
	Type            ProposerType `protobuf:"varint,8,opt,name=type,proto3,enum=consensus.ProposerType" json:"type,omitempty"`
	ForwardProp     bool         `protobuf:"varint,9,opt,name=forward_prop,json=forwardProp,proto3" json:"forward_prop,omitempty"`
	MaxBlockBatch   uint64       `protobuf:"varint,10,opt,name=max_block_batch,json=maxBlockBatch,proto3" json:"max_block_batch,omitempty"`
	MemoryStore     bool         `protobuf:"varint,11,opt,name=memory_store,json=memoryStore,proto3" json:"memory_store,omitempty"`
	VerifyTimestamp bool         `protobuf:"varint,12,opt,name=verify_timestamp,json=verifyTimestamp,proto3" json:"verify_timestamp,omitempty"`
	WaitTxDuration  uint64       `protobuf:"varint,13,opt,name=wait_tx_duration,json=waitTxDuration,proto3" json:"wait_tx_duration,omitempty"`
}

func (m *HotStuffConfig) Reset()         { *m = HotStuffConfig{} }
func (m *HotStuffConfig) String() string { return proto.CompactTextString(m) }
func (*HotStuffConfig) ProtoMessage()    {}
func (*HotStuffConfig) Descriptor() ([]byte, []int) {
	return fileDescriptor_477fc6492de41e15, []int{9}
}
func (m *HotStuffConfig) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *HotStuffConfig) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_HotStuffConfig.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *HotStuffConfig) XXX_Merge(src proto.Message) {
	xxx_messageInfo_HotStuffConfig.Merge(m, src)
}
func (m *HotStuffConfig) XXX_Size() int {
	return m.Size()
}
func (m *HotStuffConfig) XXX_DiscardUnknown() {
	xxx_messageInfo_HotStuffConfig.DiscardUnknown(m)
}

var xxx_messageInfo_HotStuffConfig proto.InternalMessageInfo

type ConsensusUpdate struct {
	// Types that are valid to be assigned to Update:
	//	*ConsensusUpdate_ConfChange
	//	*ConsensusUpdate_Alg
	//	*ConsensusUpdate_Props
	Update isConsensusUpdate_Update `protobuf_oneof:"update"`
}

func (m *ConsensusUpdate) Reset()         { *m = ConsensusUpdate{} }
func (m *ConsensusUpdate) String() string { return proto.CompactTextString(m) }
func (*ConsensusUpdate) ProtoMessage()    {}
func (*ConsensusUpdate) Descriptor() ([]byte, []int) {
	return fileDescriptor_477fc6492de41e15, []int{10}
}
func (m *ConsensusUpdate) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ConsensusUpdate) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ConsensusUpdate.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ConsensusUpdate) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ConsensusUpdate.Merge(m, src)
}
func (m *ConsensusUpdate) XXX_Size() int {
	return m.Size()
}
func (m *ConsensusUpdate) XXX_DiscardUnknown() {
	xxx_messageInfo_ConsensusUpdate.DiscardUnknown(m)
}

var xxx_messageInfo_ConsensusUpdate proto.InternalMessageInfo

type isConsensusUpdate_Update interface {
	isConsensusUpdate_Update()
	MarshalTo([]byte) (int, error)
	Size() int
}

type ConsensusUpdate_ConfChange struct {
	ConfChange *ConfigChange `protobuf:"bytes,1,opt,name=conf_change,json=confChange,proto3,oneof" json:"conf_change,omitempty"`
}
type ConsensusUpdate_Alg struct {
	Alg ConsType `protobuf:"varint,2,opt,name=alg,proto3,enum=consensus.ConsType,oneof" json:"alg,omitempty"`
}
type ConsensusUpdate_Props struct {
	Props *ConsensusUpdate_Properties `protobuf:"bytes,3,opt,name=props,proto3,oneof" json:"props,omitempty"`
}

func (*ConsensusUpdate_ConfChange) isConsensusUpdate_Update() {}
func (*ConsensusUpdate_Alg) isConsensusUpdate_Update()        {}
func (*ConsensusUpdate_Props) isConsensusUpdate_Update()      {}

func (m *ConsensusUpdate) GetUpdate() isConsensusUpdate_Update {
	if m != nil {
		return m.Update
	}
	return nil
}

func (m *ConsensusUpdate) GetConfChange() *ConfigChange {
	if x, ok := m.GetUpdate().(*ConsensusUpdate_ConfChange); ok {
		return x.ConfChange
	}
	return nil
}

func (m *ConsensusUpdate) GetAlg() ConsType {
	if x, ok := m.GetUpdate().(*ConsensusUpdate_Alg); ok {
		return x.Alg
	}
	return Solo
}

func (m *ConsensusUpdate) GetProps() *ConsensusUpdate_Properties {
	if x, ok := m.GetUpdate().(*ConsensusUpdate_Props); ok {
		return x.Props
	}
	return nil
}

// XXX_OneofWrappers is for the internal use of the proto package.
func (*ConsensusUpdate) XXX_OneofWrappers() []interface{} {
	return []interface{}{
		(*ConsensusUpdate_ConfChange)(nil),
		(*ConsensusUpdate_Alg)(nil),
		(*ConsensusUpdate_Props)(nil),
	}
}

type ConsensusUpdate_Properties struct {
	Kv map[string]string `protobuf:"bytes,1,rep,name=kv,proto3" json:"kv,omitempty" protobuf_key:"bytes,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value,proto3"`
}

func (m *ConsensusUpdate_Properties) Reset()         { *m = ConsensusUpdate_Properties{} }
func (m *ConsensusUpdate_Properties) String() string { return proto.CompactTextString(m) }
func (*ConsensusUpdate_Properties) ProtoMessage()    {}
func (*ConsensusUpdate_Properties) Descriptor() ([]byte, []int) {
	return fileDescriptor_477fc6492de41e15, []int{10, 0}
}
func (m *ConsensusUpdate_Properties) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ConsensusUpdate_Properties) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ConsensusUpdate_Properties.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ConsensusUpdate_Properties) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ConsensusUpdate_Properties.Merge(m, src)
}
func (m *ConsensusUpdate_Properties) XXX_Size() int {
	return m.Size()
}
func (m *ConsensusUpdate_Properties) XXX_DiscardUnknown() {
	xxx_messageInfo_ConsensusUpdate_Properties.DiscardUnknown(m)
}

var xxx_messageInfo_ConsensusUpdate_Properties proto.InternalMessageInfo

// Data structure for block header signature
type BlockHeaderInfo struct {
	Number     uint64 `protobuf:"varint,1,opt,name=number,proto3" json:"number,omitempty"`
	ParentHash []byte `protobuf:"bytes,2,opt,name=parent_hash,json=parentHash,proto3" json:"parent_hash,omitempty"`
	BodyHash   []byte `protobuf:"bytes,3,opt,name=body_hash,json=bodyHash,proto3" json:"body_hash,omitempty"`
	Timestamp  int64  `protobuf:"varint,4,opt,name=timestamp,proto3" json:"timestamp,omitempty"`
}

func (m *BlockHeaderInfo) Reset()         { *m = BlockHeaderInfo{} }
func (m *BlockHeaderInfo) String() string { return proto.CompactTextString(m) }
func (*BlockHeaderInfo) ProtoMessage()    {}
func (*BlockHeaderInfo) Descriptor() ([]byte, []int) {
	return fileDescriptor_477fc6492de41e15, []int{11}
}
func (m *BlockHeaderInfo) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *BlockHeaderInfo) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_BlockHeaderInfo.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *BlockHeaderInfo) XXX_Merge(src proto.Message) {
	xxx_messageInfo_BlockHeaderInfo.Merge(m, src)
}
func (m *BlockHeaderInfo) XXX_Size() int {
	return m.Size()
}
func (m *BlockHeaderInfo) XXX_DiscardUnknown() {
	xxx_messageInfo_BlockHeaderInfo.DiscardUnknown(m)
}

var xxx_messageInfo_BlockHeaderInfo proto.InternalMessageInfo

type ConsensusCertificate struct {
	Alg         ConsType `protobuf:"varint,1,opt,name=alg,proto3,enum=consensus.ConsType" json:"alg,omitempty"`
	Certificate []byte   `protobuf:"bytes,2,opt,name=certificate,proto3" json:"certificate,omitempty"`
}

func (m *ConsensusCertificate) Reset()         { *m = ConsensusCertificate{} }
func (m *ConsensusCertificate) String() string { return proto.CompactTextString(m) }
func (*ConsensusCertificate) ProtoMessage()    {}
func (*ConsensusCertificate) Descriptor() ([]byte, []int) {
	return fileDescriptor_477fc6492de41e15, []int{12}
}
func (m *ConsensusCertificate) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ConsensusCertificate) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ConsensusCertificate.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ConsensusCertificate) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ConsensusCertificate.Merge(m, src)
}
func (m *ConsensusCertificate) XXX_Size() int {
	return m.Size()
}
func (m *ConsensusCertificate) XXX_DiscardUnknown() {
	xxx_messageInfo_ConsensusCertificate.DiscardUnknown(m)
}

var xxx_messageInfo_ConsensusCertificate proto.InternalMessageInfo

type RaftCert struct {
	Cert []byte `protobuf:"bytes,1,opt,name=cert,proto3" json:"cert,omitempty"`
	Sign []byte `protobuf:"bytes,2,opt,name=sign,proto3" json:"sign,omitempty"`
}

func (m *RaftCert) Reset()         { *m = RaftCert{} }
func (m *RaftCert) String() string { return proto.CompactTextString(m) }
func (*RaftCert) ProtoMessage()    {}
func (*RaftCert) Descriptor() ([]byte, []int) {
	return fileDescriptor_477fc6492de41e15, []int{13}
}
func (m *RaftCert) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *RaftCert) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_RaftCert.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *RaftCert) XXX_Merge(src proto.Message) {
	xxx_messageInfo_RaftCert.Merge(m, src)
}
func (m *RaftCert) XXX_Size() int {
	return m.Size()
}
func (m *RaftCert) XXX_DiscardUnknown() {
	xxx_messageInfo_RaftCert.DiscardUnknown(m)
}

var xxx_messageInfo_RaftCert proto.InternalMessageInfo

func init() {
	proto.RegisterEnum("consensus.ConsType", ConsType_name, ConsType_value)
	proto.RegisterEnum("consensus.ProposerType", ProposerType_name, ProposerType_value)
	proto.RegisterEnum("consensus.VoteAction", VoteAction_name, VoteAction_value)
	proto.RegisterType((*SysCons)(nil), "consensus.SysCons")
	proto.RegisterType((*CommonConfig)(nil), "consensus.CommonConfig")
	proto.RegisterType((*Cons)(nil), "consensus.Cons")
	proto.RegisterType((*Identity)(nil), "consensus.Identity")
	proto.RegisterType((*ConfigChange)(nil), "consensus.ConfigChange")
	proto.RegisterType((*Genesis)(nil), "consensus.Genesis")
	proto.RegisterType((*RaftConfig)(nil), "consensus.RaftConfig")
	proto.RegisterType((*SoloConfig)(nil), "consensus.SoloConfig")
	proto.RegisterType((*FlicConfig)(nil), "consensus.FlicConfig")
	proto.RegisterType((*HotStuffConfig)(nil), "consensus.HotStuffConfig")
	proto.RegisterType((*ConsensusUpdate)(nil), "consensus.ConsensusUpdate")
	proto.RegisterType((*ConsensusUpdate_Properties)(nil), "consensus.ConsensusUpdate.Properties")
	proto.RegisterMapType((map[string]string)(nil), "consensus.ConsensusUpdate.Properties.KvEntry")
	proto.RegisterType((*BlockHeaderInfo)(nil), "consensus.BlockHeaderInfo")
	proto.RegisterType((*ConsensusCertificate)(nil), "consensus.ConsensusCertificate")
	proto.RegisterType((*RaftCert)(nil), "consensus.RaftCert")
}

func init() { proto.RegisterFile("consensus/consensus.proto", fileDescriptor_477fc6492de41e15) }

var fileDescriptor_477fc6492de41e15 = []byte{
	// 1486 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0x8c, 0x56, 0x41, 0x73, 0x1b, 0x35,
	0x14, 0xf6, 0xda, 0x4e, 0x62, 0x3f, 0x3b, 0x89, 0x23, 0xd2, 0xd6, 0x0d, 0x1d, 0x93, 0x1a, 0xda,
	0x86, 0x14, 0x12, 0x08, 0x94, 0x76, 0x3a, 0xd3, 0x43, 0x63, 0x48, 0xdd, 0x29, 0x03, 0x99, 0x4d,
	0xda, 0x03, 0x97, 0x45, 0x59, 0xcb, 0xb6, 0x26, 0xde, 0xd5, 0x46, 0xab, 0x75, 0xec, 0x1e, 0x3b,
	0x03, 0x67, 0x7e, 0x07, 0xff, 0x82, 0x19, 0x0e, 0x3d, 0x96, 0x1b, 0x47, 0xda, 0xfe, 0x11, 0xe6,
	0x49, 0xda, 0x5d, 0xbb, 0xed, 0x14, 0x6e, 0xda, 0xef, 0x7d, 0x4f, 0x7a, 0x4f, 0x7a, 0xef, 0x7b,
	0x0b, 0x97, 0x7d, 0x11, 0xc6, 0x2c, 0x8c, 0x93, 0x78, 0x37, 0x5b, 0xed, 0x44, 0x52, 0x28, 0x41,
	0xaa, 0x19, 0xb0, 0xb1, 0x3e, 0x10, 0x03, 0xa1, 0xd1, 0x5d, 0x5c, 0x19, 0xc2, 0xc6, 0x7a, 0xee,
	0xdb, 0x1f, 0x71, 0xdf, 0xa2, 0x17, 0xe7, 0x76, 0xec, 0xf3, 0x81, 0xc1, 0xdb, 0x7f, 0x38, 0xb0,
	0x74, 0x34, 0x8d, 0x3b, 0x22, 0x8c, 0xc9, 0x0d, 0x28, 0xab, 0x69, 0xc4, 0x9a, 0xce, 0xa6, 0xb3,
	0xb5, 0xb2, 0xf7, 0xc1, 0x4e, 0x7e, 0x34, 0x9a, 0x8f, 0xa7, 0x11, 0x73, 0x35, 0x81, 0x7c, 0x06,
	0x4b, 0x03, 0x16, 0xb2, 0x98, 0xc7, 0xcd, 0xe2, 0xa6, 0xb3, 0x55, 0xdb, 0x23, 0x33, 0xdc, 0x07,
	0xc6, 0xe2, 0xa6, 0x14, 0x72, 0x13, 0xca, 0x78, 0x64, 0xb3, 0xa4, 0xa9, 0x97, 0xe6, 0xb6, 0x0d,
	0x02, 0x11, 0x76, 0x74, 0x3c, 0xae, 0x26, 0x91, 0x3d, 0xb0, 0x09, 0x2a, 0x26, 0x9b, 0xe5, 0xcd,
	0xd2, 0x56, 0x6d, 0x6f, 0xfd, 0x8d, 0x40, 0xb4, 0xcd, 0xcd, 0x69, 0xed, 0xdf, 0x17, 0xa0, 0x3e,
	0xbb, 0x15, 0xd9, 0x84, 0x7a, 0x40, 0x27, 0x9e, 0x9a, 0x78, 0xbe, 0x48, 0x42, 0xa5, 0x13, 0x2a,
	0xbb, 0x10, 0xd0, 0xc9, 0xf1, 0xa4, 0x83, 0x08, 0xf9, 0x04, 0x56, 0x90, 0x71, 0x32, 0x12, 0xfe,
	0xa9, 0x17, 0xf3, 0xa7, 0x4c, 0x27, 0x52, 0x76, 0xd1, 0x6f, 0x1f, 0xc1, 0x23, 0xfe, 0x94, 0x91,
	0xab, 0x50, 0x57, 0x3c, 0x60, 0x22, 0x51, 0x9e, 0xe2, 0xfe, 0xa9, 0xce, 0xa0, 0xec, 0xd6, 0x2c,
	0x76, 0xcc, 0xfd, 0x53, 0xf2, 0x31, 0x2c, 0xa3, 0xc9, 0xe3, 0x18, 0xc9, 0x98, 0x8e, 0x9a, 0x65,
	0xb3, 0x0f, 0x82, 0x0f, 0x2d, 0x46, 0x5a, 0x50, 0x53, 0x13, 0xef, 0x24, 0xe9, 0x9b, 0xa3, 0x16,
	0x34, 0xa5, 0xaa, 0x26, 0xfb, 0x49, 0x3f, 0x3d, 0x07, 0xa3, 0x91, 0x22, 0x51, 0x3c, 0x64, 0x71,
	0xb3, 0x6e, 0xce, 0x09, 0xe8, 0xc4, 0xb5, 0x10, 0xb9, 0x09, 0x84, 0x87, 0x5c, 0xa5, 0x11, 0xb3,
	0x33, 0xcf, 0xa7, 0x51, 0x73, 0x51, 0x13, 0x57, 0xd1, 0x62, 0xa2, 0x66, 0x67, 0x1d, 0x1a, 0x91,
	0xdb, 0xd0, 0xd4, 0xe4, 0x88, 0x85, 0x3d, 0x1e, 0x0e, 0x3c, 0x16, 0x2a, 0xc9, 0x59, 0xac, 0x5d,
	0x96, 0xb4, 0xcb, 0x05, 0xb4, 0x1f, 0x1a, 0xf3, 0x77, 0xc6, 0x8a, 0x8e, 0x6d, 0x9b, 0x4d, 0x16,
	0x6a, 0x25, 0xcd, 0xd8, 0x3f, 0x4d, 0x83, 0xbd, 0x05, 0x97, 0x22, 0x29, 0x22, 0x11, 0xb3, 0x9e,
	0x8d, 0x26, 0x63, 0x57, 0x35, 0x7b, 0x3d, 0x35, 0xeb, 0x90, 0x52, 0xb7, 0xdb, 0xd0, 0xf4, 0x45,
	0x10, 0x70, 0xa5, 0xde, 0xf6, 0x03, 0x13, 0x53, 0x66, 0x7f, 0xd3, 0x31, 0x62, 0x32, 0xe6, 0xf1,
	0x3b, 0x1c, 0x6b, 0xc6, 0x31, 0xb3, 0xcf, 0x39, 0x6e, 0x41, 0xc3, 0xd0, 0x47, 0x3c, 0xe0, 0xca,
	0x93, 0x54, 0xb1, 0xe6, 0xb2, 0x76, 0x58, 0xd1, 0xf8, 0xf7, 0x08, 0xbb, 0x54, 0x31, 0x9d, 0xf6,
	0x64, 0x96, 0xb6, 0x62, 0xd3, 0x9e, 0xcc, 0x71, 0x62, 0x16, 0xf6, 0xf2, 0xb3, 0x57, 0x0d, 0x07,
	0xc1, 0xf4, 0xc4, 0x36, 0x2c, 0x4b, 0xe6, 0x8f, 0x73, 0x4e, 0xc3, 0x70, 0x10, 0xb4, 0x9c, 0xf6,
	0x10, 0xca, 0xba, 0xd9, 0xbe, 0x84, 0x0a, 0xef, 0xb1, 0x50, 0x71, 0x35, 0xd5, 0xf5, 0x59, 0x9b,
	0x6b, 0xb8, 0x87, 0xd6, 0xd4, 0x2d, 0xb8, 0x19, 0x8d, 0x5c, 0x83, 0x32, 0x76, 0xb4, 0xed, 0xb9,
	0xd5, 0x19, 0xfa, 0xc1, 0x88, 0xfb, 0xdd, 0x82, 0xab, 0xcd, 0xfb, 0x8b, 0xa6, 0x8d, 0xdb, 0x7b,
	0x50, 0x49, 0xb7, 0x21, 0x04, 0xca, 0xb4, 0xd7, 0x93, 0xfa, 0xa4, 0xaa, 0xab, 0xd7, 0x88, 0xf9,
	0x4c, 0x2a, 0xbd, 0x5d, 0xdd, 0xd5, 0xeb, 0x36, 0xc3, 0x4e, 0xc2, 0x1e, 0xea, 0x0c, 0x69, 0x38,
	0xc0, 0xca, 0x2c, 0x8a, 0xc8, 0x0a, 0xc2, 0xda, 0x7c, 0x1f, 0xf6, 0x7f, 0x8c, 0xdc, 0xa2, 0x88,
	0xe6, 0x3b, 0xd6, 0x84, 0xf6, 0x9f, 0x1d, 0xfb, 0x97, 0x03, 0x4b, 0x0f, 0x72, 0x79, 0x88, 0xc5,
	0x48, 0xd8, 0x4b, 0xb8, 0x30, 0xe3, 0x7a, 0x24, 0x46, 0xc2, 0x44, 0x83, 0xb9, 0x21, 0x09, 0xc9,
	0x92, 0xf6, 0x95, 0x3d, 0x67, 0x96, 0xec, 0xd2, 0xbe, 0xca, 0xc9, 0x48, 0x42, 0xb2, 0xbe, 0xaf,
	0xd2, 0x5b, 0x64, 0xbc, 0xaf, 0x9c, 0x8c, 0x24, 0x72, 0x1b, 0x2a, 0x43, 0xa1, 0x62, 0x95, 0xf4,
	0xfb, 0xba, 0x87, 0x6b, 0x7b, 0x97, 0x67, 0x1c, 0xba, 0x42, 0x1d, 0xa1, 0x29, 0x73, 0xca, 0xc8,
	0x78, 0xdd, 0xa8, 0x5c, 0xed, 0x5f, 0x1d, 0x80, 0x3c, 0x08, 0xd2, 0x86, 0x3a, 0xf6, 0x18, 0xa7,
	0xa3, 0x23, 0x85, 0x25, 0xe5, 0xe8, 0x5b, 0x9e, 0xc3, 0xc8, 0x15, 0xa8, 0xc6, 0x7c, 0x10, 0x52,
	0x95, 0x48, 0x66, 0x9f, 0x21, 0x07, 0xd0, 0x1a, 0x25, 0x27, 0x23, 0xee, 0x3f, 0x62, 0x53, 0x9d,
	0x43, 0xdd, 0xcd, 0x01, 0xd2, 0x84, 0x25, 0x25, 0x13, 0x2c, 0x7a, 0x1d, 0x6e, 0xc5, 0x4d, 0x3f,
	0xdb, 0x75, 0x80, 0xfc, 0xe6, 0xda, 0x8f, 0x01, 0xf2, 0x6c, 0xc9, 0x75, 0x58, 0x45, 0xa5, 0xe9,
	0xd3, 0x64, 0xa4, 0xbc, 0x50, 0xf4, 0x58, 0x6c, 0xc5, 0x71, 0x39, 0xa0, 0x93, 0x03, 0x44, 0x7f,
	0x40, 0x90, 0x7c, 0x04, 0x35, 0xc9, 0xce, 0x3c, 0xab, 0x74, 0x56, 0x1c, 0x41, 0xb2, 0xb3, 0x63,
	0x83, 0xb4, 0x5f, 0x96, 0x60, 0x65, 0xfe, 0x52, 0xc8, 0x3a, 0x2c, 0xb0, 0x48, 0xf8, 0x43, 0xbb,
	0xa3, 0xf9, 0x40, 0x74, 0x20, 0x45, 0x12, 0xe9, 0x3d, 0xaa, 0xae, 0xf9, 0x20, 0x5f, 0x03, 0x64,
	0xd5, 0x10, 0x37, 0x4b, 0xef, 0xd1, 0xf9, 0x19, 0x1e, 0xd9, 0x80, 0xca, 0x88, 0x51, 0x19, 0xa2,
	0x0f, 0xce, 0x86, 0xaa, 0x9b, 0x7d, 0x93, 0x6d, 0x58, 0xc3, 0xcc, 0x22, 0x99, 0x84, 0xa9, 0x4e,
	0xc4, 0x56, 0x69, 0x31, 0xe5, 0x43, 0x8d, 0x6b, 0x7d, 0x88, 0xb1, 0xf2, 0xb5, 0x9e, 0x1b, 0xf9,
	0xd4, 0x6b, 0xd4, 0xe0, 0x31, 0x67, 0xe7, 0x59, 0xca, 0xa8, 0x93, 0xcb, 0x6e, 0x0d, 0x31, 0x9b,
	0x33, 0xd6, 0x93, 0x9e, 0x8f, 0x15, 0xdd, 0x0e, 0xb3, 0x83, 0xec, 0xd0, 0x28, 0x9e, 0x9c, 0x99,
	0x91, 0x57, 0xa1, 0xde, 0x17, 0xf2, 0x9c, 0xca, 0x9e, 0x87, 0x7a, 0xa8, 0xb5, 0xb1, 0xe2, 0xd6,
	0x2c, 0x86, 0x0e, 0xe9, 0x63, 0x58, 0x4d, 0xa3, 0xca, 0x1f, 0x5a, 0x25, 0x5c, 0x4e, 0xa7, 0xd0,
	0x3e, 0x82, 0x7a, 0x3c, 0xb0, 0x40, 0xc8, 0xa9, 0x17, 0x2b, 0x21, 0x8d, 0xea, 0x55, 0xdc, 0x9a,
	0xc1, 0x8e, 0x10, 0x22, 0x9f, 0x42, 0x63, 0xcc, 0x24, 0xef, 0x4f, 0x75, 0xfc, 0xb1, 0xa2, 0x41,
	0xa4, 0xa7, 0x48, 0xc5, 0x5d, 0x35, 0xf8, 0x71, 0x0a, 0xa3, 0x2c, 0x9e, 0x53, 0xae, 0x70, 0x3a,
	0xf6, 0x12, 0x49, 0x15, 0x17, 0x61, 0x2a, 0x8b, 0x88, 0x1f, 0x4f, 0xbe, 0xb5, 0x68, 0xfb, 0xcf,
	0x22, 0xac, 0x76, 0xd2, 0x1c, 0x1f, 0x47, 0x3d, 0x2c, 0xd9, 0xbb, 0x50, 0xc3, 0x6a, 0xf7, 0x7c,
	0xad, 0x0f, 0xb6, 0x69, 0x2f, 0xbd, 0xa1, 0x0c, 0xa9, 0x7c, 0x74, 0x0b, 0xfa, 0xf9, 0xfa, 0x56,
	0x4c, 0x6e, 0x40, 0x89, 0x8e, 0x06, 0xba, 0x10, 0xde, 0xfd, 0x7b, 0xd1, 0x2d, 0xb8, 0xc8, 0x20,
	0xf7, 0x60, 0x01, 0xef, 0x2c, 0xb6, 0x9d, 0x7b, 0xed, 0xad, 0xc2, 0xc8, 0xe2, 0xd1, 0x37, 0xcf,
	0xa4, 0xe2, 0x2c, 0xee, 0x16, 0x5c, 0xe3, 0xb5, 0xf1, 0xcc, 0x01, 0xc8, 0x71, 0x72, 0x0f, 0x8a,
	0xa7, 0xe3, 0xa6, 0xa3, 0x6b, 0xec, 0xf3, 0xff, 0xb5, 0xd5, 0xce, 0xa3, 0x31, 0x0e, 0xc5, 0xa9,
	0x5b, 0x3c, 0x1d, 0x6f, 0xdc, 0x82, 0x25, 0xfb, 0x49, 0x1a, 0x50, 0x3a, 0x65, 0x53, 0x2b, 0xa2,
	0xb8, 0xc4, 0xea, 0x1e, 0xd3, 0x51, 0xc2, 0xd2, 0xea, 0xd6, 0x1f, 0x77, 0x8b, 0x77, 0x9c, 0xfd,
	0x0a, 0x2c, 0x26, 0x7a, 0xdf, 0xf6, 0x2f, 0x0e, 0xac, 0xea, 0xd7, 0xec, 0x32, 0xda, 0x63, 0xf2,
	0x61, 0xd8, 0x17, 0xe4, 0x22, 0x2c, 0x86, 0x49, 0x70, 0xc2, 0xa4, 0x6d, 0x16, 0xfb, 0x85, 0x7d,
	0x17, 0x51, 0xc9, 0x42, 0xe5, 0x0d, 0x69, 0x3c, 0xb4, 0x9a, 0x00, 0x06, 0xea, 0xd2, 0x78, 0x48,
	0x3e, 0x84, 0xea, 0x89, 0xe8, 0x4d, 0x8d, 0xd9, 0x88, 0x42, 0x05, 0x01, 0x6d, 0xbc, 0x02, 0xd5,
	0xfc, 0xf9, 0x51, 0x15, 0x4a, 0x6e, 0x0e, 0xb4, 0x3d, 0x58, 0xcf, 0x52, 0xee, 0x60, 0xa2, 0x7d,
	0xee, 0xe3, 0x93, 0x5e, 0x33, 0xcf, 0xf2, 0x9e, 0xbf, 0x3e, 0xfd, 0x28, 0x9b, 0x50, 0xf3, 0x73,
	0x2f, 0x1b, 0xda, 0x2c, 0x84, 0x03, 0x47, 0x0b, 0x20, 0x93, 0x2a, 0x1b, 0x2e, 0x4e, 0x3e, 0x5c,
	0x10, 0x43, 0x75, 0x4b, 0x07, 0x0e, 0xae, 0xb7, 0xbf, 0x81, 0x4a, 0x7a, 0x0c, 0xa9, 0x40, 0x19,
	0x85, 0xab, 0x51, 0xc0, 0x15, 0xee, 0xd4, 0x70, 0x70, 0x75, 0xb8, 0x7f, 0x70, 0xdc, 0x28, 0x92,
	0x3a, 0x54, 0xba, 0x56, 0x73, 0x1b, 0xa5, 0xed, 0x9f, 0xa1, 0x3e, 0xdb, 0x74, 0x64, 0x0d, 0x96,
	0x0f, 0xf8, 0x84, 0xf5, 0x52, 0xb0, 0x51, 0x20, 0x0d, 0xa8, 0x3f, 0xe1, 0xec, 0x3c, 0x43, 0x1c,
	0xb2, 0x0e, 0x0d, 0x57, 0x28, 0xaa, 0x78, 0x38, 0xc8, 0xd0, 0x22, 0xb9, 0x00, 0x6b, 0xf7, 0x47,
	0x8a, 0xc9, 0x90, 0x2a, 0x96, 0xc1, 0xa5, 0xed, 0x2f, 0x00, 0x9e, 0x08, 0xc5, 0xee, 0xfb, 0xd8,
	0x0b, 0x18, 0x07, 0x7e, 0x35, 0x0a, 0x18, 0x47, 0x47, 0x04, 0xd1, 0x88, 0x29, 0xd6, 0x70, 0x08,
	0xc0, 0xa2, 0xcb, 0xc6, 0x4c, 0xaa, 0x46, 0x71, 0xff, 0x99, 0xf3, 0xfc, 0x65, 0xab, 0xf0, 0xe2,
	0x65, 0xab, 0xf0, 0xfc, 0x55, 0xcb, 0x79, 0xf1, 0xaa, 0xe5, 0xfc, 0xf3, 0xaa, 0xe5, 0xfc, 0xf6,
	0xba, 0x55, 0x78, 0xf1, 0xba, 0x55, 0xf8, 0xfb, 0x75, 0xab, 0x00, 0xd7, 0x7d, 0x11, 0xec, 0x0c,
	0x13, 0x7a, 0xce, 0xf8, 0xce, 0x39, 0x67, 0x21, 0x93, 0xfe, 0x90, 0xf2, 0xd0, 0xfc, 0x8c, 0xe7,
	0x57, 0xff, 0xd3, 0x9d, 0x01, 0x57, 0x29, 0xcf, 0x17, 0xc1, 0x6e, 0x24, 0x78, 0x1c, 0xa3, 0x95,
	0x4a, 0x7f, 0xb8, 0x3b, 0xe3, 0xb9, 0x6b, 0xfe, 0xff, 0x33, 0xcf, 0x93, 0x45, 0x0d, 0x7c, 0xf5,
	0x6f, 0x00, 0x00, 0x00, 0xff, 0xff, 0x89, 0x16, 0xa0, 0x0b, 0x43, 0x0c, 0x00, 0x00,
}

func (m *SysCons) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SysCons) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *SysCons) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Consenter) > 0 {
		for iNdEx := len(m.Consenter) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Consenter[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintConsensus(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x22
		}
	}
	if m.Conf != nil {
		{
			size, err := m.Conf.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintConsensus(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1a
	}
	if m.Genesis != nil {
		{
			size, err := m.Genesis.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintConsensus(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	if m.Type != 0 {
		i = encodeVarintConsensus(dAtA, i, uint64(m.Type))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *CommonConfig) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CommonConfig) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *CommonConfig) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.RecvBufSize != 0 {
		i = encodeVarintConsensus(dAtA, i, uint64(m.RecvBufSize))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0x80
	}
	if m.SendBufSize != 0 {
		i = encodeVarintConsensus(dAtA, i, uint64(m.SendBufSize))
		i--
		dAtA[i] = 0x78
	}
	if m.TxLimitRate != 0 {
		i = encodeVarintConsensus(dAtA, i, uint64(m.TxLimitRate))
		i--
		dAtA[i] = 0x70
	}
	if m.BlockLimitRate != 0 {
		i = encodeVarintConsensus(dAtA, i, uint64(m.BlockLimitRate))
		i--
		dAtA[i] = 0x68
	}
	if m.MaxRoutines != 0 {
		i = encodeVarintConsensus(dAtA, i, uint64(m.MaxRoutines))
		i--
		dAtA[i] = 0x60
	}
	if m.PersistedBlockBufSize != 0 {
		i = encodeVarintConsensus(dAtA, i, uint64(m.PersistedBlockBufSize))
		i--
		dAtA[i] = 0x58
	}
	if m.CommittedBlockBufSize != 0 {
		i = encodeVarintConsensus(dAtA, i, uint64(m.CommittedBlockBufSize))
		i--
		dAtA[i] = 0x50
	}
	if m.ProposedBlockBufSize != 0 {
		i = encodeVarintConsensus(dAtA, i, uint64(m.ProposedBlockBufSize))
		i--
		dAtA[i] = 0x48
	}
	if m.TickBufSize != 0 {
		i = encodeVarintConsensus(dAtA, i, uint64(m.TickBufSize))
		i--
		dAtA[i] = 0x40
	}
	if m.InitPendingEntriesCap != 0 {
		i = encodeVarintConsensus(dAtA, i, uint64(m.InitPendingEntriesCap))
		i--
		dAtA[i] = 0x38
	}
	if m.InitBlockSeqCap != 0 {
		i = encodeVarintConsensus(dAtA, i, uint64(m.InitBlockSeqCap))
		i--
		dAtA[i] = 0x30
	}
	if m.TxBufSize != 0 {
		i = encodeVarintConsensus(dAtA, i, uint64(m.TxBufSize))
		i--
		dAtA[i] = 0x28
	}
	if m.TickInterval != 0 {
		i = encodeVarintConsensus(dAtA, i, uint64(m.TickInterval))
		i--
		dAtA[i] = 0x20
	}
	if m.TimeoutTick != 0 {
		i = encodeVarintConsensus(dAtA, i, uint64(m.TimeoutTick))
		i--
		dAtA[i] = 0x18
	}
	if m.MaxBlockSize != 0 {
		i = encodeVarintConsensus(dAtA, i, uint64(m.MaxBlockSize))
		i--
		dAtA[i] = 0x10
	}
	if m.MaxTxCount != 0 {
		i = encodeVarintConsensus(dAtA, i, uint64(m.MaxTxCount))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *Cons) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Cons) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Cons) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Type != nil {
		{
			size := m.Type.Size()
			i -= size
			if _, err := m.Type.MarshalTo(dAtA[i:]); err != nil {
				return 0, err
			}
		}
	}
	return len(dAtA) - i, nil
}

func (m *Cons_Identity) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Cons_Identity) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.Identity != nil {
		{
			size, err := m.Identity.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintConsensus(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}
func (m *Cons_Flic) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Cons_Flic) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.Flic != nil {
		{
			size, err := m.Flic.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintConsensus(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	return len(dAtA) - i, nil
}
func (m *Identity) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Identity) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Identity) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Cert) > 0 {
		i -= len(m.Cert)
		copy(dAtA[i:], m.Cert)
		i = encodeVarintConsensus(dAtA, i, uint64(len(m.Cert)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Addr) > 0 {
		i -= len(m.Addr)
		copy(dAtA[i:], m.Addr)
		i = encodeVarintConsensus(dAtA, i, uint64(len(m.Addr)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *ConfigChange) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ConfigChange) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ConfigChange) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Consenter != nil {
		{
			size, err := m.Consenter.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintConsensus(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	if m.Op != 0 {
		i = encodeVarintConsensus(dAtA, i, uint64(m.Op))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *Genesis) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Genesis) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Genesis) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Conf != nil {
		{
			size := m.Conf.Size()
			i -= size
			if _, err := m.Conf.MarshalTo(dAtA[i:]); err != nil {
				return 0, err
			}
		}
	}
	return len(dAtA) - i, nil
}

func (m *Genesis_Solo) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Genesis_Solo) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.Solo != nil {
		{
			size, err := m.Solo.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintConsensus(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}
func (m *Genesis_Raft) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Genesis_Raft) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.Raft != nil {
		{
			size, err := m.Raft.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintConsensus(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	return len(dAtA) - i, nil
}
func (m *Genesis_Flic) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Genesis_Flic) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.Flic != nil {
		{
			size, err := m.Flic.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintConsensus(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1a
	}
	return len(dAtA) - i, nil
}
func (m *Genesis_Hotstuff) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Genesis_Hotstuff) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.Hotstuff != nil {
		{
			size, err := m.Hotstuff.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintConsensus(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x22
	}
	return len(dAtA) - i, nil
}
func (m *RaftConfig) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *RaftConfig) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *RaftConfig) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Trusted {
		i--
		if m.Trusted {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x20
	}
	if len(m.PublicKey) > 0 {
		i -= len(m.PublicKey)
		copy(dAtA[i:], m.PublicKey)
		i = encodeVarintConsensus(dAtA, i, uint64(len(m.PublicKey)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.Signature) > 0 {
		i -= len(m.Signature)
		copy(dAtA[i:], m.Signature)
		i = encodeVarintConsensus(dAtA, i, uint64(len(m.Signature)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.InitialState) > 0 {
		i -= len(m.InitialState)
		copy(dAtA[i:], m.InitialState)
		i = encodeVarintConsensus(dAtA, i, uint64(len(m.InitialState)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *SoloConfig) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SoloConfig) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *SoloConfig) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	return len(dAtA) - i, nil
}

func (m *FlicConfig) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *FlicConfig) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *FlicConfig) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.ReqTimeout != 0 {
		i = encodeVarintConsensus(dAtA, i, uint64(m.ReqTimeout))
		i--
		dAtA[i] = 0x10
	}
	if m.MaxFaultNodes != 0 {
		i = encodeVarintConsensus(dAtA, i, uint64(m.MaxFaultNodes))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *HotStuffConfig) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *HotStuffConfig) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *HotStuffConfig) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.WaitTxDuration != 0 {
		i = encodeVarintConsensus(dAtA, i, uint64(m.WaitTxDuration))
		i--
		dAtA[i] = 0x68
	}
	if m.VerifyTimestamp {
		i--
		if m.VerifyTimestamp {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x60
	}
	if m.MemoryStore {
		i--
		if m.MemoryStore {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x58
	}
	if m.MaxBlockBatch != 0 {
		i = encodeVarintConsensus(dAtA, i, uint64(m.MaxBlockBatch))
		i--
		dAtA[i] = 0x50
	}
	if m.ForwardProp {
		i--
		if m.ForwardProp {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x48
	}
	if m.Type != 0 {
		i = encodeVarintConsensus(dAtA, i, uint64(m.Type))
		i--
		dAtA[i] = 0x40
	}
	if m.ViewTimeout != 0 {
		i = encodeVarintConsensus(dAtA, i, uint64(m.ViewTimeout))
		i--
		dAtA[i] = 0x38
	}
	if m.Tick != 0 {
		i = encodeVarintConsensus(dAtA, i, uint64(m.Tick))
		i--
		dAtA[i] = 0x30
	}
	if m.MaxPrunedBlocks != 0 {
		i = encodeVarintConsensus(dAtA, i, uint64(m.MaxPrunedBlocks))
		i--
		dAtA[i] = 0x28
	}
	if len(m.Learners) > 0 {
		for iNdEx := len(m.Learners) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.Learners[iNdEx])
			copy(dAtA[i:], m.Learners[iNdEx])
			i = encodeVarintConsensus(dAtA, i, uint64(len(m.Learners[iNdEx])))
			i--
			dAtA[i] = 0x22
		}
	}
	if len(m.Consenters) > 0 {
		for iNdEx := len(m.Consenters) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Consenters[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintConsensus(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x1a
		}
	}
	if len(m.Group) > 0 {
		i -= len(m.Group)
		copy(dAtA[i:], m.Group)
		i = encodeVarintConsensus(dAtA, i, uint64(len(m.Group)))
		i--
		dAtA[i] = 0x12
	}
	if m.Epoch != 0 {
		i = encodeVarintConsensus(dAtA, i, uint64(m.Epoch))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *ConsensusUpdate) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ConsensusUpdate) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ConsensusUpdate) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Update != nil {
		{
			size := m.Update.Size()
			i -= size
			if _, err := m.Update.MarshalTo(dAtA[i:]); err != nil {
				return 0, err
			}
		}
	}
	return len(dAtA) - i, nil
}

func (m *ConsensusUpdate_ConfChange) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ConsensusUpdate_ConfChange) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.ConfChange != nil {
		{
			size, err := m.ConfChange.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintConsensus(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}
func (m *ConsensusUpdate_Alg) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ConsensusUpdate_Alg) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	i = encodeVarintConsensus(dAtA, i, uint64(m.Alg))
	i--
	dAtA[i] = 0x10
	return len(dAtA) - i, nil
}
func (m *ConsensusUpdate_Props) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ConsensusUpdate_Props) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.Props != nil {
		{
			size, err := m.Props.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintConsensus(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1a
	}
	return len(dAtA) - i, nil
}
func (m *ConsensusUpdate_Properties) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ConsensusUpdate_Properties) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ConsensusUpdate_Properties) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Kv) > 0 {
		for k := range m.Kv {
			v := m.Kv[k]
			baseI := i
			i -= len(v)
			copy(dAtA[i:], v)
			i = encodeVarintConsensus(dAtA, i, uint64(len(v)))
			i--
			dAtA[i] = 0x12
			i -= len(k)
			copy(dAtA[i:], k)
			i = encodeVarintConsensus(dAtA, i, uint64(len(k)))
			i--
			dAtA[i] = 0xa
			i = encodeVarintConsensus(dAtA, i, uint64(baseI-i))
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *BlockHeaderInfo) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *BlockHeaderInfo) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *BlockHeaderInfo) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Timestamp != 0 {
		i = encodeVarintConsensus(dAtA, i, uint64(m.Timestamp))
		i--
		dAtA[i] = 0x20
	}
	if len(m.BodyHash) > 0 {
		i -= len(m.BodyHash)
		copy(dAtA[i:], m.BodyHash)
		i = encodeVarintConsensus(dAtA, i, uint64(len(m.BodyHash)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.ParentHash) > 0 {
		i -= len(m.ParentHash)
		copy(dAtA[i:], m.ParentHash)
		i = encodeVarintConsensus(dAtA, i, uint64(len(m.ParentHash)))
		i--
		dAtA[i] = 0x12
	}
	if m.Number != 0 {
		i = encodeVarintConsensus(dAtA, i, uint64(m.Number))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *ConsensusCertificate) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ConsensusCertificate) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ConsensusCertificate) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Certificate) > 0 {
		i -= len(m.Certificate)
		copy(dAtA[i:], m.Certificate)
		i = encodeVarintConsensus(dAtA, i, uint64(len(m.Certificate)))
		i--
		dAtA[i] = 0x12
	}
	if m.Alg != 0 {
		i = encodeVarintConsensus(dAtA, i, uint64(m.Alg))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *RaftCert) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *RaftCert) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *RaftCert) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Sign) > 0 {
		i -= len(m.Sign)
		copy(dAtA[i:], m.Sign)
		i = encodeVarintConsensus(dAtA, i, uint64(len(m.Sign)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Cert) > 0 {
		i -= len(m.Cert)
		copy(dAtA[i:], m.Cert)
		i = encodeVarintConsensus(dAtA, i, uint64(len(m.Cert)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func encodeVarintConsensus(dAtA []byte, offset int, v uint64) int {
	offset -= sovConsensus(v)
	base := offset
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return base
}
func (m *SysCons) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Type != 0 {
		n += 1 + sovConsensus(uint64(m.Type))
	}
	if m.Genesis != nil {
		l = m.Genesis.Size()
		n += 1 + l + sovConsensus(uint64(l))
	}
	if m.Conf != nil {
		l = m.Conf.Size()
		n += 1 + l + sovConsensus(uint64(l))
	}
	if len(m.Consenter) > 0 {
		for _, e := range m.Consenter {
			l = e.Size()
			n += 1 + l + sovConsensus(uint64(l))
		}
	}
	return n
}

func (m *CommonConfig) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.MaxTxCount != 0 {
		n += 1 + sovConsensus(uint64(m.MaxTxCount))
	}
	if m.MaxBlockSize != 0 {
		n += 1 + sovConsensus(uint64(m.MaxBlockSize))
	}
	if m.TimeoutTick != 0 {
		n += 1 + sovConsensus(uint64(m.TimeoutTick))
	}
	if m.TickInterval != 0 {
		n += 1 + sovConsensus(uint64(m.TickInterval))
	}
	if m.TxBufSize != 0 {
		n += 1 + sovConsensus(uint64(m.TxBufSize))
	}
	if m.InitBlockSeqCap != 0 {
		n += 1 + sovConsensus(uint64(m.InitBlockSeqCap))
	}
	if m.InitPendingEntriesCap != 0 {
		n += 1 + sovConsensus(uint64(m.InitPendingEntriesCap))
	}
	if m.TickBufSize != 0 {
		n += 1 + sovConsensus(uint64(m.TickBufSize))
	}
	if m.ProposedBlockBufSize != 0 {
		n += 1 + sovConsensus(uint64(m.ProposedBlockBufSize))
	}
	if m.CommittedBlockBufSize != 0 {
		n += 1 + sovConsensus(uint64(m.CommittedBlockBufSize))
	}
	if m.PersistedBlockBufSize != 0 {
		n += 1 + sovConsensus(uint64(m.PersistedBlockBufSize))
	}
	if m.MaxRoutines != 0 {
		n += 1 + sovConsensus(uint64(m.MaxRoutines))
	}
	if m.BlockLimitRate != 0 {
		n += 1 + sovConsensus(uint64(m.BlockLimitRate))
	}
	if m.TxLimitRate != 0 {
		n += 1 + sovConsensus(uint64(m.TxLimitRate))
	}
	if m.SendBufSize != 0 {
		n += 1 + sovConsensus(uint64(m.SendBufSize))
	}
	if m.RecvBufSize != 0 {
		n += 2 + sovConsensus(uint64(m.RecvBufSize))
	}
	return n
}

func (m *Cons) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Type != nil {
		n += m.Type.Size()
	}
	return n
}

func (m *Cons_Identity) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Identity != nil {
		l = m.Identity.Size()
		n += 1 + l + sovConsensus(uint64(l))
	}
	return n
}
func (m *Cons_Flic) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Flic != nil {
		l = m.Flic.Size()
		n += 1 + l + sovConsensus(uint64(l))
	}
	return n
}
func (m *Identity) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Addr)
	if l > 0 {
		n += 1 + l + sovConsensus(uint64(l))
	}
	l = len(m.Cert)
	if l > 0 {
		n += 1 + l + sovConsensus(uint64(l))
	}
	return n
}

func (m *ConfigChange) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Op != 0 {
		n += 1 + sovConsensus(uint64(m.Op))
	}
	if m.Consenter != nil {
		l = m.Consenter.Size()
		n += 1 + l + sovConsensus(uint64(l))
	}
	return n
}

func (m *Genesis) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Conf != nil {
		n += m.Conf.Size()
	}
	return n
}

func (m *Genesis_Solo) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Solo != nil {
		l = m.Solo.Size()
		n += 1 + l + sovConsensus(uint64(l))
	}
	return n
}
func (m *Genesis_Raft) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Raft != nil {
		l = m.Raft.Size()
		n += 1 + l + sovConsensus(uint64(l))
	}
	return n
}
func (m *Genesis_Flic) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Flic != nil {
		l = m.Flic.Size()
		n += 1 + l + sovConsensus(uint64(l))
	}
	return n
}
func (m *Genesis_Hotstuff) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Hotstuff != nil {
		l = m.Hotstuff.Size()
		n += 1 + l + sovConsensus(uint64(l))
	}
	return n
}
func (m *RaftConfig) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.InitialState)
	if l > 0 {
		n += 1 + l + sovConsensus(uint64(l))
	}
	l = len(m.Signature)
	if l > 0 {
		n += 1 + l + sovConsensus(uint64(l))
	}
	l = len(m.PublicKey)
	if l > 0 {
		n += 1 + l + sovConsensus(uint64(l))
	}
	if m.Trusted {
		n += 2
	}
	return n
}

func (m *SoloConfig) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	return n
}

func (m *FlicConfig) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.MaxFaultNodes != 0 {
		n += 1 + sovConsensus(uint64(m.MaxFaultNodes))
	}
	if m.ReqTimeout != 0 {
		n += 1 + sovConsensus(uint64(m.ReqTimeout))
	}
	return n
}

func (m *HotStuffConfig) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Epoch != 0 {
		n += 1 + sovConsensus(uint64(m.Epoch))
	}
	l = len(m.Group)
	if l > 0 {
		n += 1 + l + sovConsensus(uint64(l))
	}
	if len(m.Consenters) > 0 {
		for _, e := range m.Consenters {
			l = e.Size()
			n += 1 + l + sovConsensus(uint64(l))
		}
	}
	if len(m.Learners) > 0 {
		for _, s := range m.Learners {
			l = len(s)
			n += 1 + l + sovConsensus(uint64(l))
		}
	}
	if m.MaxPrunedBlocks != 0 {
		n += 1 + sovConsensus(uint64(m.MaxPrunedBlocks))
	}
	if m.Tick != 0 {
		n += 1 + sovConsensus(uint64(m.Tick))
	}
	if m.ViewTimeout != 0 {
		n += 1 + sovConsensus(uint64(m.ViewTimeout))
	}
	if m.Type != 0 {
		n += 1 + sovConsensus(uint64(m.Type))
	}
	if m.ForwardProp {
		n += 2
	}
	if m.MaxBlockBatch != 0 {
		n += 1 + sovConsensus(uint64(m.MaxBlockBatch))
	}
	if m.MemoryStore {
		n += 2
	}
	if m.VerifyTimestamp {
		n += 2
	}
	if m.WaitTxDuration != 0 {
		n += 1 + sovConsensus(uint64(m.WaitTxDuration))
	}
	return n
}

func (m *ConsensusUpdate) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Update != nil {
		n += m.Update.Size()
	}
	return n
}

func (m *ConsensusUpdate_ConfChange) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.ConfChange != nil {
		l = m.ConfChange.Size()
		n += 1 + l + sovConsensus(uint64(l))
	}
	return n
}
func (m *ConsensusUpdate_Alg) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	n += 1 + sovConsensus(uint64(m.Alg))
	return n
}
func (m *ConsensusUpdate_Props) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Props != nil {
		l = m.Props.Size()
		n += 1 + l + sovConsensus(uint64(l))
	}
	return n
}
func (m *ConsensusUpdate_Properties) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Kv) > 0 {
		for k, v := range m.Kv {
			_ = k
			_ = v
			mapEntrySize := 1 + len(k) + sovConsensus(uint64(len(k))) + 1 + len(v) + sovConsensus(uint64(len(v)))
			n += mapEntrySize + 1 + sovConsensus(uint64(mapEntrySize))
		}
	}
	return n
}

func (m *BlockHeaderInfo) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Number != 0 {
		n += 1 + sovConsensus(uint64(m.Number))
	}
	l = len(m.ParentHash)
	if l > 0 {
		n += 1 + l + sovConsensus(uint64(l))
	}
	l = len(m.BodyHash)
	if l > 0 {
		n += 1 + l + sovConsensus(uint64(l))
	}
	if m.Timestamp != 0 {
		n += 1 + sovConsensus(uint64(m.Timestamp))
	}
	return n
}

func (m *ConsensusCertificate) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Alg != 0 {
		n += 1 + sovConsensus(uint64(m.Alg))
	}
	l = len(m.Certificate)
	if l > 0 {
		n += 1 + l + sovConsensus(uint64(l))
	}
	return n
}

func (m *RaftCert) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Cert)
	if l > 0 {
		n += 1 + l + sovConsensus(uint64(l))
	}
	l = len(m.Sign)
	if l > 0 {
		n += 1 + l + sovConsensus(uint64(l))
	}
	return n
}

func sovConsensus(x uint64) (n int) {
	return (math_bits.Len64(x|1) + 6) / 7
}
func sozConsensus(x uint64) (n int) {
	return sovConsensus(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (m *SysCons) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowConsensus
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SysCons: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SysCons: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Type", wireType)
			}
			m.Type = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowConsensus
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Type |= ConsType(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Genesis", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowConsensus
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthConsensus
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthConsensus
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Genesis == nil {
				m.Genesis = &Genesis{}
			}
			if err := m.Genesis.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Conf", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowConsensus
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthConsensus
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthConsensus
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Conf == nil {
				m.Conf = &CommonConfig{}
			}
			if err := m.Conf.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Consenter", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowConsensus
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthConsensus
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthConsensus
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Consenter = append(m.Consenter, &Consenter{})
			if err := m.Consenter[len(m.Consenter)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipConsensus(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthConsensus
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CommonConfig) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowConsensus
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CommonConfig: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CommonConfig: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MaxTxCount", wireType)
			}
			m.MaxTxCount = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowConsensus
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MaxTxCount |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MaxBlockSize", wireType)
			}
			m.MaxBlockSize = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowConsensus
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MaxBlockSize |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TimeoutTick", wireType)
			}
			m.TimeoutTick = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowConsensus
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TimeoutTick |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TickInterval", wireType)
			}
			m.TickInterval = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowConsensus
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TickInterval |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TxBufSize", wireType)
			}
			m.TxBufSize = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowConsensus
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TxBufSize |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field InitBlockSeqCap", wireType)
			}
			m.InitBlockSeqCap = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowConsensus
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.InitBlockSeqCap |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field InitPendingEntriesCap", wireType)
			}
			m.InitPendingEntriesCap = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowConsensus
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.InitPendingEntriesCap |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 8:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TickBufSize", wireType)
			}
			m.TickBufSize = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowConsensus
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TickBufSize |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 9:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ProposedBlockBufSize", wireType)
			}
			m.ProposedBlockBufSize = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowConsensus
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ProposedBlockBufSize |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 10:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CommittedBlockBufSize", wireType)
			}
			m.CommittedBlockBufSize = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowConsensus
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.CommittedBlockBufSize |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 11:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field PersistedBlockBufSize", wireType)
			}
			m.PersistedBlockBufSize = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowConsensus
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.PersistedBlockBufSize |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 12:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MaxRoutines", wireType)
			}
			m.MaxRoutines = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowConsensus
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MaxRoutines |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 13:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field BlockLimitRate", wireType)
			}
			m.BlockLimitRate = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowConsensus
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.BlockLimitRate |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 14:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TxLimitRate", wireType)
			}
			m.TxLimitRate = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowConsensus
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TxLimitRate |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 15:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SendBufSize", wireType)
			}
			m.SendBufSize = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowConsensus
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.SendBufSize |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 16:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RecvBufSize", wireType)
			}
			m.RecvBufSize = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowConsensus
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.RecvBufSize |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipConsensus(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthConsensus
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Cons) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowConsensus
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Cons: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Cons: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Identity", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowConsensus
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthConsensus
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthConsensus
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &Identity{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Type = &Cons_Identity{v}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Flic", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowConsensus
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthConsensus
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthConsensus
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &Flic{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Type = &Cons_Flic{v}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipConsensus(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthConsensus
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Identity) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowConsensus
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Identity: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Identity: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Addr", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowConsensus
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthConsensus
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthConsensus
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Addr = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Cert", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowConsensus
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthConsensus
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthConsensus
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Cert = append(m.Cert[:0], dAtA[iNdEx:postIndex]...)
			if m.Cert == nil {
				m.Cert = []byte{}
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipConsensus(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthConsensus
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ConfigChange) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowConsensus
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ConfigChange: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ConfigChange: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Op", wireType)
			}
			m.Op = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowConsensus
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Op |= ConfOp(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Consenter", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowConsensus
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthConsensus
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthConsensus
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Consenter == nil {
				m.Consenter = &Consenter{}
			}
			if err := m.Consenter.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipConsensus(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthConsensus
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Genesis) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowConsensus
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Genesis: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Genesis: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Solo", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowConsensus
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthConsensus
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthConsensus
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &SoloConfig{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Conf = &Genesis_Solo{v}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Raft", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowConsensus
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthConsensus
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthConsensus
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &RaftConfig{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Conf = &Genesis_Raft{v}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Flic", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowConsensus
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthConsensus
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthConsensus
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &FlicConfig{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Conf = &Genesis_Flic{v}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Hotstuff", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowConsensus
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthConsensus
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthConsensus
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &HotStuffConfig{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Conf = &Genesis_Hotstuff{v}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipConsensus(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthConsensus
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *RaftConfig) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowConsensus
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: RaftConfig: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: RaftConfig: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field InitialState", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowConsensus
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthConsensus
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthConsensus
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.InitialState = append(m.InitialState[:0], dAtA[iNdEx:postIndex]...)
			if m.InitialState == nil {
				m.InitialState = []byte{}
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Signature", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowConsensus
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthConsensus
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthConsensus
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Signature = append(m.Signature[:0], dAtA[iNdEx:postIndex]...)
			if m.Signature == nil {
				m.Signature = []byte{}
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PublicKey", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowConsensus
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthConsensus
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthConsensus
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.PublicKey = append(m.PublicKey[:0], dAtA[iNdEx:postIndex]...)
			if m.PublicKey == nil {
				m.PublicKey = []byte{}
			}
			iNdEx = postIndex
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Trusted", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowConsensus
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Trusted = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipConsensus(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthConsensus
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SoloConfig) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowConsensus
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SoloConfig: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SoloConfig: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipConsensus(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthConsensus
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *FlicConfig) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowConsensus
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: FlicConfig: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: FlicConfig: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MaxFaultNodes", wireType)
			}
			m.MaxFaultNodes = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowConsensus
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MaxFaultNodes |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ReqTimeout", wireType)
			}
			m.ReqTimeout = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowConsensus
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ReqTimeout |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipConsensus(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthConsensus
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *HotStuffConfig) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowConsensus
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: HotStuffConfig: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: HotStuffConfig: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Epoch", wireType)
			}
			m.Epoch = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowConsensus
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Epoch |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Group", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowConsensus
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthConsensus
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthConsensus
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Group = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Consenters", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowConsensus
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthConsensus
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthConsensus
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Consenters = append(m.Consenters, &Consenter{})
			if err := m.Consenters[len(m.Consenters)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Learners", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowConsensus
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthConsensus
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthConsensus
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Learners = append(m.Learners, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MaxPrunedBlocks", wireType)
			}
			m.MaxPrunedBlocks = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowConsensus
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MaxPrunedBlocks |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Tick", wireType)
			}
			m.Tick = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowConsensus
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Tick |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ViewTimeout", wireType)
			}
			m.ViewTimeout = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowConsensus
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ViewTimeout |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 8:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Type", wireType)
			}
			m.Type = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowConsensus
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Type |= ProposerType(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 9:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ForwardProp", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowConsensus
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.ForwardProp = bool(v != 0)
		case 10:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MaxBlockBatch", wireType)
			}
			m.MaxBlockBatch = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowConsensus
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MaxBlockBatch |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 11:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MemoryStore", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowConsensus
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.MemoryStore = bool(v != 0)
		case 12:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field VerifyTimestamp", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowConsensus
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.VerifyTimestamp = bool(v != 0)
		case 13:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field WaitTxDuration", wireType)
			}
			m.WaitTxDuration = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowConsensus
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.WaitTxDuration |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipConsensus(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthConsensus
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ConsensusUpdate) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowConsensus
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ConsensusUpdate: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ConsensusUpdate: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ConfChange", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowConsensus
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthConsensus
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthConsensus
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &ConfigChange{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Update = &ConsensusUpdate_ConfChange{v}
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Alg", wireType)
			}
			var v ConsType
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowConsensus
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= ConsType(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Update = &ConsensusUpdate_Alg{v}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Props", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowConsensus
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthConsensus
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthConsensus
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &ConsensusUpdate_Properties{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Update = &ConsensusUpdate_Props{v}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipConsensus(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthConsensus
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ConsensusUpdate_Properties) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowConsensus
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Properties: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Properties: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Kv", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowConsensus
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthConsensus
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthConsensus
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Kv == nil {
				m.Kv = make(map[string]string)
			}
			var mapkey string
			var mapvalue string
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowConsensus
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					var stringLenmapkey uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowConsensus
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapkey |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapkey := int(stringLenmapkey)
					if intStringLenmapkey < 0 {
						return ErrInvalidLengthConsensus
					}
					postStringIndexmapkey := iNdEx + intStringLenmapkey
					if postStringIndexmapkey < 0 {
						return ErrInvalidLengthConsensus
					}
					if postStringIndexmapkey > l {
						return io.ErrUnexpectedEOF
					}
					mapkey = string(dAtA[iNdEx:postStringIndexmapkey])
					iNdEx = postStringIndexmapkey
				} else if fieldNum == 2 {
					var stringLenmapvalue uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowConsensus
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapvalue |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapvalue := int(stringLenmapvalue)
					if intStringLenmapvalue < 0 {
						return ErrInvalidLengthConsensus
					}
					postStringIndexmapvalue := iNdEx + intStringLenmapvalue
					if postStringIndexmapvalue < 0 {
						return ErrInvalidLengthConsensus
					}
					if postStringIndexmapvalue > l {
						return io.ErrUnexpectedEOF
					}
					mapvalue = string(dAtA[iNdEx:postStringIndexmapvalue])
					iNdEx = postStringIndexmapvalue
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipConsensus(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if (skippy < 0) || (iNdEx+skippy) < 0 {
						return ErrInvalidLengthConsensus
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.Kv[mapkey] = mapvalue
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipConsensus(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthConsensus
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *BlockHeaderInfo) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowConsensus
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: BlockHeaderInfo: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: BlockHeaderInfo: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Number", wireType)
			}
			m.Number = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowConsensus
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Number |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ParentHash", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowConsensus
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthConsensus
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthConsensus
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ParentHash = append(m.ParentHash[:0], dAtA[iNdEx:postIndex]...)
			if m.ParentHash == nil {
				m.ParentHash = []byte{}
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field BodyHash", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowConsensus
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthConsensus
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthConsensus
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.BodyHash = append(m.BodyHash[:0], dAtA[iNdEx:postIndex]...)
			if m.BodyHash == nil {
				m.BodyHash = []byte{}
			}
			iNdEx = postIndex
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Timestamp", wireType)
			}
			m.Timestamp = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowConsensus
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Timestamp |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipConsensus(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthConsensus
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ConsensusCertificate) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowConsensus
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ConsensusCertificate: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ConsensusCertificate: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Alg", wireType)
			}
			m.Alg = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowConsensus
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Alg |= ConsType(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Certificate", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowConsensus
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthConsensus
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthConsensus
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Certificate = append(m.Certificate[:0], dAtA[iNdEx:postIndex]...)
			if m.Certificate == nil {
				m.Certificate = []byte{}
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipConsensus(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthConsensus
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *RaftCert) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowConsensus
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: RaftCert: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: RaftCert: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Cert", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowConsensus
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthConsensus
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthConsensus
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Cert = append(m.Cert[:0], dAtA[iNdEx:postIndex]...)
			if m.Cert == nil {
				m.Cert = []byte{}
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Sign", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowConsensus
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthConsensus
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthConsensus
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Sign = append(m.Sign[:0], dAtA[iNdEx:postIndex]...)
			if m.Sign == nil {
				m.Sign = []byte{}
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipConsensus(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthConsensus
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipConsensus(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	depth := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowConsensus
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowConsensus
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
		case 1:
			iNdEx += 8
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowConsensus
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if length < 0 {
				return 0, ErrInvalidLengthConsensus
			}
			iNdEx += length
		case 3:
			depth++
		case 4:
			if depth == 0 {
				return 0, ErrUnexpectedEndOfGroupConsensus
			}
			depth--
		case 5:
			iNdEx += 4
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
		if iNdEx < 0 {
			return 0, ErrInvalidLengthConsensus
		}
		if depth == 0 {
			return iNdEx, nil
		}
	}
	return 0, io.ErrUnexpectedEOF
}

var (
	ErrInvalidLengthConsensus        = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowConsensus          = fmt.Errorf("proto: integer overflow")
	ErrUnexpectedEndOfGroupConsensus = fmt.Errorf("proto: unexpected end of group")
)
