// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: consensus/flic.proto

package consensus

import (
	fmt "fmt"
	common "git.huawei.com/huaweichain/proto/common"
	_ "github.com/gogo/protobuf/gogoproto"
	proto "github.com/gogo/protobuf/proto"
	io "io"
	math "math"
	math_bits "math/bits"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.GoGoProtoPackageIsVersion3 // please upgrade the proto package

type Flic struct {
	// Types that are valid to be assigned to Type:
	//	*Flic_Request
	//	*Flic_Append
	//	*Flic_Confirm
	//	*Flic_Commit
	//	*Flic_Viewchange
	//	*Flic_Newview
	//	*Flic_QueryDiff
	//	*Flic_RspDiff
	//	*Flic_QueryPkg
	//	*Flic_RspPkg
	//	*Flic_Finish
	Type isFlic_Type `protobuf_oneof:"type"`
}

func (m *Flic) Reset()         { *m = Flic{} }
func (m *Flic) String() string { return proto.CompactTextString(m) }
func (*Flic) ProtoMessage()    {}
func (*Flic) Descriptor() ([]byte, []int) {
	return fileDescriptor_7eaf5410d4a8d2ac, []int{0}
}
func (m *Flic) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Flic) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Flic.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Flic) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Flic.Merge(m, src)
}
func (m *Flic) XXX_Size() int {
	return m.Size()
}
func (m *Flic) XXX_DiscardUnknown() {
	xxx_messageInfo_Flic.DiscardUnknown(m)
}

var xxx_messageInfo_Flic proto.InternalMessageInfo

type isFlic_Type interface {
	isFlic_Type()
	MarshalTo([]byte) (int, error)
	Size() int
}

type Flic_Request struct {
	Request *Request `protobuf:"bytes,1,opt,name=request,proto3,oneof" json:"request,omitempty"`
}
type Flic_Append struct {
	Append *Append `protobuf:"bytes,2,opt,name=append,proto3,oneof" json:"append,omitempty"`
}
type Flic_Confirm struct {
	Confirm *Confirm `protobuf:"bytes,3,opt,name=confirm,proto3,oneof" json:"confirm,omitempty"`
}
type Flic_Commit struct {
	Commit *Commit `protobuf:"bytes,4,opt,name=commit,proto3,oneof" json:"commit,omitempty"`
}
type Flic_Viewchange struct {
	Viewchange *ViewChange `protobuf:"bytes,5,opt,name=viewchange,proto3,oneof" json:"viewchange,omitempty"`
}
type Flic_Newview struct {
	Newview *NewView `protobuf:"bytes,6,opt,name=newview,proto3,oneof" json:"newview,omitempty"`
}
type Flic_QueryDiff struct {
	QueryDiff *QueryDiff `protobuf:"bytes,7,opt,name=queryDiff,proto3,oneof" json:"queryDiff,omitempty"`
}
type Flic_RspDiff struct {
	RspDiff *RspDiff `protobuf:"bytes,8,opt,name=rspDiff,proto3,oneof" json:"rspDiff,omitempty"`
}
type Flic_QueryPkg struct {
	QueryPkg *QueryPkg `protobuf:"bytes,9,opt,name=queryPkg,proto3,oneof" json:"queryPkg,omitempty"`
}
type Flic_RspPkg struct {
	RspPkg *RspPkg `protobuf:"bytes,10,opt,name=rspPkg,proto3,oneof" json:"rspPkg,omitempty"`
}
type Flic_Finish struct {
	Finish *Finish `protobuf:"bytes,11,opt,name=finish,proto3,oneof" json:"finish,omitempty"`
}

func (*Flic_Request) isFlic_Type()    {}
func (*Flic_Append) isFlic_Type()     {}
func (*Flic_Confirm) isFlic_Type()    {}
func (*Flic_Commit) isFlic_Type()     {}
func (*Flic_Viewchange) isFlic_Type() {}
func (*Flic_Newview) isFlic_Type()    {}
func (*Flic_QueryDiff) isFlic_Type()  {}
func (*Flic_RspDiff) isFlic_Type()    {}
func (*Flic_QueryPkg) isFlic_Type()   {}
func (*Flic_RspPkg) isFlic_Type()     {}
func (*Flic_Finish) isFlic_Type()     {}

func (m *Flic) GetType() isFlic_Type {
	if m != nil {
		return m.Type
	}
	return nil
}

func (m *Flic) GetRequest() *Request {
	if x, ok := m.GetType().(*Flic_Request); ok {
		return x.Request
	}
	return nil
}

func (m *Flic) GetAppend() *Append {
	if x, ok := m.GetType().(*Flic_Append); ok {
		return x.Append
	}
	return nil
}

func (m *Flic) GetConfirm() *Confirm {
	if x, ok := m.GetType().(*Flic_Confirm); ok {
		return x.Confirm
	}
	return nil
}

func (m *Flic) GetCommit() *Commit {
	if x, ok := m.GetType().(*Flic_Commit); ok {
		return x.Commit
	}
	return nil
}

func (m *Flic) GetViewchange() *ViewChange {
	if x, ok := m.GetType().(*Flic_Viewchange); ok {
		return x.Viewchange
	}
	return nil
}

func (m *Flic) GetNewview() *NewView {
	if x, ok := m.GetType().(*Flic_Newview); ok {
		return x.Newview
	}
	return nil
}

func (m *Flic) GetQueryDiff() *QueryDiff {
	if x, ok := m.GetType().(*Flic_QueryDiff); ok {
		return x.QueryDiff
	}
	return nil
}

func (m *Flic) GetRspDiff() *RspDiff {
	if x, ok := m.GetType().(*Flic_RspDiff); ok {
		return x.RspDiff
	}
	return nil
}

func (m *Flic) GetQueryPkg() *QueryPkg {
	if x, ok := m.GetType().(*Flic_QueryPkg); ok {
		return x.QueryPkg
	}
	return nil
}

func (m *Flic) GetRspPkg() *RspPkg {
	if x, ok := m.GetType().(*Flic_RspPkg); ok {
		return x.RspPkg
	}
	return nil
}

func (m *Flic) GetFinish() *Finish {
	if x, ok := m.GetType().(*Flic_Finish); ok {
		return x.Finish
	}
	return nil
}

// XXX_OneofWrappers is for the internal use of the proto package.
func (*Flic) XXX_OneofWrappers() []interface{} {
	return []interface{}{
		(*Flic_Request)(nil),
		(*Flic_Append)(nil),
		(*Flic_Confirm)(nil),
		(*Flic_Commit)(nil),
		(*Flic_Viewchange)(nil),
		(*Flic_Newview)(nil),
		(*Flic_QueryDiff)(nil),
		(*Flic_RspDiff)(nil),
		(*Flic_QueryPkg)(nil),
		(*Flic_RspPkg)(nil),
		(*Flic_Finish)(nil),
	}
}

type Request struct {
	Payload []byte `protobuf:"bytes,1,opt,name=payload,proto3" json:"payload,omitempty"`
}

func (m *Request) Reset()         { *m = Request{} }
func (m *Request) String() string { return proto.CompactTextString(m) }
func (*Request) ProtoMessage()    {}
func (*Request) Descriptor() ([]byte, []int) {
	return fileDescriptor_7eaf5410d4a8d2ac, []int{1}
}
func (m *Request) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Request) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Request.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Request) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Request.Merge(m, src)
}
func (m *Request) XXX_Size() int {
	return m.Size()
}
func (m *Request) XXX_DiscardUnknown() {
	xxx_messageInfo_Request.DiscardUnknown(m)
}

var xxx_messageInfo_Request proto.InternalMessageInfo

type SeqView struct {
	View uint64 `protobuf:"varint,1,opt,name=view,proto3" json:"view,omitempty"`
	Seq  uint64 `protobuf:"varint,2,opt,name=seq,proto3" json:"seq,omitempty"`
}

func (m *SeqView) Reset()         { *m = SeqView{} }
func (m *SeqView) String() string { return proto.CompactTextString(m) }
func (*SeqView) ProtoMessage()    {}
func (*SeqView) Descriptor() ([]byte, []int) {
	return fileDescriptor_7eaf5410d4a8d2ac, []int{2}
}
func (m *SeqView) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *SeqView) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_SeqView.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *SeqView) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SeqView.Merge(m, src)
}
func (m *SeqView) XXX_Size() int {
	return m.Size()
}
func (m *SeqView) XXX_DiscardUnknown() {
	xxx_messageInfo_SeqView.DiscardUnknown(m)
}

var xxx_messageInfo_SeqView proto.InternalMessageInfo

type BatchHeader struct {
	Seq      uint64 `protobuf:"varint,1,opt,name=seq,proto3" json:"seq,omitempty"`
	DataHash []byte `protobuf:"bytes,2,opt,name=data_hash,json=dataHash,proto3" json:"data_hash,omitempty"`
}

func (m *BatchHeader) Reset()         { *m = BatchHeader{} }
func (m *BatchHeader) String() string { return proto.CompactTextString(m) }
func (*BatchHeader) ProtoMessage()    {}
func (*BatchHeader) Descriptor() ([]byte, []int) {
	return fileDescriptor_7eaf5410d4a8d2ac, []int{3}
}
func (m *BatchHeader) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *BatchHeader) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_BatchHeader.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *BatchHeader) XXX_Merge(src proto.Message) {
	xxx_messageInfo_BatchHeader.Merge(m, src)
}
func (m *BatchHeader) XXX_Size() int {
	return m.Size()
}
func (m *BatchHeader) XXX_DiscardUnknown() {
	xxx_messageInfo_BatchHeader.DiscardUnknown(m)
}

var xxx_messageInfo_BatchHeader proto.InternalMessageInfo

type Batch struct {
	Header     []byte            `protobuf:"bytes,1,opt,name=header,proto3" json:"header,omitempty"`
	Payloads   [][]byte          `protobuf:"bytes,2,rep,name=payloads,proto3" json:"payloads,omitempty"`
	Signatures map[uint64][]byte `protobuf:"bytes,3,rep,name=signatures,proto3" json:"signatures,omitempty" protobuf_key:"varint,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value,proto3"`
}

func (m *Batch) Reset()         { *m = Batch{} }
func (m *Batch) String() string { return proto.CompactTextString(m) }
func (*Batch) ProtoMessage()    {}
func (*Batch) Descriptor() ([]byte, []int) {
	return fileDescriptor_7eaf5410d4a8d2ac, []int{4}
}
func (m *Batch) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Batch) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Batch.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Batch) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Batch.Merge(m, src)
}
func (m *Batch) XXX_Size() int {
	return m.Size()
}
func (m *Batch) XXX_DiscardUnknown() {
	xxx_messageInfo_Batch.DiscardUnknown(m)
}

var xxx_messageInfo_Batch proto.InternalMessageInfo

type Append struct {
	Seq   *SeqView `protobuf:"bytes,1,opt,name=seq,proto3" json:"seq,omitempty"`
	Batch *Batch   `protobuf:"bytes,2,opt,name=batch,proto3" json:"batch,omitempty"`
}

func (m *Append) Reset()         { *m = Append{} }
func (m *Append) String() string { return proto.CompactTextString(m) }
func (*Append) ProtoMessage()    {}
func (*Append) Descriptor() ([]byte, []int) {
	return fileDescriptor_7eaf5410d4a8d2ac, []int{5}
}
func (m *Append) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Append) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Append.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Append) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Append.Merge(m, src)
}
func (m *Append) XXX_Size() int {
	return m.Size()
}
func (m *Append) XXX_DiscardUnknown() {
	xxx_messageInfo_Append.DiscardUnknown(m)
}

var xxx_messageInfo_Append proto.InternalMessageInfo

type Subject struct {
	Seq    *SeqView `protobuf:"bytes,1,opt,name=seq,proto3" json:"seq,omitempty"`
	Digest []byte   `protobuf:"bytes,2,opt,name=digest,proto3" json:"digest,omitempty"`
}

func (m *Subject) Reset()         { *m = Subject{} }
func (m *Subject) String() string { return proto.CompactTextString(m) }
func (*Subject) ProtoMessage()    {}
func (*Subject) Descriptor() ([]byte, []int) {
	return fileDescriptor_7eaf5410d4a8d2ac, []int{6}
}
func (m *Subject) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Subject) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Subject.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Subject) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Subject.Merge(m, src)
}
func (m *Subject) XXX_Size() int {
	return m.Size()
}
func (m *Subject) XXX_DiscardUnknown() {
	xxx_messageInfo_Subject.DiscardUnknown(m)
}

var xxx_messageInfo_Subject proto.InternalMessageInfo

type Confirm struct {
	Seq    *SeqView `protobuf:"bytes,1,opt,name=seq,proto3" json:"seq,omitempty"`
	Digest []byte   `protobuf:"bytes,2,opt,name=digest,proto3" json:"digest,omitempty"`
}

func (m *Confirm) Reset()         { *m = Confirm{} }
func (m *Confirm) String() string { return proto.CompactTextString(m) }
func (*Confirm) ProtoMessage()    {}
func (*Confirm) Descriptor() ([]byte, []int) {
	return fileDescriptor_7eaf5410d4a8d2ac, []int{7}
}
func (m *Confirm) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Confirm) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Confirm.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Confirm) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Confirm.Merge(m, src)
}
func (m *Confirm) XXX_Size() int {
	return m.Size()
}
func (m *Confirm) XXX_DiscardUnknown() {
	xxx_messageInfo_Confirm.DiscardUnknown(m)
}

var xxx_messageInfo_Confirm proto.InternalMessageInfo

type Commit struct {
	Seq        *SeqView          `protobuf:"bytes,1,opt,name=seq,proto3" json:"seq,omitempty"`
	Digest     []byte            `protobuf:"bytes,2,opt,name=digest,proto3" json:"digest,omitempty"`
	Signatures map[uint64][]byte `protobuf:"bytes,3,rep,name=signatures,proto3" json:"signatures,omitempty" protobuf_key:"varint,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value,proto3"`
}

func (m *Commit) Reset()         { *m = Commit{} }
func (m *Commit) String() string { return proto.CompactTextString(m) }
func (*Commit) ProtoMessage()    {}
func (*Commit) Descriptor() ([]byte, []int) {
	return fileDescriptor_7eaf5410d4a8d2ac, []int{8}
}
func (m *Commit) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Commit) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Commit.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Commit) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Commit.Merge(m, src)
}
func (m *Commit) XXX_Size() int {
	return m.Size()
}
func (m *Commit) XXX_DiscardUnknown() {
	xxx_messageInfo_Commit.DiscardUnknown(m)
}

var xxx_messageInfo_Commit proto.InternalMessageInfo

type ViewChange struct {
	View        uint64 `protobuf:"varint,1,opt,name=view,proto3" json:"view,omitempty"`
	Seq         uint64 `protobuf:"varint,2,opt,name=seq,proto3" json:"seq,omitempty"`
	Batchheader []byte `protobuf:"bytes,3,opt,name=batchheader,proto3" json:"batchheader,omitempty"`
}

func (m *ViewChange) Reset()         { *m = ViewChange{} }
func (m *ViewChange) String() string { return proto.CompactTextString(m) }
func (*ViewChange) ProtoMessage()    {}
func (*ViewChange) Descriptor() ([]byte, []int) {
	return fileDescriptor_7eaf5410d4a8d2ac, []int{9}
}
func (m *ViewChange) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ViewChange) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ViewChange.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ViewChange) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ViewChange.Merge(m, src)
}
func (m *ViewChange) XXX_Size() int {
	return m.Size()
}
func (m *ViewChange) XXX_DiscardUnknown() {
	xxx_messageInfo_ViewChange.DiscardUnknown(m)
}

var xxx_messageInfo_ViewChange proto.InternalMessageInfo

type NewView struct {
	View       uint64            `protobuf:"varint,1,opt,name=view,proto3" json:"view,omitempty"`
	Seq        uint64            `protobuf:"varint,2,opt,name=seq,proto3" json:"seq,omitempty"`
	Batch      *Batch            `protobuf:"bytes,3,opt,name=batch,proto3" json:"batch,omitempty"`
	Signatures map[uint64][]byte `protobuf:"bytes,4,rep,name=signatures,proto3" json:"signatures,omitempty" protobuf_key:"varint,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value,proto3"`
}

func (m *NewView) Reset()         { *m = NewView{} }
func (m *NewView) String() string { return proto.CompactTextString(m) }
func (*NewView) ProtoMessage()    {}
func (*NewView) Descriptor() ([]byte, []int) {
	return fileDescriptor_7eaf5410d4a8d2ac, []int{10}
}
func (m *NewView) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *NewView) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_NewView.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *NewView) XXX_Merge(src proto.Message) {
	xxx_messageInfo_NewView.Merge(m, src)
}
func (m *NewView) XXX_Size() int {
	return m.Size()
}
func (m *NewView) XXX_DiscardUnknown() {
	xxx_messageInfo_NewView.DiscardUnknown(m)
}

var xxx_messageInfo_NewView proto.InternalMessageInfo

// recovery process messages
type QueryDiff struct {
	View uint64 `protobuf:"varint,1,opt,name=view,proto3" json:"view,omitempty"`
	Seq  uint64 `protobuf:"varint,2,opt,name=seq,proto3" json:"seq,omitempty"`
}

func (m *QueryDiff) Reset()         { *m = QueryDiff{} }
func (m *QueryDiff) String() string { return proto.CompactTextString(m) }
func (*QueryDiff) ProtoMessage()    {}
func (*QueryDiff) Descriptor() ([]byte, []int) {
	return fileDescriptor_7eaf5410d4a8d2ac, []int{11}
}
func (m *QueryDiff) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *QueryDiff) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_QueryDiff.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *QueryDiff) XXX_Merge(src proto.Message) {
	xxx_messageInfo_QueryDiff.Merge(m, src)
}
func (m *QueryDiff) XXX_Size() int {
	return m.Size()
}
func (m *QueryDiff) XXX_DiscardUnknown() {
	xxx_messageInfo_QueryDiff.DiscardUnknown(m)
}

var xxx_messageInfo_QueryDiff proto.InternalMessageInfo

type PkgHeader struct {
	Start uint64 `protobuf:"varint,1,opt,name=start,proto3" json:"start,omitempty"`
	End   uint64 `protobuf:"varint,2,opt,name=end,proto3" json:"end,omitempty"`
	Hash  []byte `protobuf:"bytes,3,opt,name=hash,proto3" json:"hash,omitempty"`
}

func (m *PkgHeader) Reset()         { *m = PkgHeader{} }
func (m *PkgHeader) String() string { return proto.CompactTextString(m) }
func (*PkgHeader) ProtoMessage()    {}
func (*PkgHeader) Descriptor() ([]byte, []int) {
	return fileDescriptor_7eaf5410d4a8d2ac, []int{12}
}
func (m *PkgHeader) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *PkgHeader) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_PkgHeader.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *PkgHeader) XXX_Merge(src proto.Message) {
	xxx_messageInfo_PkgHeader.Merge(m, src)
}
func (m *PkgHeader) XXX_Size() int {
	return m.Size()
}
func (m *PkgHeader) XXX_DiscardUnknown() {
	xxx_messageInfo_PkgHeader.DiscardUnknown(m)
}

var xxx_messageInfo_PkgHeader proto.InternalMessageInfo

type RecoveryPkg struct {
	Blocks []*common.Block `protobuf:"bytes,1,rep,name=blocks,proto3" json:"blocks,omitempty"`
}

func (m *RecoveryPkg) Reset()         { *m = RecoveryPkg{} }
func (m *RecoveryPkg) String() string { return proto.CompactTextString(m) }
func (*RecoveryPkg) ProtoMessage()    {}
func (*RecoveryPkg) Descriptor() ([]byte, []int) {
	return fileDescriptor_7eaf5410d4a8d2ac, []int{13}
}
func (m *RecoveryPkg) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *RecoveryPkg) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_RecoveryPkg.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *RecoveryPkg) XXX_Merge(src proto.Message) {
	xxx_messageInfo_RecoveryPkg.Merge(m, src)
}
func (m *RecoveryPkg) XXX_Size() int {
	return m.Size()
}
func (m *RecoveryPkg) XXX_DiscardUnknown() {
	xxx_messageInfo_RecoveryPkg.DiscardUnknown(m)
}

var xxx_messageInfo_RecoveryPkg proto.InternalMessageInfo

type RspDiff struct {
	View       uint64       `protobuf:"varint,1,opt,name=view,proto3" json:"view,omitempty"`
	Status     uint64       `protobuf:"varint,2,opt,name=status,proto3" json:"status,omitempty"`
	PkgHeaders []*PkgHeader `protobuf:"bytes,3,rep,name=pkgHeaders,proto3" json:"pkgHeaders,omitempty"`
}

func (m *RspDiff) Reset()         { *m = RspDiff{} }
func (m *RspDiff) String() string { return proto.CompactTextString(m) }
func (*RspDiff) ProtoMessage()    {}
func (*RspDiff) Descriptor() ([]byte, []int) {
	return fileDescriptor_7eaf5410d4a8d2ac, []int{14}
}
func (m *RspDiff) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *RspDiff) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_RspDiff.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *RspDiff) XXX_Merge(src proto.Message) {
	xxx_messageInfo_RspDiff.Merge(m, src)
}
func (m *RspDiff) XXX_Size() int {
	return m.Size()
}
func (m *RspDiff) XXX_DiscardUnknown() {
	xxx_messageInfo_RspDiff.DiscardUnknown(m)
}

var xxx_messageInfo_RspDiff proto.InternalMessageInfo

type QueryPkg struct {
	Start uint64 `protobuf:"varint,1,opt,name=start,proto3" json:"start,omitempty"`
	End   uint64 `protobuf:"varint,2,opt,name=end,proto3" json:"end,omitempty"`
}

func (m *QueryPkg) Reset()         { *m = QueryPkg{} }
func (m *QueryPkg) String() string { return proto.CompactTextString(m) }
func (*QueryPkg) ProtoMessage()    {}
func (*QueryPkg) Descriptor() ([]byte, []int) {
	return fileDescriptor_7eaf5410d4a8d2ac, []int{15}
}
func (m *QueryPkg) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *QueryPkg) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_QueryPkg.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *QueryPkg) XXX_Merge(src proto.Message) {
	xxx_messageInfo_QueryPkg.Merge(m, src)
}
func (m *QueryPkg) XXX_Size() int {
	return m.Size()
}
func (m *QueryPkg) XXX_DiscardUnknown() {
	xxx_messageInfo_QueryPkg.DiscardUnknown(m)
}

var xxx_messageInfo_QueryPkg proto.InternalMessageInfo

type RspPkg struct {
	Pkg *RecoveryPkg `protobuf:"bytes,1,opt,name=pkg,proto3" json:"pkg,omitempty"`
}

func (m *RspPkg) Reset()         { *m = RspPkg{} }
func (m *RspPkg) String() string { return proto.CompactTextString(m) }
func (*RspPkg) ProtoMessage()    {}
func (*RspPkg) Descriptor() ([]byte, []int) {
	return fileDescriptor_7eaf5410d4a8d2ac, []int{16}
}
func (m *RspPkg) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *RspPkg) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_RspPkg.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *RspPkg) XXX_Merge(src proto.Message) {
	xxx_messageInfo_RspPkg.Merge(m, src)
}
func (m *RspPkg) XXX_Size() int {
	return m.Size()
}
func (m *RspPkg) XXX_DiscardUnknown() {
	xxx_messageInfo_RspPkg.DiscardUnknown(m)
}

var xxx_messageInfo_RspPkg proto.InternalMessageInfo

type Finish struct {
	Status uint64 `protobuf:"varint,1,opt,name=status,proto3" json:"status,omitempty"`
}

func (m *Finish) Reset()         { *m = Finish{} }
func (m *Finish) String() string { return proto.CompactTextString(m) }
func (*Finish) ProtoMessage()    {}
func (*Finish) Descriptor() ([]byte, []int) {
	return fileDescriptor_7eaf5410d4a8d2ac, []int{17}
}
func (m *Finish) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Finish) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Finish.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Finish) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Finish.Merge(m, src)
}
func (m *Finish) XXX_Size() int {
	return m.Size()
}
func (m *Finish) XXX_DiscardUnknown() {
	xxx_messageInfo_Finish.DiscardUnknown(m)
}

var xxx_messageInfo_Finish proto.InternalMessageInfo

func init() {
	proto.RegisterType((*Flic)(nil), "consensus.Flic")
	proto.RegisterType((*Request)(nil), "consensus.Request")
	proto.RegisterType((*SeqView)(nil), "consensus.SeqView")
	proto.RegisterType((*BatchHeader)(nil), "consensus.BatchHeader")
	proto.RegisterType((*Batch)(nil), "consensus.Batch")
	proto.RegisterMapType((map[uint64][]byte)(nil), "consensus.Batch.SignaturesEntry")
	proto.RegisterType((*Append)(nil), "consensus.Append")
	proto.RegisterType((*Subject)(nil), "consensus.Subject")
	proto.RegisterType((*Confirm)(nil), "consensus.Confirm")
	proto.RegisterType((*Commit)(nil), "consensus.Commit")
	proto.RegisterMapType((map[uint64][]byte)(nil), "consensus.Commit.SignaturesEntry")
	proto.RegisterType((*ViewChange)(nil), "consensus.ViewChange")
	proto.RegisterType((*NewView)(nil), "consensus.NewView")
	proto.RegisterMapType((map[uint64][]byte)(nil), "consensus.NewView.SignaturesEntry")
	proto.RegisterType((*QueryDiff)(nil), "consensus.QueryDiff")
	proto.RegisterType((*PkgHeader)(nil), "consensus.PkgHeader")
	proto.RegisterType((*RecoveryPkg)(nil), "consensus.RecoveryPkg")
	proto.RegisterType((*RspDiff)(nil), "consensus.RspDiff")
	proto.RegisterType((*QueryPkg)(nil), "consensus.QueryPkg")
	proto.RegisterType((*RspPkg)(nil), "consensus.RspPkg")
	proto.RegisterType((*Finish)(nil), "consensus.Finish")
}

func init() { proto.RegisterFile("consensus/flic.proto", fileDescriptor_7eaf5410d4a8d2ac) }

var fileDescriptor_7eaf5410d4a8d2ac = []byte{
	// 862 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xb4, 0x56, 0xdd, 0x6e, 0xe3, 0x44,
	0x14, 0xb6, 0x1b, 0xc7, 0x49, 0x4e, 0x16, 0xb1, 0x0c, 0xa1, 0xb2, 0x8a, 0x14, 0x05, 0xf3, 0xa3,
	0x4a, 0x48, 0x89, 0xb6, 0x54, 0x62, 0x85, 0x40, 0x62, 0x53, 0xd8, 0xcd, 0x15, 0x5a, 0xa6, 0x68,
	0x2f, 0xf6, 0x06, 0x4d, 0x9d, 0x89, 0x3d, 0x24, 0xb5, 0x1d, 0x8f, 0xdd, 0x28, 0x6f, 0xc1, 0x43,
	0xf0, 0x18, 0x3c, 0x40, 0x2f, 0x7b, 0x89, 0xb8, 0x62, 0xdb, 0x17, 0x41, 0x67, 0x66, 0xec, 0xba,
	0xf5, 0x6a, 0x15, 0x69, 0xd5, 0xbb, 0x99, 0x73, 0xbe, 0xf3, 0xe5, 0x9b, 0xcf, 0x67, 0xce, 0x04,
	0x06, 0x41, 0x12, 0x4b, 0x1e, 0xcb, 0x42, 0x4e, 0x16, 0x2b, 0x11, 0x8c, 0xd3, 0x2c, 0xc9, 0x13,
	0xd2, 0xab, 0xa2, 0x07, 0x83, 0x30, 0x09, 0x13, 0x15, 0x9d, 0xe0, 0x4a, 0x03, 0x0e, 0x48, 0x90,
	0x9c, 0x9f, 0x27, 0xf1, 0xe4, 0x6c, 0x95, 0x04, 0x4b, 0x1d, 0xf3, 0xff, 0x72, 0xc0, 0x79, 0xbe,
	0x12, 0x01, 0x19, 0x43, 0x27, 0xe3, 0xeb, 0x82, 0xcb, 0xdc, 0xb3, 0x47, 0xf6, 0x61, 0xff, 0x88,
	0x8c, 0x2b, 0xbe, 0x31, 0xd5, 0x99, 0x99, 0x45, 0x4b, 0x10, 0xf9, 0x1a, 0x5c, 0x96, 0xa6, 0x3c,
	0x9e, 0x7b, 0x7b, 0x0a, 0xfe, 0x51, 0x0d, 0xfe, 0x4c, 0x25, 0x66, 0x16, 0x35, 0x10, 0x24, 0x0f,
	0x92, 0x78, 0x21, 0xb2, 0x73, 0xaf, 0xd5, 0x20, 0x3f, 0xd1, 0x19, 0x24, 0x37, 0x20, 0x24, 0x47,
	0xad, 0x22, 0xf7, 0x9c, 0x06, 0xf9, 0x89, 0x4a, 0x20, 0xb9, 0x86, 0x90, 0x6f, 0x01, 0x2e, 0x04,
	0xdf, 0x04, 0x11, 0x8b, 0x43, 0xee, 0xb5, 0x55, 0xc1, 0x27, 0xb5, 0x82, 0x57, 0x82, 0x6f, 0x4e,
	0x54, 0x72, 0x66, 0xd1, 0x1a, 0x14, 0x55, 0xc5, 0x7c, 0x83, 0x01, 0xcf, 0x6d, 0xa8, 0xfa, 0x85,
	0x6f, 0xb0, 0x10, 0x55, 0x19, 0x10, 0x39, 0x86, 0xde, 0xba, 0xe0, 0xd9, 0xf6, 0x27, 0xb1, 0x58,
	0x78, 0x1d, 0x55, 0x31, 0xa8, 0x55, 0xfc, 0x5a, 0xe6, 0x66, 0x16, 0xbd, 0x05, 0x2a, 0x63, 0x65,
	0xaa, 0x6a, 0xba, 0x4d, 0x63, 0x75, 0x46, 0x19, 0xab, 0x97, 0xe4, 0x09, 0x74, 0x55, 0xf1, 0xcb,
	0x65, 0xe8, 0xf5, 0x54, 0xc1, 0xc7, 0xf7, 0x7f, 0xe4, 0xe5, 0x32, 0x9c, 0x59, 0xb4, 0x82, 0xa1,
	0x5d, 0x99, 0x4c, 0xb1, 0x00, 0x1a, 0x76, 0x51, 0x95, 0x40, 0xbb, 0x34, 0x04, 0xc1, 0x0b, 0x11,
	0x0b, 0x19, 0x79, 0xfd, 0x06, 0xf8, 0xb9, 0x4a, 0x20, 0x58, 0x43, 0xa6, 0x2e, 0x38, 0xf9, 0x36,
	0xe5, 0xfe, 0xe7, 0xd0, 0x31, 0x3d, 0x40, 0x3c, 0xe8, 0xa4, 0x6c, 0xbb, 0x4a, 0xd8, 0x5c, 0x35,
	0xca, 0x23, 0x5a, 0x6e, 0xfd, 0x09, 0x74, 0x4e, 0xf9, 0x1a, 0x5d, 0x23, 0x04, 0x1c, 0xe5, 0x2b,
	0x22, 0x1c, 0xaa, 0xd6, 0xe4, 0x31, 0xb4, 0x24, 0x5f, 0xab, 0x76, 0x71, 0x28, 0x2e, 0xfd, 0xef,
	0xa1, 0x3f, 0x65, 0x79, 0x10, 0xcd, 0x38, 0x9b, 0xf3, 0xac, 0x04, 0xd8, 0x15, 0x80, 0x7c, 0x0a,
	0xbd, 0x39, 0xcb, 0xd9, 0xef, 0x11, 0x93, 0x91, 0x2a, 0x7c, 0x44, 0xbb, 0x18, 0x98, 0x31, 0x19,
	0xf9, 0x7f, 0xdb, 0xd0, 0x56, 0xe5, 0x64, 0x1f, 0xdc, 0x48, 0x51, 0x18, 0x45, 0x66, 0x47, 0x0e,
	0xa0, 0x6b, 0xb4, 0x49, 0x6f, 0x6f, 0xd4, 0xc2, 0xea, 0x72, 0x4f, 0x7e, 0x04, 0x90, 0x22, 0x8c,
	0x59, 0x5e, 0x64, 0x5c, 0x7a, 0xad, 0x51, 0xeb, 0xb0, 0x7f, 0x34, 0xaa, 0x59, 0xa1, 0x98, 0xc7,
	0xa7, 0x15, 0xe4, 0xe7, 0x38, 0xcf, 0xb6, 0xb4, 0x56, 0x73, 0xf0, 0x03, 0x7c, 0x78, 0x2f, 0x8d,
	0x27, 0x58, 0xf2, 0x6d, 0x79, 0x82, 0x25, 0xdf, 0x92, 0x01, 0xb4, 0x2f, 0xd8, 0xaa, 0xe0, 0x46,
	0xbd, 0xde, 0x7c, 0xb7, 0xf7, 0xd4, 0xf6, 0x5f, 0x81, 0xab, 0xef, 0x09, 0xf9, 0xe2, 0xf6, 0xdc,
	0x77, 0xbb, 0xc3, 0xb8, 0xa9, 0xbd, 0xf8, 0x0a, 0xda, 0x67, 0xa8, 0xc9, 0xdc, 0xb7, 0xc7, 0xf7,
	0xb5, 0x52, 0x9d, 0xf6, 0x5f, 0x40, 0xe7, 0xb4, 0x38, 0xfb, 0x83, 0x07, 0xf9, 0x8e, 0xc4, 0xfb,
	0xe0, 0xce, 0x45, 0x88, 0x17, 0x5f, 0x6b, 0x34, 0x3b, 0x24, 0x32, 0x57, 0xf3, 0x3d, 0x89, 0x2e,
	0x6d, 0x70, 0xf5, 0xad, 0x7d, 0x3f, 0x22, 0xf2, 0xec, 0x2d, 0xdf, 0xec, 0xb3, 0xc6, 0x68, 0x78,
	0xc8, 0x8f, 0xf6, 0x1b, 0xc0, 0xed, 0x38, 0xd9, 0xad, 0xcb, 0xc9, 0x08, 0xfa, 0xea, 0xcb, 0x98,
	0x16, 0x6d, 0x29, 0xce, 0x7a, 0xc8, 0xff, 0xd7, 0x86, 0x8e, 0x99, 0x37, 0x3b, 0x72, 0x56, 0xcd,
	0xd0, 0x7a, 0x67, 0x33, 0x90, 0xe9, 0x1d, 0xc7, 0x1c, 0xe5, 0x98, 0xdf, 0x9c, 0x72, 0x0f, 0x69,
	0xd9, 0x13, 0xe8, 0x55, 0x93, 0x71, 0xc7, 0xb9, 0xf0, 0x02, 0x7a, 0x38, 0xb3, 0xf4, 0x25, 0x1e,
	0x40, 0x5b, 0xe6, 0x2c, 0xcb, 0x4d, 0x8d, 0xde, 0x60, 0x51, 0xf9, 0xf6, 0x38, 0x14, 0x97, 0x48,
	0xad, 0xc6, 0x84, 0xf6, 0x57, 0xad, 0xfd, 0x63, 0xe8, 0x53, 0x1e, 0x24, 0x17, 0x66, 0x4e, 0x7e,
	0x09, 0xae, 0x7a, 0xfb, 0xa4, 0x67, 0x2b, 0x27, 0x3e, 0x18, 0xeb, 0x17, 0x71, 0x3c, 0xc5, 0x28,
	0x35, 0x49, 0x7f, 0x09, 0x1d, 0x33, 0x97, 0xdf, 0xaa, 0x77, 0x1f, 0x5c, 0x99, 0xb3, 0xbc, 0x90,
	0xe6, 0xd7, 0xcd, 0x8e, 0x1c, 0x03, 0xa4, 0xa5, 0xea, 0xb2, 0x3b, 0xeb, 0xef, 0x43, 0x75, 0x24,
	0x5a, 0xc3, 0xf9, 0x47, 0xd0, 0x2d, 0x67, 0xfa, 0xae, 0x47, 0xf5, 0x8f, 0xc0, 0xd5, 0x63, 0x9d,
	0x1c, 0x42, 0x2b, 0x5d, 0x86, 0xe6, 0x3e, 0xed, 0xdf, 0x79, 0xb1, 0xab, 0x63, 0x53, 0x84, 0xf8,
	0x23, 0x70, 0xf5, 0x74, 0xaf, 0xe9, 0xb7, 0xeb, 0xfa, 0xa7, 0xaf, 0x2f, 0xdf, 0x0c, 0xad, 0xab,
	0x37, 0x43, 0xeb, 0xf2, 0x7a, 0x68, 0x5f, 0x5d, 0x0f, 0xed, 0xff, 0xae, 0x87, 0xf6, 0x9f, 0x37,
	0x43, 0xeb, 0xea, 0x66, 0x68, 0xfd, 0x73, 0x33, 0xb4, 0x5e, 0x3f, 0x0d, 0x45, 0x3e, 0x8e, 0x0a,
	0xb6, 0xe1, 0x02, 0x9d, 0x9b, 0xa4, 0x89, 0x90, 0x12, 0x7f, 0x92, 0x65, 0x41, 0x34, 0xd9, 0x08,
	0x1e, 0xf3, 0x2c, 0x88, 0x98, 0x88, 0x27, 0xfa, 0xbf, 0x47, 0x25, 0xe7, 0xcc, 0x55, 0x81, 0x6f,
	0xfe, 0x0f, 0x00, 0x00, 0xff, 0xff, 0x35, 0xbf, 0x93, 0xc4, 0xba, 0x08, 0x00, 0x00,
}

func (m *Flic) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Flic) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Flic) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Type != nil {
		{
			size := m.Type.Size()
			i -= size
			if _, err := m.Type.MarshalTo(dAtA[i:]); err != nil {
				return 0, err
			}
		}
	}
	return len(dAtA) - i, nil
}

func (m *Flic_Request) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Flic_Request) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.Request != nil {
		{
			size, err := m.Request.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintFlic(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}
func (m *Flic_Append) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Flic_Append) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.Append != nil {
		{
			size, err := m.Append.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintFlic(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	return len(dAtA) - i, nil
}
func (m *Flic_Confirm) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Flic_Confirm) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.Confirm != nil {
		{
			size, err := m.Confirm.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintFlic(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1a
	}
	return len(dAtA) - i, nil
}
func (m *Flic_Commit) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Flic_Commit) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.Commit != nil {
		{
			size, err := m.Commit.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintFlic(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x22
	}
	return len(dAtA) - i, nil
}
func (m *Flic_Viewchange) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Flic_Viewchange) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.Viewchange != nil {
		{
			size, err := m.Viewchange.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintFlic(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x2a
	}
	return len(dAtA) - i, nil
}
func (m *Flic_Newview) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Flic_Newview) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.Newview != nil {
		{
			size, err := m.Newview.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintFlic(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x32
	}
	return len(dAtA) - i, nil
}
func (m *Flic_QueryDiff) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Flic_QueryDiff) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.QueryDiff != nil {
		{
			size, err := m.QueryDiff.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintFlic(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x3a
	}
	return len(dAtA) - i, nil
}
func (m *Flic_RspDiff) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Flic_RspDiff) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.RspDiff != nil {
		{
			size, err := m.RspDiff.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintFlic(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x42
	}
	return len(dAtA) - i, nil
}
func (m *Flic_QueryPkg) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Flic_QueryPkg) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.QueryPkg != nil {
		{
			size, err := m.QueryPkg.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintFlic(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x4a
	}
	return len(dAtA) - i, nil
}
func (m *Flic_RspPkg) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Flic_RspPkg) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.RspPkg != nil {
		{
			size, err := m.RspPkg.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintFlic(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x52
	}
	return len(dAtA) - i, nil
}
func (m *Flic_Finish) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Flic_Finish) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.Finish != nil {
		{
			size, err := m.Finish.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintFlic(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x5a
	}
	return len(dAtA) - i, nil
}
func (m *Request) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Request) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Request) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Payload) > 0 {
		i -= len(m.Payload)
		copy(dAtA[i:], m.Payload)
		i = encodeVarintFlic(dAtA, i, uint64(len(m.Payload)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *SeqView) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SeqView) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *SeqView) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Seq != 0 {
		i = encodeVarintFlic(dAtA, i, uint64(m.Seq))
		i--
		dAtA[i] = 0x10
	}
	if m.View != 0 {
		i = encodeVarintFlic(dAtA, i, uint64(m.View))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *BatchHeader) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *BatchHeader) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *BatchHeader) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.DataHash) > 0 {
		i -= len(m.DataHash)
		copy(dAtA[i:], m.DataHash)
		i = encodeVarintFlic(dAtA, i, uint64(len(m.DataHash)))
		i--
		dAtA[i] = 0x12
	}
	if m.Seq != 0 {
		i = encodeVarintFlic(dAtA, i, uint64(m.Seq))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *Batch) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Batch) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Batch) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Signatures) > 0 {
		for k := range m.Signatures {
			v := m.Signatures[k]
			baseI := i
			if len(v) > 0 {
				i -= len(v)
				copy(dAtA[i:], v)
				i = encodeVarintFlic(dAtA, i, uint64(len(v)))
				i--
				dAtA[i] = 0x12
			}
			i = encodeVarintFlic(dAtA, i, uint64(k))
			i--
			dAtA[i] = 0x8
			i = encodeVarintFlic(dAtA, i, uint64(baseI-i))
			i--
			dAtA[i] = 0x1a
		}
	}
	if len(m.Payloads) > 0 {
		for iNdEx := len(m.Payloads) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.Payloads[iNdEx])
			copy(dAtA[i:], m.Payloads[iNdEx])
			i = encodeVarintFlic(dAtA, i, uint64(len(m.Payloads[iNdEx])))
			i--
			dAtA[i] = 0x12
		}
	}
	if len(m.Header) > 0 {
		i -= len(m.Header)
		copy(dAtA[i:], m.Header)
		i = encodeVarintFlic(dAtA, i, uint64(len(m.Header)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *Append) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Append) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Append) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Batch != nil {
		{
			size, err := m.Batch.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintFlic(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	if m.Seq != nil {
		{
			size, err := m.Seq.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintFlic(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *Subject) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Subject) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Subject) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Digest) > 0 {
		i -= len(m.Digest)
		copy(dAtA[i:], m.Digest)
		i = encodeVarintFlic(dAtA, i, uint64(len(m.Digest)))
		i--
		dAtA[i] = 0x12
	}
	if m.Seq != nil {
		{
			size, err := m.Seq.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintFlic(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *Confirm) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Confirm) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Confirm) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Digest) > 0 {
		i -= len(m.Digest)
		copy(dAtA[i:], m.Digest)
		i = encodeVarintFlic(dAtA, i, uint64(len(m.Digest)))
		i--
		dAtA[i] = 0x12
	}
	if m.Seq != nil {
		{
			size, err := m.Seq.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintFlic(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *Commit) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Commit) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Commit) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Signatures) > 0 {
		for k := range m.Signatures {
			v := m.Signatures[k]
			baseI := i
			if len(v) > 0 {
				i -= len(v)
				copy(dAtA[i:], v)
				i = encodeVarintFlic(dAtA, i, uint64(len(v)))
				i--
				dAtA[i] = 0x12
			}
			i = encodeVarintFlic(dAtA, i, uint64(k))
			i--
			dAtA[i] = 0x8
			i = encodeVarintFlic(dAtA, i, uint64(baseI-i))
			i--
			dAtA[i] = 0x1a
		}
	}
	if len(m.Digest) > 0 {
		i -= len(m.Digest)
		copy(dAtA[i:], m.Digest)
		i = encodeVarintFlic(dAtA, i, uint64(len(m.Digest)))
		i--
		dAtA[i] = 0x12
	}
	if m.Seq != nil {
		{
			size, err := m.Seq.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintFlic(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *ViewChange) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ViewChange) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ViewChange) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Batchheader) > 0 {
		i -= len(m.Batchheader)
		copy(dAtA[i:], m.Batchheader)
		i = encodeVarintFlic(dAtA, i, uint64(len(m.Batchheader)))
		i--
		dAtA[i] = 0x1a
	}
	if m.Seq != 0 {
		i = encodeVarintFlic(dAtA, i, uint64(m.Seq))
		i--
		dAtA[i] = 0x10
	}
	if m.View != 0 {
		i = encodeVarintFlic(dAtA, i, uint64(m.View))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *NewView) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *NewView) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *NewView) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Signatures) > 0 {
		for k := range m.Signatures {
			v := m.Signatures[k]
			baseI := i
			if len(v) > 0 {
				i -= len(v)
				copy(dAtA[i:], v)
				i = encodeVarintFlic(dAtA, i, uint64(len(v)))
				i--
				dAtA[i] = 0x12
			}
			i = encodeVarintFlic(dAtA, i, uint64(k))
			i--
			dAtA[i] = 0x8
			i = encodeVarintFlic(dAtA, i, uint64(baseI-i))
			i--
			dAtA[i] = 0x22
		}
	}
	if m.Batch != nil {
		{
			size, err := m.Batch.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintFlic(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1a
	}
	if m.Seq != 0 {
		i = encodeVarintFlic(dAtA, i, uint64(m.Seq))
		i--
		dAtA[i] = 0x10
	}
	if m.View != 0 {
		i = encodeVarintFlic(dAtA, i, uint64(m.View))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *QueryDiff) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *QueryDiff) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *QueryDiff) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Seq != 0 {
		i = encodeVarintFlic(dAtA, i, uint64(m.Seq))
		i--
		dAtA[i] = 0x10
	}
	if m.View != 0 {
		i = encodeVarintFlic(dAtA, i, uint64(m.View))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *PkgHeader) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *PkgHeader) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *PkgHeader) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Hash) > 0 {
		i -= len(m.Hash)
		copy(dAtA[i:], m.Hash)
		i = encodeVarintFlic(dAtA, i, uint64(len(m.Hash)))
		i--
		dAtA[i] = 0x1a
	}
	if m.End != 0 {
		i = encodeVarintFlic(dAtA, i, uint64(m.End))
		i--
		dAtA[i] = 0x10
	}
	if m.Start != 0 {
		i = encodeVarintFlic(dAtA, i, uint64(m.Start))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *RecoveryPkg) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *RecoveryPkg) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *RecoveryPkg) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Blocks) > 0 {
		for iNdEx := len(m.Blocks) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Blocks[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintFlic(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *RspDiff) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *RspDiff) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *RspDiff) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.PkgHeaders) > 0 {
		for iNdEx := len(m.PkgHeaders) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.PkgHeaders[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintFlic(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x1a
		}
	}
	if m.Status != 0 {
		i = encodeVarintFlic(dAtA, i, uint64(m.Status))
		i--
		dAtA[i] = 0x10
	}
	if m.View != 0 {
		i = encodeVarintFlic(dAtA, i, uint64(m.View))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *QueryPkg) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *QueryPkg) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *QueryPkg) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.End != 0 {
		i = encodeVarintFlic(dAtA, i, uint64(m.End))
		i--
		dAtA[i] = 0x10
	}
	if m.Start != 0 {
		i = encodeVarintFlic(dAtA, i, uint64(m.Start))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *RspPkg) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *RspPkg) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *RspPkg) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Pkg != nil {
		{
			size, err := m.Pkg.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintFlic(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *Finish) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Finish) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Finish) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Status != 0 {
		i = encodeVarintFlic(dAtA, i, uint64(m.Status))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func encodeVarintFlic(dAtA []byte, offset int, v uint64) int {
	offset -= sovFlic(v)
	base := offset
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return base
}
func (m *Flic) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Type != nil {
		n += m.Type.Size()
	}
	return n
}

func (m *Flic_Request) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Request != nil {
		l = m.Request.Size()
		n += 1 + l + sovFlic(uint64(l))
	}
	return n
}
func (m *Flic_Append) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Append != nil {
		l = m.Append.Size()
		n += 1 + l + sovFlic(uint64(l))
	}
	return n
}
func (m *Flic_Confirm) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Confirm != nil {
		l = m.Confirm.Size()
		n += 1 + l + sovFlic(uint64(l))
	}
	return n
}
func (m *Flic_Commit) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Commit != nil {
		l = m.Commit.Size()
		n += 1 + l + sovFlic(uint64(l))
	}
	return n
}
func (m *Flic_Viewchange) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Viewchange != nil {
		l = m.Viewchange.Size()
		n += 1 + l + sovFlic(uint64(l))
	}
	return n
}
func (m *Flic_Newview) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Newview != nil {
		l = m.Newview.Size()
		n += 1 + l + sovFlic(uint64(l))
	}
	return n
}
func (m *Flic_QueryDiff) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.QueryDiff != nil {
		l = m.QueryDiff.Size()
		n += 1 + l + sovFlic(uint64(l))
	}
	return n
}
func (m *Flic_RspDiff) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.RspDiff != nil {
		l = m.RspDiff.Size()
		n += 1 + l + sovFlic(uint64(l))
	}
	return n
}
func (m *Flic_QueryPkg) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.QueryPkg != nil {
		l = m.QueryPkg.Size()
		n += 1 + l + sovFlic(uint64(l))
	}
	return n
}
func (m *Flic_RspPkg) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.RspPkg != nil {
		l = m.RspPkg.Size()
		n += 1 + l + sovFlic(uint64(l))
	}
	return n
}
func (m *Flic_Finish) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Finish != nil {
		l = m.Finish.Size()
		n += 1 + l + sovFlic(uint64(l))
	}
	return n
}
func (m *Request) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Payload)
	if l > 0 {
		n += 1 + l + sovFlic(uint64(l))
	}
	return n
}

func (m *SeqView) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.View != 0 {
		n += 1 + sovFlic(uint64(m.View))
	}
	if m.Seq != 0 {
		n += 1 + sovFlic(uint64(m.Seq))
	}
	return n
}

func (m *BatchHeader) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Seq != 0 {
		n += 1 + sovFlic(uint64(m.Seq))
	}
	l = len(m.DataHash)
	if l > 0 {
		n += 1 + l + sovFlic(uint64(l))
	}
	return n
}

func (m *Batch) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Header)
	if l > 0 {
		n += 1 + l + sovFlic(uint64(l))
	}
	if len(m.Payloads) > 0 {
		for _, b := range m.Payloads {
			l = len(b)
			n += 1 + l + sovFlic(uint64(l))
		}
	}
	if len(m.Signatures) > 0 {
		for k, v := range m.Signatures {
			_ = k
			_ = v
			l = 0
			if len(v) > 0 {
				l = 1 + len(v) + sovFlic(uint64(len(v)))
			}
			mapEntrySize := 1 + sovFlic(uint64(k)) + l
			n += mapEntrySize + 1 + sovFlic(uint64(mapEntrySize))
		}
	}
	return n
}

func (m *Append) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Seq != nil {
		l = m.Seq.Size()
		n += 1 + l + sovFlic(uint64(l))
	}
	if m.Batch != nil {
		l = m.Batch.Size()
		n += 1 + l + sovFlic(uint64(l))
	}
	return n
}

func (m *Subject) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Seq != nil {
		l = m.Seq.Size()
		n += 1 + l + sovFlic(uint64(l))
	}
	l = len(m.Digest)
	if l > 0 {
		n += 1 + l + sovFlic(uint64(l))
	}
	return n
}

func (m *Confirm) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Seq != nil {
		l = m.Seq.Size()
		n += 1 + l + sovFlic(uint64(l))
	}
	l = len(m.Digest)
	if l > 0 {
		n += 1 + l + sovFlic(uint64(l))
	}
	return n
}

func (m *Commit) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Seq != nil {
		l = m.Seq.Size()
		n += 1 + l + sovFlic(uint64(l))
	}
	l = len(m.Digest)
	if l > 0 {
		n += 1 + l + sovFlic(uint64(l))
	}
	if len(m.Signatures) > 0 {
		for k, v := range m.Signatures {
			_ = k
			_ = v
			l = 0
			if len(v) > 0 {
				l = 1 + len(v) + sovFlic(uint64(len(v)))
			}
			mapEntrySize := 1 + sovFlic(uint64(k)) + l
			n += mapEntrySize + 1 + sovFlic(uint64(mapEntrySize))
		}
	}
	return n
}

func (m *ViewChange) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.View != 0 {
		n += 1 + sovFlic(uint64(m.View))
	}
	if m.Seq != 0 {
		n += 1 + sovFlic(uint64(m.Seq))
	}
	l = len(m.Batchheader)
	if l > 0 {
		n += 1 + l + sovFlic(uint64(l))
	}
	return n
}

func (m *NewView) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.View != 0 {
		n += 1 + sovFlic(uint64(m.View))
	}
	if m.Seq != 0 {
		n += 1 + sovFlic(uint64(m.Seq))
	}
	if m.Batch != nil {
		l = m.Batch.Size()
		n += 1 + l + sovFlic(uint64(l))
	}
	if len(m.Signatures) > 0 {
		for k, v := range m.Signatures {
			_ = k
			_ = v
			l = 0
			if len(v) > 0 {
				l = 1 + len(v) + sovFlic(uint64(len(v)))
			}
			mapEntrySize := 1 + sovFlic(uint64(k)) + l
			n += mapEntrySize + 1 + sovFlic(uint64(mapEntrySize))
		}
	}
	return n
}

func (m *QueryDiff) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.View != 0 {
		n += 1 + sovFlic(uint64(m.View))
	}
	if m.Seq != 0 {
		n += 1 + sovFlic(uint64(m.Seq))
	}
	return n
}

func (m *PkgHeader) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Start != 0 {
		n += 1 + sovFlic(uint64(m.Start))
	}
	if m.End != 0 {
		n += 1 + sovFlic(uint64(m.End))
	}
	l = len(m.Hash)
	if l > 0 {
		n += 1 + l + sovFlic(uint64(l))
	}
	return n
}

func (m *RecoveryPkg) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Blocks) > 0 {
		for _, e := range m.Blocks {
			l = e.Size()
			n += 1 + l + sovFlic(uint64(l))
		}
	}
	return n
}

func (m *RspDiff) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.View != 0 {
		n += 1 + sovFlic(uint64(m.View))
	}
	if m.Status != 0 {
		n += 1 + sovFlic(uint64(m.Status))
	}
	if len(m.PkgHeaders) > 0 {
		for _, e := range m.PkgHeaders {
			l = e.Size()
			n += 1 + l + sovFlic(uint64(l))
		}
	}
	return n
}

func (m *QueryPkg) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Start != 0 {
		n += 1 + sovFlic(uint64(m.Start))
	}
	if m.End != 0 {
		n += 1 + sovFlic(uint64(m.End))
	}
	return n
}

func (m *RspPkg) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Pkg != nil {
		l = m.Pkg.Size()
		n += 1 + l + sovFlic(uint64(l))
	}
	return n
}

func (m *Finish) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Status != 0 {
		n += 1 + sovFlic(uint64(m.Status))
	}
	return n
}

func sovFlic(x uint64) (n int) {
	return (math_bits.Len64(x|1) + 6) / 7
}
func sozFlic(x uint64) (n int) {
	return sovFlic(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (m *Flic) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowFlic
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Flic: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Flic: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Request", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFlic
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthFlic
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthFlic
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &Request{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Type = &Flic_Request{v}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Append", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFlic
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthFlic
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthFlic
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &Append{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Type = &Flic_Append{v}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Confirm", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFlic
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthFlic
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthFlic
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &Confirm{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Type = &Flic_Confirm{v}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Commit", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFlic
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthFlic
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthFlic
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &Commit{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Type = &Flic_Commit{v}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Viewchange", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFlic
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthFlic
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthFlic
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &ViewChange{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Type = &Flic_Viewchange{v}
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Newview", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFlic
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthFlic
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthFlic
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &NewView{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Type = &Flic_Newview{v}
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field QueryDiff", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFlic
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthFlic
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthFlic
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &QueryDiff{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Type = &Flic_QueryDiff{v}
			iNdEx = postIndex
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RspDiff", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFlic
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthFlic
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthFlic
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &RspDiff{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Type = &Flic_RspDiff{v}
			iNdEx = postIndex
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field QueryPkg", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFlic
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthFlic
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthFlic
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &QueryPkg{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Type = &Flic_QueryPkg{v}
			iNdEx = postIndex
		case 10:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RspPkg", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFlic
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthFlic
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthFlic
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &RspPkg{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Type = &Flic_RspPkg{v}
			iNdEx = postIndex
		case 11:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Finish", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFlic
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthFlic
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthFlic
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &Finish{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Type = &Flic_Finish{v}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipFlic(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthFlic
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Request) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowFlic
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Request: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Request: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Payload", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFlic
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthFlic
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthFlic
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Payload = append(m.Payload[:0], dAtA[iNdEx:postIndex]...)
			if m.Payload == nil {
				m.Payload = []byte{}
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipFlic(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthFlic
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SeqView) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowFlic
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SeqView: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SeqView: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field View", wireType)
			}
			m.View = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFlic
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.View |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Seq", wireType)
			}
			m.Seq = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFlic
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Seq |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipFlic(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthFlic
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *BatchHeader) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowFlic
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: BatchHeader: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: BatchHeader: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Seq", wireType)
			}
			m.Seq = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFlic
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Seq |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DataHash", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFlic
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthFlic
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthFlic
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.DataHash = append(m.DataHash[:0], dAtA[iNdEx:postIndex]...)
			if m.DataHash == nil {
				m.DataHash = []byte{}
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipFlic(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthFlic
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Batch) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowFlic
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Batch: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Batch: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Header", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFlic
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthFlic
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthFlic
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Header = append(m.Header[:0], dAtA[iNdEx:postIndex]...)
			if m.Header == nil {
				m.Header = []byte{}
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Payloads", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFlic
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthFlic
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthFlic
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Payloads = append(m.Payloads, make([]byte, postIndex-iNdEx))
			copy(m.Payloads[len(m.Payloads)-1], dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Signatures", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFlic
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthFlic
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthFlic
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Signatures == nil {
				m.Signatures = make(map[uint64][]byte)
			}
			var mapkey uint64
			mapvalue := []byte{}
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowFlic
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowFlic
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapkey |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
				} else if fieldNum == 2 {
					var mapbyteLen uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowFlic
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapbyteLen |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intMapbyteLen := int(mapbyteLen)
					if intMapbyteLen < 0 {
						return ErrInvalidLengthFlic
					}
					postbytesIndex := iNdEx + intMapbyteLen
					if postbytesIndex < 0 {
						return ErrInvalidLengthFlic
					}
					if postbytesIndex > l {
						return io.ErrUnexpectedEOF
					}
					mapvalue = make([]byte, mapbyteLen)
					copy(mapvalue, dAtA[iNdEx:postbytesIndex])
					iNdEx = postbytesIndex
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipFlic(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if (skippy < 0) || (iNdEx+skippy) < 0 {
						return ErrInvalidLengthFlic
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.Signatures[mapkey] = mapvalue
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipFlic(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthFlic
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Append) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowFlic
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Append: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Append: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Seq", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFlic
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthFlic
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthFlic
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Seq == nil {
				m.Seq = &SeqView{}
			}
			if err := m.Seq.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Batch", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFlic
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthFlic
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthFlic
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Batch == nil {
				m.Batch = &Batch{}
			}
			if err := m.Batch.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipFlic(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthFlic
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Subject) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowFlic
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Subject: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Subject: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Seq", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFlic
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthFlic
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthFlic
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Seq == nil {
				m.Seq = &SeqView{}
			}
			if err := m.Seq.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Digest", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFlic
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthFlic
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthFlic
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Digest = append(m.Digest[:0], dAtA[iNdEx:postIndex]...)
			if m.Digest == nil {
				m.Digest = []byte{}
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipFlic(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthFlic
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Confirm) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowFlic
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Confirm: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Confirm: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Seq", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFlic
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthFlic
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthFlic
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Seq == nil {
				m.Seq = &SeqView{}
			}
			if err := m.Seq.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Digest", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFlic
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthFlic
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthFlic
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Digest = append(m.Digest[:0], dAtA[iNdEx:postIndex]...)
			if m.Digest == nil {
				m.Digest = []byte{}
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipFlic(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthFlic
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Commit) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowFlic
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Commit: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Commit: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Seq", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFlic
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthFlic
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthFlic
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Seq == nil {
				m.Seq = &SeqView{}
			}
			if err := m.Seq.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Digest", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFlic
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthFlic
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthFlic
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Digest = append(m.Digest[:0], dAtA[iNdEx:postIndex]...)
			if m.Digest == nil {
				m.Digest = []byte{}
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Signatures", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFlic
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthFlic
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthFlic
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Signatures == nil {
				m.Signatures = make(map[uint64][]byte)
			}
			var mapkey uint64
			mapvalue := []byte{}
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowFlic
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowFlic
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapkey |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
				} else if fieldNum == 2 {
					var mapbyteLen uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowFlic
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapbyteLen |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intMapbyteLen := int(mapbyteLen)
					if intMapbyteLen < 0 {
						return ErrInvalidLengthFlic
					}
					postbytesIndex := iNdEx + intMapbyteLen
					if postbytesIndex < 0 {
						return ErrInvalidLengthFlic
					}
					if postbytesIndex > l {
						return io.ErrUnexpectedEOF
					}
					mapvalue = make([]byte, mapbyteLen)
					copy(mapvalue, dAtA[iNdEx:postbytesIndex])
					iNdEx = postbytesIndex
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipFlic(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if (skippy < 0) || (iNdEx+skippy) < 0 {
						return ErrInvalidLengthFlic
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.Signatures[mapkey] = mapvalue
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipFlic(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthFlic
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ViewChange) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowFlic
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ViewChange: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ViewChange: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field View", wireType)
			}
			m.View = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFlic
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.View |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Seq", wireType)
			}
			m.Seq = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFlic
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Seq |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Batchheader", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFlic
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthFlic
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthFlic
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Batchheader = append(m.Batchheader[:0], dAtA[iNdEx:postIndex]...)
			if m.Batchheader == nil {
				m.Batchheader = []byte{}
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipFlic(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthFlic
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *NewView) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowFlic
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: NewView: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: NewView: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field View", wireType)
			}
			m.View = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFlic
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.View |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Seq", wireType)
			}
			m.Seq = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFlic
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Seq |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Batch", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFlic
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthFlic
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthFlic
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Batch == nil {
				m.Batch = &Batch{}
			}
			if err := m.Batch.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Signatures", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFlic
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthFlic
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthFlic
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Signatures == nil {
				m.Signatures = make(map[uint64][]byte)
			}
			var mapkey uint64
			mapvalue := []byte{}
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowFlic
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowFlic
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapkey |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
				} else if fieldNum == 2 {
					var mapbyteLen uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowFlic
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapbyteLen |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intMapbyteLen := int(mapbyteLen)
					if intMapbyteLen < 0 {
						return ErrInvalidLengthFlic
					}
					postbytesIndex := iNdEx + intMapbyteLen
					if postbytesIndex < 0 {
						return ErrInvalidLengthFlic
					}
					if postbytesIndex > l {
						return io.ErrUnexpectedEOF
					}
					mapvalue = make([]byte, mapbyteLen)
					copy(mapvalue, dAtA[iNdEx:postbytesIndex])
					iNdEx = postbytesIndex
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipFlic(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if (skippy < 0) || (iNdEx+skippy) < 0 {
						return ErrInvalidLengthFlic
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.Signatures[mapkey] = mapvalue
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipFlic(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthFlic
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *QueryDiff) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowFlic
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: QueryDiff: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: QueryDiff: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field View", wireType)
			}
			m.View = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFlic
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.View |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Seq", wireType)
			}
			m.Seq = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFlic
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Seq |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipFlic(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthFlic
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *PkgHeader) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowFlic
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: PkgHeader: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: PkgHeader: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Start", wireType)
			}
			m.Start = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFlic
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Start |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field End", wireType)
			}
			m.End = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFlic
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.End |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Hash", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFlic
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthFlic
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthFlic
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Hash = append(m.Hash[:0], dAtA[iNdEx:postIndex]...)
			if m.Hash == nil {
				m.Hash = []byte{}
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipFlic(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthFlic
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *RecoveryPkg) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowFlic
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: RecoveryPkg: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: RecoveryPkg: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Blocks", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFlic
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthFlic
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthFlic
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Blocks = append(m.Blocks, &common.Block{})
			if err := m.Blocks[len(m.Blocks)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipFlic(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthFlic
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *RspDiff) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowFlic
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: RspDiff: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: RspDiff: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field View", wireType)
			}
			m.View = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFlic
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.View |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Status", wireType)
			}
			m.Status = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFlic
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Status |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PkgHeaders", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFlic
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthFlic
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthFlic
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.PkgHeaders = append(m.PkgHeaders, &PkgHeader{})
			if err := m.PkgHeaders[len(m.PkgHeaders)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipFlic(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthFlic
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *QueryPkg) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowFlic
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: QueryPkg: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: QueryPkg: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Start", wireType)
			}
			m.Start = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFlic
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Start |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field End", wireType)
			}
			m.End = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFlic
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.End |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipFlic(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthFlic
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *RspPkg) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowFlic
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: RspPkg: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: RspPkg: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Pkg", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFlic
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthFlic
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthFlic
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Pkg == nil {
				m.Pkg = &RecoveryPkg{}
			}
			if err := m.Pkg.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipFlic(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthFlic
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Finish) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowFlic
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Finish: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Finish: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Status", wireType)
			}
			m.Status = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowFlic
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Status |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipFlic(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthFlic
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipFlic(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	depth := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowFlic
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowFlic
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
		case 1:
			iNdEx += 8
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowFlic
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if length < 0 {
				return 0, ErrInvalidLengthFlic
			}
			iNdEx += length
		case 3:
			depth++
		case 4:
			if depth == 0 {
				return 0, ErrUnexpectedEndOfGroupFlic
			}
			depth--
		case 5:
			iNdEx += 4
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
		if iNdEx < 0 {
			return 0, ErrInvalidLengthFlic
		}
		if depth == 0 {
			return iNdEx, nil
		}
	}
	return 0, io.ErrUnexpectedEOF
}

var (
	ErrInvalidLengthFlic        = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowFlic          = fmt.Errorf("proto: integer overflow")
	ErrUnexpectedEndOfGroupFlic = fmt.Errorf("proto: unexpected end of group")
)
